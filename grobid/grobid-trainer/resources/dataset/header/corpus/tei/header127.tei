<tei>
	<teiHeader>
	<fileDesc xml:id="128"/>
	</teiHeader>
<text xml:lang="en">
		<front>
		<docTitle>
			<titlePart type="main">Real-Time Computing with Lock-Free Shared Objects <lb/></titlePart>
		</docTitle>
		<byline><docAuthor>James H. Anderson Srikanth Ramamurthy Kevin Jeffay <lb/></docAuthor></byline>
		<byline><affiliation>Department of Computer Science, University of North Carolina,</affiliation></byline>
		<address>Chapel Hill, NC 27599-3175 <lb/></address>
		<div type="abstract">Abstract <lb/>This paper considers the use of lock-free shared objects <lb/>within hard real-time systems. As the name suggests, <lb/>lock-free shared objects are distinguished by the fact <lb/>that they are not locked. As such, they do not give <lb/>rise to priority inversions, a key advantage over conventional, lock-based object-sharing approaches. Despite this advantage, it is not immediately apparent <lb/>that lock-free shared objects can be employed if tasks <lb/>must adhere to strict timing constraints. In particular, <lb/>lock-free object implementations permit concurrent operations to interfere with each other, and repeated interferences can cause a given operation to take an arbitrarily long time to complete. <lb/>The main contribution of this paper is to show that <lb/>such interferences can be bounded by judicious scheduling. This work pertains to periodic, hard real-time <lb/>tasks that share lock-free objects on a uniprocessor. In <lb/>the first part of the paper, scheduling conditions are derived for such tasks, for both static and dynamic priority schemes. Based on these conditions, it is formally <lb/>shown that lock-free object-sharing approaches can be <lb/>expected to incur much less overhead than approaches <lb/>based on wait-free objects or lock-based schemes. In <lb/>the last part of the paper, this conclusion is validated experimentally through work involving a real-time desktop videoconferencing system. <lb/></div>
		<div type="intro">1 Introduction</div>
		</front>
</text>
</tei>