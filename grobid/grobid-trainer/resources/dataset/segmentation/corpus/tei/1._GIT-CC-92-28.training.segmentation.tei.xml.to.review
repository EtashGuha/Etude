<?xml version="1.0"?>
<tei>
	<teiHeader>
		<fileDesc xml:id="_GIT-CC-92-28"/>
	</teiHeader>
	<text xml:lang="en">
		<front>Protocols for Collecting Responses in Multi-hop Radio Networks<lb/> Chungki Lee James E. Burns Mostafa H. Ammar<lb/> GIT{CC{92/28<lb/> June 1992<lb/> Abstract<lb/> The problem of collecting responses in multi-hop radio networks is consid-ered. A given node, called the source, is to collect a speciied number of responses from nodes in a radio network. The problem arises in several applications of distributed systems. A deterministic and a randomized pro-tocol for the problem are presented. The two protocols are analyzed and their performance is compared. Conclusions are drawn about the suitability of our protocols in various network environments.<lb/> College of Computing Georgia Institute of Technology Atlanta, Georgia 30332{0280<lb/> THIS PAGE INTENTIONALLY LEFT BLANK.<lb/></front>
		
		<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/> 1<lb/></note>
		
		<body>1 Introduction<lb/> A radio network is a collection of radios that communicate with each other over radio channels. If all units in a radio network can hear each other, the radio network is single-hop; otherwise it is multi-hop and repeaters must be used to provide network connectivity. In this paper, the problem of collecting responses in multi-hop radio networks is considered. A given node, called the source, is to collect a speciied number of responses from nodes in a radio network. Developing protocols for the problem in multi-hop radio networks is a complicated task. The diiculties emerge both from the unknown topology of the network and from the possibility of connicts (i.e., situations when several neighbors of a node transmit simultaneously and the node receives only noise). The collection problem arises in several applications of distributed systems. In a distributed database system, a central node broadcasts a series of queries and collects the responses to the queries from multiple nodes &#x6EF59;Nat85]. In a computer network, a node may need to &#x6EF59;nd the location of multiple instances of a resource &#x6EF59;MV88], or to know the network topology for routing and control purposes &#x6EF59;HS88]. The collection problem has been studied in several diierent contexts AS87, AR90, BII89, WS89]. Afek and Saks AS87] introduced a \token collection" problem, in which a distinguished node collects a speciied number of tokens from other nodes in a point-to-point computer network. Tokens appear spontaneously at the nodes at arbitrary times. Ammar and Rouskas &#x6EF59;AR90] introduced a \response collection" problem in which a collector is interested in gathering a set of responses from a number of potential respon-dents. The collector and respondents communicate over a shared single-hop channel with feedback. They deened three collection objectives and investigated a suite of protocols that can be used to achieve these objectives. Wang and Silvester WS89] pre-sented protocols to optimize the performance of response traac for broadcast messages in a single-hop radio network. They assumed that the exact number of nodes is un-known, which makes the problem nontrivial. In multi-hop radio networks, Bar-Yehuda et al. BII89] developed a randomized collection protocol as a subprotocol of multiple broadcasts. This protocol sends the broadcast messages from multiple sources to the root of the BFS tree that has been constructed before any broadcasts are performed. In this paper, a deterministic protocol and a randomized protocol for collecting responses in multi-hop radio networks are presented. The performance of the two protocols is analyzed and conclusions are drawn about the suitability of the protocols in various network environments. This paper is organized as follows. In Section 2, a model of radio networks is presented, and in Section 3 the collection problem is deened. A simple depth rst search protocol is described in Section 4, while Sections 5 and 6 describe our deterministic and randomized protocols, respectively. Section 7 compares the performance of our protocols. Section 8 concludes the paper.<lb/>

			<page>2<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			2 The Model<lb/> A radio network is modeled by a connected, undirected graph whose vertices represent nodes (radios) and whose edges represent two-way communication channels between their incident vertices. Thus, we assume that adjacent radios are of comparable power and are within range of each other. Nodes communicate in synchronous timeslots using radio transmissions. All nodes agree on the beginning of each timeslot. The length of a timeslot is assumed to be at least as long as the transmission time of the longest message plus the maximum propagation delay of messages between any pair of nodes. The properties of radio communication are described by the following rules. In each timeslot, a node can act either as a transmitter or as a receiver, but not both. Thus, a transmitting node cannot directly detect whether or not its transmission is successful. A node receives a message in a timeslot if it acts as a receiver and exactly one of its neighbors transmits. If more than one neighbor of a node transmits, a collision occurs. Except for collisions, channels are assumed to be error-free. We consider two possible cases for collisions:<lb/> 1. Collision Detection (CD). If a collision occurs, a receiving node detects the<lb/> presence of a collision by the amplitude of noise during the timeslot.<lb/> 2. No Collision Detection (NCD). Collisions are indistinguishable from back-<lb/> ground noise, so receiving nodes cannot determine reliably that a collision has occurred.<lb/> Obviously, protocols that do not rely on collision detection are more robust than those that do. Our deterministic protocol does not rely on collision detection, while our randomized protocol uses collision detection only for initial synchronization. In the concluding section we consider methods for eliminating the CD assumption of the ran-domized protocol.<lb/> 3 The Collection Problem<lb/> The Collection Problem simulates the task of gathering information (referred to as responses) from remote nodes and consolidating it within a single node (referred to as the source). A given execution of a protocol for the Collection Problem is parameterized by an integer K, 0 &lt; K &lt; N, indicating the number of responses to be gathered, where N is the number of nodes in the network. Other parameters of the network that are important for analysis are<lb/> &#x6EF59; D, the diameter of the network. &#x6EF59; , the maximum degree over all nodes in the network.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>3<lb/></page>

			Our randomized protocol makes use of the quantity , and so assumes this to be known globally (it is suucient to know an upper bound on ). The only other knowledge about the network required by our protocols is that each node has a unique identiier (ID) and initially knows the ID's of its neighbors. The primary complexity measure considered in this paper is the expected execution time (i.e., the number of timeslots to collect at least K responses). Secondary cost items, message size and local time and space requirements, are not considered here. Besides the communication characteristics of the radio network, the eeciency of collection protocols is sensitive to the initial conditions of the network. For simplicity in this paper, we assume that<lb/> &#x6EF59; Only a single collection by a single source is in progress at any point in time.<lb/> &#x6EF59; Each node has a response to send.<lb/> &#x6EF59; For the randomized protocol, the type of information to be collected is known in<lb/> advance.<lb/> In the absence of the last assumption, a preliminary broadcast phase could be used to designate the information to be collected.<lb/>

			4 The Depth First Search Protocol<lb/> A simple and obvious protocol, based on depth &#x6EF59;rst search, exists for any (connected) radio network. The depth rst search (DFS) protocol can be viewed as moving a token along the edges of a depth &#x6EF59;rst search tree. The token contains the ID's of previously visited nodes, so that back edges (i.e., those edges (u; v) that are not in the DFS tree and are connecting a node u to a previously visited node v) need not be followed. When backing up from a fully explored node, the token adds the response of that node to its information. Thus, a token message must be large enough to contain O(N) ID's and O(K) responses. Since back edges are not traversed, the DFS protocol takes exactly<lb/> 2K timeslots to explore the whole network (if K &lt; N &#x6EF59; 1, only part of the network is<lb/> explored). The DFS protocol as described does not make use of the broadcast nature of the radio medium. Therefore, it will be eecient only if the diameter of the network is approximately equal to the number of nodes, e.g., a line graph. For arbitrary networks with diameter typically less than N we expect other approaches to be superior. We consider two protocols, one deterministic and one randomized.<lb/>

			<page>4<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			5 The Deterministic Collection Protocol<lb/> 5.1 Informal Description<lb/> Deene the l-hop nodes to be those that are at distance l from the source and the lth level, or level(l), to be the set of l-hop nodes. The main idea of the protocol is to collect responses in phases: &#x6EF59;rst from one-hop nodes, then two-hop nodes, then three-hop nodes, etc., until at least K responses are collected. The l-hop topology of the network is a graph consisting of all the ID's of all nodes within distance l of the source and of all edges between such nodes, except for edges between nodes at distance l. At the end of phase (l&#x6EF59;1) of the protocol, the source knows the l-hop topology. (Note that initially, l = 1 and the source knows its neighbors | the one-hop nodes, so this condition is true at the beginning of the protocol.) The lth phase consists of a sequence of rounds, each of which gathers information from some of the l-hop nodes. In addition to the responses from the l-hop nodes, information about the ID's of their neighbors is also returned. This allows the source to determine the (l + 1)-hop topology in preparation for the next phase. The protocol terminates when the source has received at least K responses, after at most D phases. The major nontrivial parts of the protocol are described next. A complete description of the protocol is given in the appendix.<lb/> 5.1.1 Collecting Responses from l-hop Nodes<lb/> Assume that the source knows the l-hop topology at the beginning of phase l. The source uses two dynamic storage structures, called the current topology and the new topology, during the phase. At the beginning of the phase, current topology = new topology = l-hop topology. From any topology, we can construct a directed acyclic graph (DAG) by deleting edges between nodes at the same level and directing the remaining edges away from the source. In discussing the protocol, it is convenient to deene a node u to be a descendant of a node v if v is on some path in the DAG from the source to u. In this case, we also say v is above u and u is below v. Similarly, messages going to descendants on the next level go down, while those going to ancestors above go up. At the beginning of each round of the phase, the source constructs a communication tree for a subset of nodes within the current topology. The communication tree assigns a timeslot for each node in the tree to send (or forward) responses from the l-hop nodes. The construction technique guarantees that there is at least one (previously uncollected) l-hop node in the tree and that all communications are collision-free (as far as the intended recipient of each message is concerned). At the end of the round, the source modiies the new topology to include information from the leaves of the communication tree. The current topology is also modiied: All leaves in that round's communication tree are deleted from the current topology. Also, a recursive procedure is used to delete any nodes that no longer have l-hop nodes as descendants.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>5<lb/></page>

			In each round, at least one l-hop node is eliminated from the current topology. The phase terminates when all l-hop nodes have been eliminated. At this point, the new topology is equal to the (l + 1)-hop topology, and the next phase is ready to begin (unless at least K responses have already been collected, in which case the protocol terminates). Two types of messages are used by the protocol.<lb/> &#x6EF59; Collect messages are sent down the communication tree from the source and<lb/> forwarded in the next timeslot after reception by all internal nodes in the tree. (If necessary, Collect messages can also specify what type of information is to be collected.) A Collect message contains the communication tree (with timeslot assignments) for the current round. Collect messages do not collide at any nodes in the communication tree at the next level, and so are received at the leaves of the communication tree in exactly l timeslots.<lb/> &#x6EF59; Reply messages are sent up from the leaves and forwarded by the internal nodes.<lb/> Unlike Collect messages, Reply messages are only sent when the timeslot assigned to the sending node arrives (timeslot assignment is done relative to the time a node is ready to send). These timeslot assignments are designed to avoid collisions at the receiving nodes in the level above. The Reply message sent by a leaf contains the response of that node, its ID, and the IDs of its neighbors. Each internal node aggregates the Reply messages from its children and sends the aggregated Reply message to its parent in its assigned timeslot. The protocol to collect responses from all l-hop nodes is described in Figure 1. The value numwaitslot i represents the assigned timeslot of node i as stored in the communication tree T. An explanation of how communication trees are built and timeslots are assigned is presented in the following subsections.<lb/> 5.1.2 Building a Communication Tree of Height l<lb/> We build communication trees so that a message initiated by the source will be for-warded to the leaves of the tree in l timeslots without collisions. Note that there is at least one uncollected l-hop node before we begin building a tree, since otherwise the lth phase would terminate. The tree is constructed level by level top-down. That is,<lb/> nodes of level h, 1 &#x6EF59; h &lt; l, are included in the tree before any node of level h + 1.<lb/> Nodes from level h are added to the tree one node at a time. If a node of level h is included in the tree, another node of level h cannot be included whose simultaneous transmission would collide at their common neighbor(s) at level h + 1, because collision is not allowed at intended receivers in the protocol. We could add nodes of level h in any order, but the heuristic attempts to cover as many leaves as possible by including nodes in the order of the number of l-hop nodes that are their descendants. The heuristic is based on the rate of a node. Let node i be an internal node in the current topology. The rate of node i, Rate&#x6EF59;i], is deened to be the number of l-hop nodes<lb/>

			<page>6<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 

			1. Sketch of the protocol at the source: (Initially, new topology contains the source and its neighbors.) current topology = new topology.<lb/> repeat<lb/> Build a communication tree T (a subgraph of the current topology) with some l-hop nodes as leaves. Assign timeslots for nodes in the tree to send their Reply messages.<lb/> send a Collect message (which includes T). receive a Reply message from each child in the communication tree. if at least K responses from distinct nodes have been received, then exit.<lb/> Update new topology using new neighbors of leaves from Reply messages. Update current topology by deleting leaves of the communication tree and (recursively) internal nodes without l-hop nodes as descendants.<lb/> until the source receives responses from all l-hop nodes.<lb/> 2. Sketch of the protocol at non-source node i:<lb/> Set Counting := False; t := 0.<lb/> a. On receiving a Collect message containing communication tree T,<lb/> if i is an internal node in T, then forward Collect in the following timeslot;<lb/> also, set M to empty.<lb/> else if i is a leaf node in T, then set M to the Reply message for this node; also, set Counting := True. else do nothing.<lb/> b. On receiving a Reply message,<lb/> if i is in T and Reply is from a child of i, then concatenate Reply to M; also, if Reply's have been received from all children, set Counting := True. else do nothing.<lb/> c. For each timeslot,<lb/> if Counting then if t = numwaitslot i , then send M; also, set Counting := False; t := 0. else t := t + 1.<lb/> Figure 1: The Protocol to Collect Responses from l-hop Nodes<lb/> in the current topology that are descendants of node i. In the absence of collisions,<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>7<lb/></page>

			Rate&#x6EF59;i] would represent the number of l-hop nodes that could receive a message from node i. Due to collisions, some of those l-hop nodes might not receive the message from node i at all. However, Rate&#x6EF59;i] is an approximation of the number of l-hop nodes that may eventually occur in the tree if node i is included. Note that nding an optimal tree with the maximum number of l-hop nodes is too expensive because we would have to consider all possible trees of height l. Two nodes at level h are said to connict (relative to the current topology) if they have a common descendant at level h + 1. Our protocol uses the easily computed set, ConnictNodes&#x6EF59;i], which consists of all nodes that are at the same level as i and connict with i. Now we are ready to describe in detail the construction of a communication tree.<lb/> Initially, the tree includes only the source as its root. The nodes of level h, 1 &#x6EF59; h &lt; l,<lb/> are included as follows. All nodes of distance h that are neighbors of any node of level<lb/> h &#x6EF59; 1 in the tree are nodes that may possibly be included. Among them, we choose a<lb/> node with the maximum Rate, say node i. Ties are broken in favor of smaller ID. Node i is added to the tree, while all nodes in ConnictNodes&#x6EF59;i] are excluded. We repeat this selection process until the set of nodes at level h that have not already been included is empty. For level l (the level of the leaves), all nodes that are neighbors of previously<lb/> included nodes at level l &#x6EF59; 1 are included in the tree. The algorithm to construct a<lb/> communication tree of height l is described in Figure 2. Assigning timeslots to the nodes of the communication tree is discussed in the following subsection.<lb/> 5.1.3 Computing Timeslot Assignments<lb/> Assume that a communication tree T of height l has been constructed. The Collect message initiated by the source can be forwarded to all nodes on the tree without collisions. However, deciding when nodes should send Reply messages up the tree is more complicated. Because internal nodes send (aggregate) Reply messages only after they receive Reply messages from their children, the timeslots to send their Reply messages are assigned in a bottom-up fashion. It is easy to assign timeslots to leaves of the tree. For each node i at level l&#x6EF59;1, order the children of node i in increasing order of their ID's and assign timeslots 0; 1; 2; . . . to<lb/> them in that order. Note that children of diierent nodes at level l &#x6EF59; 1 are scheduled in<lb/> the same timeslots, but no collisions occur since their parents do not connict. Let us consider the problem of assigning timeslots to internal nodes of the tree. Each node has a rst timeslot in which it is ready to transmit its Reply message (this is the next timeslot after receiving Reply messages from all of its children in T). For a node x, we assign numwaitslot&#x6EF59;x] to be the number of timeslots a node must wait (possibly 0) after it is ready to send. Two types of collisions must be avoided:<lb/> Level connict. Collisions between nodes x and y at the same level caused by x sending<lb/> to its parent at the same time y is receiving from a child. This type of connict only occurs if x and y are connected by an edge of the network.<lb/>

			<page>8<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/> </note>
			
			Compute Rate&#x6EF59;x], ConnictNodes&#x6EF59;x] for each node x in the current topology dp := 1 CurrentNodes := neighbors of the source<lb/> T := fsourceg while dp &lt; l do NextNodes := ;; while CurrentNodes 6 = ; do<lb/> Let y be a node with maximum Rate over nodes in CurrentNodes;<lb/> T := T fyg; CurrentNodes := CurrentNodes &#x6EF59;fyg fzjz 2 ConnictNodes&#x6EF59;y]g; NextNodes := NextNodes fw 2 level(dp + 1)jw adjacent to yg end<lb/> CurrentNodes := NextNodes; dp := dp + 1<lb/> end T := T &#x6EF59; CurrentNodes<lb/> Figure 2: The Algorithm to Build a Communication Tree, T, of Height l<lb/> Sibling connict. Collisions of Reply messages from siblings to their common parent<lb/> in T. Level connicts are always resolved in favor of the node receiving a Reply message from a deeper level. Sibling connicts are resolved in favor of nodes with lower ID's. We assign numwaitslot&#x6EF59;x] to be the smallest value so that x has neither a level or sibling connict in the assigned timeslot. Details of the algorithm are given in Figure 3.<lb/> 5.1.4 Example<lb/> In order to illustrate the protocol, we execute it on a sample network given in Figure 4. The IDs of nodes are represented by numbers inside nodes and nodes connected by edges can communicate. Node 0 is the source. Suppose that the source has already collected responses from one-hop and two-hop nodes. The source wants to collect responses from three-hop nodes. The execution of the protocol by non-source nodes is straightforward and is omitted. The execution of the protocol by the source is as follows. 1. Before a tree is constructed, rates of one-hop and two-hop nodes are computed with their connicting nodes. Rate&#x6EF59;1] is 5 because node 8, 9, 10, 11, and 12 are three-hop nodes and are descendants of node 1 in the DAG deened above. Sim-ilarly, Rate&#x6EF59;2] = 3. Also, Rate&#x6EF59;4] = 3, Rate&#x6EF59;3] = Rate&#x6EF59;6] = Rate&#x6EF59;7] = 2, and<lb/> Rate5] = 1. ConnictNodes1] = ConnictNodes2] = ; because node 1 and 2 have<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>9<lb/></page>

			(* sibling&#x6EF59;x] is a set of siblings of node x *) (* children&#x6EF59;x] is a set of children of node x *)<lb/> for node x 2 T \ level(l) do Let x be the j-th element in sibling&#x6EF59;x]; oldslotno&#x6EF59;x] := 1; numwaitslot&#x6EF59;x] := j &#x6EF59; 1 for d := l &#x6EF59; 1 downto 1 do (* decide when internal nodes in T are to send Reply *) NT := T \ level(d); for node x 2 NT do oldslotno&#x6EF59;x] := max(oldslotno&#x6EF59;y] + numwaitslot&#x6EF59;y]) + 1, where y 2 children&#x6EF59;x];<lb/> newslotno&#x6EF59;x] := oldslotno&#x6EF59;x]<lb/> for node x 2 NT do for node y 2 NT do if y 6 = x and y adjacent to x then (* x may wait for y to nish collecting *) if oldslotno&#x6EF59;x] &#x6EF59; oldslotno&#x6EF59;y] jchildren&#x6EF59;y]j then<lb/> newslotno&#x6EF59;x] := max (newslotno&#x6EF59;x]; oldslotno&#x6EF59;y])<lb/> while NT 6 = ; do (* assign waiting timeslots *) Let x be a node in NT; NT := NT &#x6EF59; sibling&#x6EF59;x]; for node y 2 sibling&#x6EF59;x] do (* tie is broken in favor of smaller ID *) Let newslotno&#x6EF59;y] be the j-th element in fnewslotno&#x6EF59;z] j z 2 sibling&#x6EF59;x]g;<lb/> index&#x6EF59;j] := y cno := newslotno&#x6EF59;index&#x6EF59;1]]; wno := 0;<lb/> numwaitslot&#x6EF59;index1]] := wno + (cno &#x6EF59; oldslotno&#x6EF59;index&#x6EF59;1]]); for i := 2 to jsibling&#x6EF59;x]j do if newslotno&#x6EF59;index&#x6EF59;i]] = cno then wno := wno + 1; else cno := newslotno&#x6EF59;index&#x6EF59;i]]; numwaitslot&#x6EF59;index&#x6EF59;i]] := wno + (newslotno&#x6EF59;index&#x6EF59;i]] &#x6EF59; oldslotno&#x6EF59;index&#x6EF59;i]]) end<lb/> Figure 3: The Algorithm for Assigning Timeslots to the Nodes in T<lb/> no common neighbor of distance 2 and so can send simultaneously. Similarly,<lb/> ConnictNodes&#x6EF59;5] = ;. However, ConnictNodes&#x6EF59;3] = f4g and ConnictNodes&#x6EF59;4] = f3g because node 3 and 4 have a common neighbor (node 9) of distance<lb/> 3 and their simultaneous transmissions will collide at the neighbor. Similarly,<lb/> ConnictNodes6] = f7g and ConnictNodes7] = f6g.<lb/> 2. Now the source is ready to build a communication tree. The tree is built level-by-level top-down. The source becomes the root. Then nodes of level 1 are included. Node 1 is selected rst because Rate1] = 5 &gt; 3 = Rate&#x6EF59;2]. Since ConnictNodes&#x6EF59;1] is empty, node 2 is selected next. Now neighbors of node 1 and 2 of distance 2 (i.e., node 3, 4, 5, 6, and 7) become potential nodes that can be included as<lb/>

			<page>10<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			0<lb/> 1 2<lb/> 3 4 5 6 7<lb/> 8 9 10 11 12 14 15 13<lb/> Figure 4: The Sample Network<lb/> nodes of level 2. Node 4 is selected because it has the maximum rate. Now node<lb/> 3 cannot be selected because ConnictNodes&#x6EF59;4] = f3g. Then node 6 is selected<lb/> and so node 7 is excluded. Finally node 5 is selected. All neighbors of node 4, 5, and 6 of distance 3 are included as leaves of the tree. The &#x6EF59;nal tree is shown in Figure 5. The dotted lines represent non-tree edges.<lb/> 3. The Collect message initiated by the source can be forwarded to all nodes on the tree in 3 timeslots without collisions. Now consider assigning timeslots for nodes to send Reply messages. This is done in a bottom-up fashion. Let numwaitslot&#x6EF59;x] be the number of timeslots to wait after node x is ready to send its Reply message. Node 9, 10, and 11 are siblings and so can send their Reply messages in the ascending order of their ID's. Thus numwaitslot9] = 0, numwaitslot10] = 1, and numwaitslot&#x6EF59;11] = 2. Similarly, numwaitslot&#x6EF59;13] = 0 and numwaitslot&#x6EF59;14] = 1. Also numwaitslot&#x6EF59;12] = 0. Consider nodes of level 2. Node 5 is ready to send a<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note> 
			
			<page>11<lb/></page> 
			
			0<lb/> 1 2<lb/> 4 5 6<lb/> 9 10 11 12 14 13<lb/> Figure 5: The Communication Tree<lb/> Reply message in timeslot 5 but must wait for node 4 to nish receiving all Reply messages because a level connict due to an edge (4,5) must be avoided (i.e., a transmission without waiting would collide at node 4 with that of node 10). Then it must wait for one more timeslot because a sibling connict must be avoided and its ID is greater than 4. Therefore numwaitslot5] = 3. On the other hand, node 4 need not wait after it receives all Reply messages because its ID is less than 5. Thus numwaitslot&#x6EF59;4] = 0. Also numwaitslot&#x6EF59;6] = 0 because node 6 has neither a level nor a sibling connict. Finally consider nodes of level 1. Node 2 must wait for node 1 to receive all Reply messages because a level connict due to an edge (1,2) must be avoided (i.e., a transmission without waiting would collide at node 1 with that of node 4). Then it must wait for one more timeslot because a sibling connict must be avoided and its ID is greater than 1. Therefore numwaitslot2] = 3. Finally, numwaitslot1] = 0.<lb/>

			<page>12<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			4. The source sends Collect message with the communication tree (containing times-lot assignments) down the tree. It will receive all Reply messages from leaves of the tree in 10 timeslots. Then it updates new topology by inserting new edges, i.e., (9,10) and (14,15). Also it updates current topology by deleting leaves and their incident edges rst. Since nodes 4, 5, and 6 have no neighbors of distance 3, they are deleted with their incident edges. The reduced network is shown in Figure 6. The second tree built by the source is the reduced network, except for edge (1,2). After the source collects responses from node 8 and 15 using the second tree, the protocol terminates because responses have been received from all 3-hop nodes (and, by assumption, K &lt; N).<lb/> 0<lb/> 1 2<lb/> 3 7<lb/> 8 15<lb/> Figure 6: The Reduced Network<lb/> 5.2 Correctness of the Deterministic Protocol<lb/> We now outline a proof that the deterministic protocol is correct.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>13<lb/></page>

			Lemma 1. For each phase l, the communication trees built in each round have at least<lb/> one leaf at level l. Furthermore, no communication trees in diierent rounds have any<lb/> leaves in common. This implies phase l terminates in at most jlevel(l)j rounds.<lb/> Proof: Before the source starts to collect responses from l-hop nodes, there is at least<lb/> one node at hop l in current topology. Otherwise the source would not start phase l. At the beginning of each round, every node in the current topology has at least one descendant at level l (otherwise, it would have been deleted by the recursive pruning procedure). Since the rst node considered at each level is always included in the com-munication tree, the tree has at least one node from each level through l, and hence has a leaf at level l. At the end of each round, all leaves of the current communication tree are deleted from the current topology, and so cannot occur in subsequent communica-tion trees of the phase. This implies that communication trees in the same phase do not have any leaves at level l in common. Since there are only level(l) nodes at level l, this implies that there are at most level(l) rounds in phase l.<lb/> Lemma 2. No messages sent in any round of the protocol collide at their intended<lb/> recipients. In particular, no parent's transmission of Collect message will collide in its child(ren) and no child's transmission of Reply message will collide in the child's parent.<lb/> Proof: During the execution of the protocol, a non-source node can transmit a message<lb/> only after the node receives the Collect message initiated by the source that shows that<lb/> the node is a part of the current communication tree. Assume that node i of level h &#x6EF59; 1<lb/> has received a Collect message. If node i is an internal node of the tree, it forwards the message in the following timeslot. The forwarded message will not collide at any child of node i because the nodes in ConnictNodes&#x6EF59;i] are not included in the tree. Thus the Collect message is forwarded to all nodes on the tree without collisions.<lb/> Consider the Reply message sent by node i of level h &#x6EF59; 1. Let node k be a parent<lb/> of node i. If node i is a leaf, its Reply message will not collide at node k because only<lb/> one child of node k sends a Reply message in any timeslot and any node of level h &#x6EF59; 1<lb/> adjacent to node k, if any, delays sending Reply message until node k nishes collecting all its Reply messages. If node i is an internal node, it sends an (aggregate) Reply message only after it receives all Reply messages from its children. The transmission of its Reply message could collide at node k only with the Reply messages from its siblings<lb/> or any node of level h &#x6EF59; 1 adjacent to node k. However, only one child of node k sends a Reply message in a timeslot, and a node of level h &#x6EF59; 1 adjacent to node k will not<lb/> send a Reply message simultaneously if its transmission interferes with that of node i. Therefore no collision occurs at node k.<lb/> Theorem 1. The deterministic collection protocol is correct. That is, the source col-<lb/>lects at least K responses in a nite time using the protocol.<lb/>

			<page>14<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			Proof: Since the protocol only terminates early if at least K responses are collected, we can assume K = N &#x6EF59;1 without loss of generality. We show by induction on phases that<lb/> if phase l begins with new topology = l-hop topology, then at the end of the phase the source has collected responses from all l-hop nodes and ends the phase with new topology = (l + 1)-hop topology. This implies the claim of the theorem. For the base case, l = 1, the new topology is initialized to the 1-hop topology. The source builds a communication tree of height 1 that includes all its neighbors. The nodes are ordered in the ascending order of their ID's and are assigned timeslots 0; 1; 2; . . . to send their Reply messages in that order. The messages are received without collisions by Lemma 2. Thus, the source correctly receives responses from all 1-hop nodes. Also, the information from the source's neighbors is incorporated into new topology, which is then equal to the 2-hop topology, as required. Now, consider phase l &gt; 1. By the inductive assumption, the phase begins with new topology = l-hop topology. The source builds a communication tree of height l level by level. All leaves of the communication tree are nodes of distance l, and the tree has at least one node of distance l by Lemma 1. By Lemma 2, the source receives Reply messages from all leaves in the tree without collisions. Thus the source collects responses from all nodes of distance l. Since the ID's of the leaves' neighbors are carried along with the responses and incorporated into new topology, the phase ends with new topology = (l + 1)-hop topology, as required. We will discuss the performance of the deterministic protocol in Section 7, but rst we will describe the randomized protocol.<lb/> 6 The Randomized Collection Protocol<lb/> Bar-Yehuda et al. developed a randomized collection protocol as a subprotocol of multiple broadcasts BII89]. The protocol sends the broadcast messages from multiple sources to the root of a breadth &#x6EF59;rst search (BFS) tree that is constructed before any broadcasts are performed. Unlike this protocol, our randomized protocol does not construct a BFS tree, which is relatively costly. Thus the deterministic active acknowledgement protocol in BII89] cannot be used. Instead, we use passive (or echo) acknowledgements. In addition to assumptions in Section 2, we assume each node knows &#x6EF59;, the maximum degree over all nodes in the network (actually, knowledge of a reasonable upper bound on &#x6EF59; is suucient). We also make use of collision detection (CD) in the initial phase of the protocol. Finally, we assume that each node is initially quiet. Two kinds of messages are used: A Collect message is sent by the source, and Reply messages (containing at least one response) are sent by each node. Unlike the deterministic protocol, topology information is not collected, and ID's are used only to distinguish diierent Reply messages. As in the deterministic protocol, Reply messages are aggregated together at intermediate nodes.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>15<lb/></page>

			6.1 Informal Description<lb/> The rst idea of the protocol is to divide all nodes into three groups in such a way that nodes in diierent groups do not interfere with each other. (See Figure 7.) For i = 0; 1; 2, group i is deened to be the set of nodes at all distances d such that d = i mod 3 from the source. Every timeslot is allocated to exactly one of the groups (each group gets one-third of the timeslots). Nodes may send messages only in allocated timeslots. On three succeeding timeslots, &#x6EF59;rst nodes in group 0 may send, then those in group 1, and then those in group 2. Since simultaneously sending nodes (at diierent levels) are distance two (or more) apart, collisions can only occur if two nodes from the same level send to a common destination. All the nodes in a group know which timeslots are allocated for their use.<lb/> Group 1 Group 0 Group 2 Group 1 Group 0<lb/> 1<lb/> 17<lb/> 16<lb/> 8<lb/> 6<lb/> 14<lb/> 2<lb/> 15<lb/> 9<lb/> 18<lb/> 3<lb/> 10<lb/> 7<lb/> 5<lb/> 12<lb/> 0<lb/> 1<lb/> 17<lb/> 16<lb/> 8<lb/> 6<lb/> 14<lb/> 2<lb/> 15<lb/> 9<lb/> 18<lb/> 3<lb/> 10<lb/> 7<lb/> 5<lb/> 12<lb/> 0<lb/> Figure 7: Example of Groups in the Randomized Protocol<lb/> Group identity is established in the &#x6EF59;rst phase of the protocol. The source sends a Collect message to its neighbors, and all other nodes forward this message to their neighbors. Since we make use of CD, collisions can be treated identically to Collect messages in this rst phase. This guarantees that<lb/>

			<page>16<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			1. All nodes begin the protocol within D timeslots from the time the source sends its Collect message.<lb/> 2. For any integer d, all nodes at distance d from the source begin their protocols at the same time, and thus are synchronized.<lb/> 3. All nodes in group i, for i = 0; 1; 2, are allocated to send in the same timeslots and no nodes in distinct groups are allocated to send at the same time.<lb/> The second idea of the protocol is to pass response messages closer to the source in \bucket brigade" fashion. From the point of view of a non-source node, three successive rounds can be considered as: (possibly) send known information, receive messages from nodes further from the source, and receive messages from nodes closer to the source. If new information is received from further away, this is added to the information to be moved closer to the source. Messages from closer to the source are treated as acknowledgements: information that has successfully been received at a node closer to the source need not be sent again. Note that collision detection is not used in this part of the protocol. The &#x6EF59;nal idea of the protocol is to use a random backoo procedure to avoid (with non-zero probability) collisions and move information closer to the source and send<lb/> acknowledgements away from the source. For each node, a succession of dlog e +<lb/> 1 allocated timeslots constitutes a response cycle. (Recall that all nodes at a given distance from the source agree on when response cycles begin and end and that allocated timeslots occur every third timeslot.) An active node is a node with at least one unacknowledged response to send. An active node may send its information at most twice in a response cycle. All active nodes send in the &#x6EF59;rst timeslot of the cycle. In succeeding timeslots, each active node ips an unbiased random binary coin. The rst time (if it occurs) in a response cycle that an active node ips a 1 (\heads"), it sends its information and becomes inactive. Thus, all nodes in a group send in the rst allocated timeslot of a response cycle, about 1 2 in the second allocated timeslot, about 1 4 in the<lb/> third, etc. Since at most &#x6EF59; &#x6EF59; 2 nodes can connict at nodes that are outside of the<lb/> sending group, collision-free transmission occurs with non-zero probability, as will be shown. The randomized protocol for non-source nodes is described in Figure 8. To guarantee the termination of the protocol at non-source nodes, we limit the time that a non-source node runs its protocol to a threshold value. Due to the random nature of the protocol, only if the threshold value is innnite is the protocol guaranteed to collect the desired number of responses before termination. The source, knowing the threshold value, will need to rerun the protocol if it did not achieve its collection objective upon termination. We envision the use of a threshold value that will make the likelihood of not achieving a collection objective small. The protocol followed by the source is straightforward and is omitted.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>17<lb/></page>

			wait until a message is received or a collision is detected for the rst time Buuer := f(i; response i ; unmarked)g; Active := True; t := 0; ts := 0 send a Reply message containing all unmarked responses in Buuer repeat<lb/> At the next timeslot: (receiving from below)<lb/> if a Reply message is received then add any new responses in the message to Buuer else do nothing.<lb/> At the next timeslot: (receiving from above)<lb/> if a Reply message is received then mark any corresponding messages in Buuer else do nothing.<lb/> At the next timeslot: (allocated for sending)<lb/> if t dlog e then Active := False; t := 0 if there are any unmarked responses in Buuer, send a Reply message containing unmarked responses in Buuer; also, Active := True. else (so, t &lt; dlog e) if Active = True then ip a binary coin if coin = 1 then send a Reply message containing all unmarked responses in Buuer; also, Active := False.<lb/> t := t + 1; ts := ts + 1<lb/> until ts &gt; threshold<lb/> Figure 8: Sketch of the Randomized Protocol at Non-source Node i<lb/> 6.2 Correctness of the Randomized Protocol<lb/> We estimate how fast Reply messages move up one level towards the source (and ac-knowledgments move one level down). We begin with a lemma to compute the proba-bility for a related problem. The following lemma follows from an argument similar to the &#x6EF59;rst theorem of Bar-Yehuda, et al. BGI87] and using the observation that a response cycle has at least log timeslots in which x in the lemma may receive from its neighbors, while x has at most neighbors.<lb/> Lemma 3. Let x be a node in the network and n(x) be the neighbors of x at the level<lb/> one more (less) than x's level. In a given response cycle for the nodes in n(x), if there<lb/>

			<page>18<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			is at least one active node in n(x), then x receives a message (acknowledgement) from some node in n(x) during the response cycle with a positive probability. From the protocol, it is clear that any responses that have not been collected by the source are necessarily unmarked in some active node. The following theorem thus implies that the randomized protocol terminates because the distance of the furthest uncollected response decreases with positive probability in nite time. For any node x, at any point during the execution of the randomized protocol, let lev(x) be the minimal level such that x's response has been received by some node at that level. (When lev(x) = 0, x's response has been received by the source.) Also, let maxlev = maxflev(x)g over all (non-source) nodes.<lb/> Theorem 2. In every response cycle that begins with maxlev &gt; 0 there is a positive<lb/> probability that either maxlev decreases or the number of nodes x such that lev(x) = maxlev decreases by the end of the cycle.<lb/> Proof: At the beginning of some response cycle with maxlev &gt; 0, let x be a node such<lb/> that lev(x) = maxlev, y be a node at level lev(x) that holds x's response, and z be<lb/> a neighbor of y at level lev(x) &#x6EF59; 1. Since z has at most &#x6EF59; neighbors at level lev(x),<lb/> Lemma 3 implies that there is a positive probability, say &#x6EF59;, that some neighbor of z transmits to z in the cycle without collision. By symmetry, all neighbors of z that are active are equally likely to be successful. Since y is necessarily active (since x's response cannot have been acknowledged), the probability is at least = that lev(x) decreases in the cycle. This implies the theorem.<lb/> 7 Performance of the Protocols<lb/> Analysis of our protocols is very diicult for arbitrary graphs, so we rst consider some graphs with simple structure that lend themselves to analysis. We then consider more arbitrary graphs and resort to performance analysis by simulation. Two families of graphs are considered: complete binary trees whose diameter is O(log N) and geometric graphs (to be described below) whose diameter is O(<lb/> q<lb/> N<lb/> log N ):<lb/> 7.1 Complete Binary Trees<lb/> Complete binary tree networks are not very realistic for radio networks, but provide a simple structure that lends itself to analysis.<lb/> Theorem 3. Assume that the graph corresponding to a network is a complete binary tree with N nodes, where N = 2 j &#x6EF59;1 and j &gt; 1, and that the source wants to collect at<lb/> least K responses, where 0 &lt; K &lt; N. Then the time complexity of the deterministic protocol in the network is 1:5blog Kc(blog Kc + 1).<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>19<lb/></page>

			Proof: In order to collect at least K responses, the source needs to consider only nodes whose distance from the source is at most blog Kc. The number of timeslots needed to collect responses from all nodes of distance i, 1 &#x6EF59; i &#x6EF59; blog Kc, is calculated. Only<lb/> one tree of height i is constructed to collect responses from them. Forwarding a Collect message to all nodes on the tree takes i timeslots. Consider how many timeslots are needed for the source to receive Reply messages from leaves of the tree. It takes two timeslots to move Reply messages one level up the tree. Therefore the total number of timeslots for the source to receive Reply messages from all nodes of distance i is 2i since the height of the tree is i. Thus the total number of timeslots to collect responses from all nodes of distance i is i + 2i = 3i. Therefore the time complexity of collecting at least K responses is<lb/> blogKc X<lb/> i=1<lb/> 3i = 1:5blog Kc(blog Kc + 1):<lb/> Note that if the source knows that the network topology is a complete binary tree with N nodes, there is an optimal protocol that requires 3blog Kc timeslots to collect at least K responses. We now explore the performance of the randomized protocol for complete binary trees.<lb/> Theorem 4. Assume that the graph corresponding to a network is a complete binary tree with N nodes, where N = 2 j &#x6EF59; 1 and j &gt; 1, and the source wants to collect at<lb/> least K responses. Then the expected time complexity of the randomized protocol is bounded above by 18:6blog Nc.<lb/> Proof: Let us count the expected number of response cycles needed for nodes of equal<lb/> distance to send successfully their Reply messages. Consider two sibling nodes of equal distance whose response cycles start at the same timeslot. Let P 2;i , i = 0; 1; 2, be the probability that only i node(s) transmits its Reply message(s) successfully during its response cycle given that each node has at least one response at the beginning of the cycle. At the rst timeslot of the response cycle both nodes send their Reply messages that are collided at their common neighbor. Then P 2;2 is 2( 1 2 ) 2 ( 1 2 ) = 1 4 because one node should transmit at the fourth timeslot of the response cycle and the other transmit at the seventh timeslot of the response cycle. P 2;1 is 2( 1 2 ) 2 ( 1 2 ) + ( 1 2 ) 2 2( 1 2 ) 2 = 3 8 because only one node transmits either at the fourth timeslot or at the seventh timeslot. Thus<lb/> P 2;0 is 1 &#x6EF59; P 2;1 &#x6EF59; P 2;2 = 3<lb/> 8 . Note that the probability that if only one node has a Reply message at the beginning of the response cycle, the node sends the message successfully during the cycle is 1. The probability that two sibling nodes with Reply messages send their Reply mes-sages successfully by the rst response cycle is equal to P 2;2 = 1 4 . The probability that<lb/>

			<page>20<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			two sibling nodes send their Reply messages successfully by the kth response cycle, k &gt; 1, is (P 2;0 ) k&#x6EF59;2 (P 2;0 P 2;2 + P 2;1 ) = ( 3 8 ) k&#x6EF59;2 15 32 . Thus the expected number of response cycles is 1 4 +<lb/> 1<lb/> X<lb/> k=2<lb/> k( 15 32 )( 3 8 ) k&#x6EF59;2 = 2:2: The length of a response cycle is 3(dlog 3e + 1) = 9. However the response cycle of two sibling nodes is overlapped with that of their common neighbor. That is, by the eighth timeslot of the response cycle the neighbor receives Reply messages and starts its response cycle at the last timeslot of the cycle. Therefore only 8 timeslots are needed for<lb/> the neighbor to receive Reply messages. Since the height of the tree network is blog Nc, the expected number of timeslots is bounded above by (9 &#x6EF59; 1)2:2blog Nc + blog Nc =<lb/> 18:6blog Nc: The performance of both protocols is shown to be exponentially better than that of the simple DFS protocol in complete binary tree networks. The performance of the randomized protocol is asymptotically better than that of the deterministic protocol in complete binary tree networks. Because the time complexity of the randomized protocol is not a tight upper bound, both the deterministic and the randomized protocol have<lb/> been simulated on complete binary tree networks. A value of threshold = 1 is used<lb/> for the randomized protocol. For the case when all responses are desired, in complete binary tree networks with at most 1024 nodes the deterministic protocol performs as good as the randomized protocol as shown in Figure 9.<lb/> 7.2 Geometric Graphs<lb/> The class of geometric graphs was rst deened by Johnson, et al. JAMS89, Ram91].<lb/> These graphs are deened in terms of two parameters, N and d. To randomly generate a graph from the class, N points are chosen uniformly and independently from the unit square. A pair of points are connected in the graph if and only if they are within Euclidean distance d of each other. Geometric graphs are a good representation for radio networks in that they simulate a random dispersement of radios of equal power in open terrain (without shadowing objects such as mountains). We want to choose d so that graphs tend to be connected, but is not too dense (as d increases, we approach the complete graph case). By choosing d to be 1<lb/> N<lb/> +<lb/> q log N<lb/> 2N , the graph is empirically known to be connected with an expectation of about 1 2 . For these graphs, the expected diameter is approximately 2<lb/> q<lb/> N<lb/> log N and there are about N log N edges. For points not too close to the boundary, the expected degree is approximately log N. Both the deterministic and the randomized protocol have been simulated on geomet-ric graphs. If only 10% of responses are to be collected, the average time complexity of the deterministic protocol is better than that of the randomized protocol in geometric networks of up to 1024 nodes (See Figure 10). The performance of the deterministic<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>21<lb/></page>

			s t o l s e m i T<lb/> f o r e b m u N<lb/>

			Number of Nodes (X; Y : logarithmic scales) O<lb/> . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . : Deterministic<lb/> . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . : Randomized<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> : DFS<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2 4 6 8 10 12 14<lb/> 2<lb/> 4<lb/> 6<lb/> 8<lb/> 10<lb/> 12<lb/> 14<lb/> . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/>

			Figure 9: Number of Timeslots for Collecting N &#x6EF59; 1 Responses in Tree Networks<lb/> protocol outperforms that of the DFS protocol in geometric networks of at least 64 nodes. For the case when 50% responses are desired, in geometric networks of up to 128 nodes the average time complexity of the deterministic protocol is better than that of the randomized protocol as shown in Figure 11. However in geometric networks of 8192 nodes, a big gap exists in (average) time complexity between the randomized and the deterministic protocol. The performance of the deterministic protocol outperforms that of the DFS protocol in geometric networks of at least 16 nodes. We next consider cases where the number of responses is &#x6EF59;xed at 32 and 60 inde-pendent of network size. The performance of all three protocols is shown in Figure 12 and Figure 13. In both cases the deterministic protocol outperforms the other two for large networks. The results of comparing the time complexity of both the deterministic and the randomized protocol with that of the simple DFS protocol to collect all responses are<lb/>

			<page>22<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			s t o l s e m i T<lb/> f o r e b m u N<lb/> Number of Nodes (X; Y : logarithmic scales) O<lb/> . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . : Deterministic<lb/> . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . : Randomized<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> : DFS<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2 4 6 8 10 12 14<lb/> 2<lb/> 4<lb/> 6<lb/> 8<lb/> 10<lb/> 12<lb/> . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/>

			Figure 10: Number of Timeslots for Collecting 10 % Responses in Geometric Networks<lb/> summarized in Table 1. The results for geometric graph networks are upper bounds that are approximations obtained by simulation.<lb/> Topology DFS Protocl Deterministic Protocol Randomized Protocol<lb/> complete binary tree 2N &#x6EF59; 2 1:5blog Nc(blog Nc + 1)<lb/> &lt; 18:6blog Nc geometric graph<lb/> 2N &#x6EF59; 2 &#x6EF59; 1:7N &#x6EF59; 2:7 p N log N Table 1: Time Complexity of Protocols to Collect N &#x6EF59; 1 Responses<lb/> 8 Conclusion<lb/> In this paper we have developed a deterministic and a randomized protocol for collect-ing responses in multi-hop packet radio networks and compared them with the simple depth rst search protocol in various network environments. Simulation shows that, in the interesting geometric graph case, the time complexity of the randomized protocol is asymptotically much better than that of the deterministic protocol. However the deterministic protocol seems to be a reasonably good choice in any of the following cases.<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>23<lb/></page>

			s t o l s e m i T<lb/> f o r e b m u N<lb/> Number of Nodes (X; Y : logarithmic scales) O<lb/> . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . : Deterministic<lb/> . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . : Randomized<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> : DFS<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2 4 6 8 10 12 14<lb/> 2<lb/> 4<lb/> 6<lb/> 8<lb/> 10<lb/> 12<lb/> 14<lb/> . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> Figure 11: Number of Timeslots for Collecting 50 % Responses in Geometric Networks<lb/> &#x6EF59; The network has a small number of nodes (say, &lt; 100). &#x6EF59; The network has a hierarchical structure that is not necessarily a tree, and whose<lb/> diameter is O(log N).<lb/> &#x6EF59; K, the number of responses to be collected, is a small fraction of N, the total<lb/> number of nodes.<lb/> The deterministic protocol incorporates a broadcast (with the Collect message), and so it could serve this function also, while the randomized protocol does not have this feature. Two drawbacks of the deterministic protocol are that it uses large messages and the computation costs at the source are high. Although the randomized protocol could use large message (O(N) responses aggregated into one message), this happens only with low probability. In these rare cases, the number of responses put into a message could be limited without any major impediment to the protocol.<lb/>

			<page>24<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note>
			
			s t o l s e m i T<lb/> f o r e b m u N<lb/> Number of Nodes (X; Y : logarithmic scales) O<lb/> . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . : Deterministic<lb/> . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . : Randomized<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> : DFS<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2 4 6 8 10 12 14<lb/> 2<lb/> 4<lb/> 6<lb/> 8<lb/> 10<lb/> . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> Figure 12: Number of Timeslots for Collecting 32 Responses in Geometric Networks<lb/> s t o l s e m i T<lb/> f o r e b m u N<lb/> Number of Nodes (X; Y : logarithmic scales) O<lb/> . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . : Deterministic<lb/> . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . : Randomized<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> : DFS<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2 4 6 8 10 12 14<lb/> 2<lb/> 4<lb/> 6<lb/> 8<lb/> 10<lb/> . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> Figure 13: Number of Timeslots for Collecting 60 Responses in Geometric Networks<lb/> While the randomized protocol is attractive, it has several limitations. One is that it uses collision detection in the initial phase of the protocol for synchronization. However,<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>25<lb/></page>

			the only critical use of this information by the protocol is to determine the direction of information ow (the time of arrival indicates whether messages are coming from above or below). This problem can be remedied by ignoring acknowledgements and always sending all responses that have been gathered so far. This increases the message size to O(N) responses, but does provide for all responses to reach the source (and every other node) with probability one.<lb/>
			</body>
		<back>
			<listBibl>References<lb/> &#x6EF59;AS87] Afek, Y., and Saks, M., \Detecting global termination conditions in the face of uncertainty," In Proc. 6th ACM Symp. on Principles of Distributed Com-puting, August 1987, pp. 109-124. &#x6EF59;AR90] Ammar, M.H., and Rouskas, G., \On the performance of protocols for col-lecting responses over a multiple-access channel," Tech. Rep. GIT-ICS-90/34, August 1990, Georgia Institute of Technology, Atlanta, GA 30332. &#x6EF59;BGI87] Bar-Yehuda, R., Goldreich, O., and Itai, A., \On the time-complexity of broadcast in radio networks: an exponential gap between determinism and randomization," In Proc. 6th ACM Symp. on Principles of Distributed Com-puting, August 1987, pp. 98-108. BII89] Bar-Yehuda, R., Israeli, A., and Itai, A., \Multiple communication in multi-hop radio networks," In Proc. 8th ACM Symp. on Principles of Distributed Computing, August 1989, pp. 329-338. &#x6EF59;HS88] Humblet, P.A., and Soloway, S.R., \Topology broadcast algorithms," Com-puter Networks and ISDN Systems 16 (1988/89), pp. 179-186. &#x6EF59;JAMS89] Johnson, D.S., Aragon, C.R., McGeoch, L.A., and Schevon, C., \Optimiza-tion by simulated annealing: an experimental evaluation; part I, graph parti-tioning," Operations Research 37 (1989), No.6, pp. 865-892. &#x6EF59;MV88] Mullender, S.J., and Vitanyi, P.M.B., \Distributed match-making," Algorith-mica 3 (1988), pp. 367-391. &#x6EF59;Nat85] Natarajan, K.S., \Query retrieval protocols in a broadcast environment," In Proc. GLOBECOM, November 1985, pp. 8.1.1-8.1.6. &#x6EF59;Ram91] Raman, R., \Generating random graphs eeciently," Tech. Rep. 369, January 1991, The University of Rochester, Rochester, New York 14627. &#x6EF59;WS89] Wang, J.L., and Silvester, J.A., \Optimizing responses to broadcast messages in radio networks," Algorithmica 4 (1989), pp. 395-416.<lb/></listBibl>
			
			<page>26<lb/></page>
			
			<note place="headnote">Lee, Burns, and Ammar<lb/></note>
			
			<div type="annex">Appendix<lb/> We present here a pseudo code of the deterministic collection protocol. Sets are widely<lb/> used for storage structures. We assume the existence of set operations &#x6EF59; (union), \ (intersection), &#x6EF59; (diierence), and 2 (membership). Two types of messages are used<lb/> by the protocol: Collect and Reply message. They are shown in the &#x6EF59;rst subsection. The protocol followed by the source (node 0) is in the second subsection. The protocol followed by non-source nodes is in the third subsection.<lb/> 8.1 The Messages<lb/> 1. Collect(sender; dests; Tree), where &#x6EF59; sender : sender of Collect message &#x6EF59; dests : intended receivers of Collect message &#x6EF59; Tree : a tree constructed at the source with timeslot assignments 2. Reply(sender; dest; numresponses; responses; neighbors), where &#x6EF59; sender : sender of Reply message &#x6EF59; dest : intended receiver of Reply message &#x6EF59; numresponses : the number of responses in Reply message &#x6EF59; responses : a list of responses from (diierent) nodes &#x6EF59; neighbors : a list of pairs of nodes and their neighbors<lb/> 8.2 The Protocol at the Source<lb/> Global Variables at the source &#x6EF59; N : the (known) number of nodes in the network &#x6EF59; K : the (known) number of responses to be collected &#x6EF59; source : the ID of the source in the network &#x6EF59; NewNodes : a set of nodes in the network topology known up to the beginning<lb/> of the current phase<lb/> &#x6EF59; neighbor(i) : a set of node i's neighbors in the network topology known up to<lb/> the beginning of the current phase. Initially, neighbor(source) is a set of source's<lb/> neighbors and neighbor(i) = ; for i 6 = source. &#x6EF59; distance(i) : the shortest distance of node i from the source. Initially, distance(i) = &#x6EF59;1 for i 6 = source.<lb/> 
			
			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note> 
			
			<page>27<lb/></page> 
			
			&#x6EF59; NoResponses : the number of responses collected up to now &#x6EF59; Responses : a list of responses collected up to now &#x6EF59; SetNodes : the set of nodes that will be given a chance to respond in the following<lb/> phase<lb/> (* Main Program *) ht := 0; NoResponses := 0;<lb/> call Initialize(); (* initialize global variables *) while NoResponses &lt; K do<lb/> ht := ht + 1;<lb/> call CollectResponses(ht); (* collect responses from all nodes of distance ht *) end<lb/> procedure Initialize()<lb/> (* initialize network topology consisting of source and its neighbors *) source := 0; (* node 0 is the source *) Responses := null; SetNodes := neighbor(source);<lb/> NewNodes := fsourceg;<lb/> distance(source) := 0;<lb/> for node x 2 SetNodes do<lb/> distance(x) := 1;<lb/> neighbor(x) := fsourceg; NewNodes := NewNodes fxg;<lb/> procedure CollectResponses(ht)<lb/> &gt;(* collect responses from all nodes of distance ht *) (* Description of Local Variables *) (* 1. ht : distance of nodes whose responses are collected *) (* 2. CurrentNodes : a set of nodes used in the current round of current phase *) (* 3. curneighbor(i) : a set of node i's neighbors used in the current round *) (* 4. Respondents : a set of all nodes of distance ht *) (* 5. V isitNodes : a set of replied nodes of distance ht *) (* 6. Tree : a tree built to collect responses from some nodes of distance ht *) (* 7. NodesTree(i) : a set of nodes of depth i in Tree *)<lb/> (* 8. dests : a set of destinations of a Collect message *)<lb/> CurrentNodes := NewNodes;<lb/> for node x 2 CurrentNodes do<lb/> curneighbor(x) := neighbor(x);<lb/>

			<page>28<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			Respondents := SetNodes;<lb/> SetNodes := ;; V isitNodes := ;; while V isitNodes 6 = Respondents do call BuildTree(ht;Tree;NodesTree;CurrentNodes;curneighbor); call FindReplySlot(ht;Tree; NodesTree;curneighbor);<lb/> dests := NodesTree(1);<lb/> send Collect(source; dests; Tree) to all neighbors; call CollectReplies(ht; Tree; NodesTree); (* collect replies from all leaves of Tree *) if NoResponses &#x6EF59; K then return; V isitNodes := V isitNodes &#x6EF59; NodesTree(ht);<lb/> (* remove all leaves and internal nodes without ht-hop nodes as descendants *)<lb/> call RemoveNodes(ht;NodesTree;CurrentNodes;curneighbor); end<lb/> procedure BuildTree(ht;Tree;NodesTree;CurrentNodes;curneighbor)<lb/> (* build a tree of height ht, a subgraph of current topology *) (* Description of Local Variables *) (* 1. ht : the height of the built tree *) (* 2. Tree : a set of nodes in the built tree *)<lb/> (* 3. depth(x) : depth of node x 2 Tree *) (* 4. parent(x) : parent of node x 2 Tree *) (* 5. children(x) : a set of children of node x 2 Tree *) (* 6. sibling(x) : a set of siblings of node x 2 Tree *)<lb/> (* 7. NodesTree(i) : a set of nodes of depth i in Tree *) (* 8. CurrentNodes : a set of nodes used in the current round of current phase *) (* 9. curneighbor(i) : a set of node i's neighbors used in the current round *) (* 10. CNodes : possible internal nodes in the same depth *) (* 11. Rate(x) : rate of node x *) (* 12. ConnictNodes(x) : a set of nodes interfering with x *) (* initialize a tree, Tree *)<lb/> Tree := fsourceg; (* source is the root of Tree *) NodesTree(0) := fsourceg;<lb/> depth(source) := 0; children(source) := curneighbor(source); parent(source) := null;<lb/> if ht &#x6EF59; 1 then (* all current neighbors of source become a part of Tree *) NodesTree(1) := ;; for node x 2 curneighbor(source) do Tree := Tree fxg; NodesTree(1) := NodesTree(1) fxg;<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>29<lb/></page>

			depth(x) := 1; parent(x) := source;<lb/> children(x) := ;;<lb/> sibling(x) := curneighbor(source);<lb/> else (* choose internal nodes of Tree, using rates of nodes *) call ComputeRate(ht;CurrentNodes;curneighbor; ConnictNodes; children; Rate);<lb/> d := 1; CNodes := curneighbor(source); (* possible internal nodes of depth 1 *)<lb/> while d &lt; ht do (* include internal nodes depth by depth *) call SelectNodesTree(d; curneighbor; CNodes; NNodes; ConnictNodes,<lb/> children; Rate; Tree; NodesTree); d := d + 1; (* increment depth *) CNodes := NNodes;<lb/> end (* include leaf nodes that are children of node x in NodesTree(ht &#x6EF59; 1) *) NodesTree(ht) := ;; for node x 2 NodesTree(ht &#x6EF59; 1) do for node y 2 children(x) do Tree := Tree &#x6EF59; fyg; NodesTree(ht) := NodesTree(ht) fyg;<lb/> parent(y) := x; sibling(y) := children(x); depth(y) := ht;<lb/> children(y) := ;;<lb/> procedure ComputeRate(ht;CurrentNodes;curneighbor;ConnictNodes; children; Rate) (* compute Rate(x); ConnictNodes(x); children(x) for x 2 CurrentNodes *)<lb/> (* Description of Local Variables *) (* 1. ht : the height of the tree *) (* 2. CurrentNodes : a set of nodes used in the current round of current phase *) (* 3. curneighbor(i) : a set of node i's neighbors used in the current round *) (* 4. ConnictNodes(x) : a set of nodes interfering with x *) (* 5. children(x) : a set of potential children of node x *) (* 6. Rate(x) : rate of node x *) (* 7. Resps(x) : the set of descendants of node x at distance ht *) (* 8. CNodes; CNodes2 : a subset of CurrentNodes *) d := ht;<lb/> CNodes := ;; for node x 2 CurrentNodes do if distance(x) &gt; 0 and distance(x) &lt; ht then CNodes := CNodes fxg;<lb/> CNodes2 := CNodes;<lb/>

			<page>30<lb/></page> 
			
			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			while d &gt; 1 do d := d &#x6EF59; 1; for node x 2 CNodes do if distance(x) = d then children(x) := ;; ConnictNodes(x) := ;; for node y 2 curneighbor(x) do if (distance(y) = distance(x) + 1) then (* y is a potential child of x *) children(x) := children(x) fyg; for node z 2 curneighbor(y) do if z 6 = x and distance(z) = d then (* z interferes with x *) ConnictNodes(x) := ConnictNodes(x) fzg;<lb/> (* compute rate of  x *)<lb/> Resps(x) := ;; if d &lt; ht &#x6EF59; 1 then for node y 2 children(x) do Resps(x) := Resps(x) &#x6EF59; Resps(y); else Resps(x) := Resps(x) &#x6EF59; children(x); Rate(x) := jResps(x)j; CNodes2 := CNodes2 fxg;<lb/> CNodes := CNodes2;<lb/> procedure SelectNodesTree(d; curneighbor;CNodes; NNodes; ConnictNodes; children; Rate,<lb/> Tree; NodesTree) (* select internal nodes of depth d with maximum rate *) (* Description of Variables *) (* 1. curneighbor(i) : a set of node i's neighbors used in the current round *) (* 2. CNodes : a set of potential nodes of depth d in Tree *) (* 3. NNodes : a set of potential nodes of depth d + 1 in Tree *) (* 4. ConnictNodes(x) : a set of nodes interfering with x *) (* 5. children(x) : a set of potential children of node x *) (* 6. Rate(x) : rate of node x *) (* 7. Tree : a set of nodes in the built tree *) (* 8. NodesTree : a set of nodes in the same depth in Tree *)<lb/> NNodes := ;; NodesTree(d) := ;; (* a set of nodes of depth d in Tree *) while CNodes 6 = ; do (* are nodes to choose left? *)<lb/> 
			
			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>31<lb/></page>

			<lb/><lb/><lb/><lb/>d); for node x 2 NodesTree(d &#x6EF59; 1) do (* update children(x) for node x of depth d &#x6EF59; 1 *) children(x) := children(x) \ NodesTree(d);<lb/> function FindMaxRate(Nodes;Rate)<lb/> (* nd a node with maximum rate *) (* Description of Local Variables *) (* 1. Nodes : a set of nodes *)<lb/> (* 2. Rate(x) : rate of node x 2 Nodes *)<lb/> (* 3. maxrate : current maximum rate *) (* 4. maxid : ID of node with maxrate *)<lb/> maxrate := &#x6EF59;1; maxid := 1; for node x 2 Nodes do if Rate(x) &gt; maxrate then<lb/> maxrate := Rate(x); maxid := x;<lb/> else if Rate(x) = maxrate then (* tie is broken in favor of smaller ID *) if maxid &gt; x then maxid := x; return maxid;<lb/>

			<page>32<lb/></page>

			<lb/>
			to node x 2 Tree *)<lb/> (* 6. newslotno(x) : nal slot number given to node x *) (* 7. numwaitslot(x) : number of timeslots for node x to wait before replying *) (* Leaf nodes send Reply in the ascending order of IDs of their siblings *)<lb/> for node x 2 NodesTree(ht) do<lb/> Let x be the j-th element in sibling(x); oldslotno(x) := 1;<lb/> numwaitslot(x) := j &#x6EF59; 1;<lb/> (* determine when internal nodes in Tree send Reply *)<lb/> for l := ht &#x6EF59; 1 downto 1 do for node x 2 NodesTree(l) do oldslotno(x) := max(oldslotno(y) + numwaitslot(y)) + 1, where y 2 children(x);<lb/> newslotno(x) := oldslotno(x);<lb/> for node x 2 NodesTree(l) do for node y 2 NodesTree(l) do if y 6 = x and y 2 curneighbor(x) then (* x may wait for y to nish collecting *) if oldslotno(x) &#x6EF59; oldslotno(y) -jchildren(y)j then<lb/> newslotno(x) := max (newslotno(x); oldslotno(y));<lb/> call AssignReplySlot(l; Tree; NodesTree); (* assign waiting timeslots *)<lb/> procedure AssignReplySlot(d; Tree; NodesTree)<lb/> (* assign number of timeslots to wait before sending Reply when ready *) (* Description of Local Variables *) (* 1. Tree : built tree *) (* 2. NodesTree(i) : a set of nodes of depth i in Tree *) (* 3. NT : a set of nodes of depth d in Tree *) (* 4. sibling(x) : a set of siblings of node x *) (* 5. index(i) : pointer to the node with the i-th newslotno *) (* 6. cno : current newslotno *) (* 7. wno : current number of waiting timeslots *) NT := NodesTree(d); (* consider siblings of a node and determine waiting timeslots *)<lb/> while NT 6 = ; do<lb/> 
			
			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note> 
			
			<page>33<lb/></page> 
			
			Let x be a node in NT;<lb/> NT := NT &#x6EF59; sibling(x); for node y 2 sibling(x) do<lb/> (* tie is broken in favor of smaller ID *)<lb/> Let newslotno(y) be the j-th element in fnewslotno(z) j z 2 sibling(x)g<lb/> index(j) := y; (* determine timeslots to wait before forwarding its Reply upwards,*) (* after it receives the last Reply from one of its children. *) cno := newslotno(index(1)); wno := 0;<lb/> numwaitslot(index(1)) := wno + (cno &#x6EF59; oldslotno(index(1))); for i := 2 to jsibling(x)j do if newslotno(index(i)) = cno then wno := wno + 1; else cno := newslotno(index(i)); numwaitslot(index(i)) := wno + (newslotno(index(i)) &#x6EF59; oldslotno(index(i)));<lb/> procedure CollectReplies(ht;Tree;NodesTree)<lb/> (* collect Reply messages from all leaves of Tree *) (* Description of Local Variables *) (* 1. Tree : tree of height ht *) (* 2. NodesTree(i) : a set of nodes of depth i in Tree *) (* 3. NoReplies : no of replies received from leaves of Tree *) (* 4. Resps : all leaves of Tree *)<lb/> (* 5. numresponses : the number of responses in Reply message *)<lb/> (* 6. responses : a list of responses sent by leaf nodes in Tree *)<lb/> (* 7. neighbors : a list of pairs of (i, neighbor i ) for leaf node i 2 Tree *)<lb/> NoReplies := 0; Resps := NodesTree(ht); (* all leaves of Tree *)<lb/> while NoReplies &lt; jRespsj do (* are some leaves left? *) receive a message; if it received Reply(sender; dest; numresponses; responses; neighbors) then<lb/> NoReplies := NoReplies + numresponses; NoResponses := NoResponses + numresponses;<lb/> Append responses to Responses; if NoResponses &#x6EF59; K then return;<lb/> (*<lb/><lb/>			

			<page>34<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			procedure UpdateTopology(ht;neighbors)<lb/> (* update network topology using a list of new neighbors, neighbors *) (* Description of Local Variables *)<lb/> (* 1. neighbors : a list of pairs of (i, neighbor i ) for leaf node i 2 Tree *)<lb/> (* 2. neighbor i : a set of i's neighbors sent by node i *) (* 3. tneighbor : a temporary set of new neighbors of some node *)<lb/> for (i; neighbor i ) 2 neighbors do<lb/> tneighbor := neighbor i -neighbor(i);<lb/> for node x 2 tneighbor do neighbor(i) := neighbor(i) &#x6EF59; fxg; if (i 6 2 neighbor(x)) then (* newly found edge *) neighbor(x) := neighbor(x) fig; if distance(x) = &#x6EF59;1 then (* newly found node *)<lb/> distance(x) := ht + 1;<lb/> NewNodes := NewNodes fxg; (* add new node *) SetNodes := SetNodes fxg; (* next respondent found *)<lb/> procedure RemoveNodes(ht;NodesTree; CurrentNodes; curneighbor)<lb/>  (* remove leaves and internal nodes without ht-hop descendants from current topology *) (* Description of Local Variables *) (* 1. Tree : tree of height ht *) (* 2. NodesTree(i) : a set of nodes of depth i in Tree *) (* 3. CurrentNodes : a set of nodes used in the current round of current phase *) (* 4. curneighbor(i) : a set of node i's neighbors used in the current round *) (* 5. SNodes : a set of remaining nodes *) (* 6. CNodes; CNodes2 : a subset of CurrentNodes *) (* remove leaves and their incident edges from current topology *)<lb/> for node x 2 NodesTree(ht) do CurrentNodes := CurrentNodes fxg; for node y 2 curneighbor(x) do curneighbor(y) := curneighbor(y) fxg; curneighbor(x) := ;;<lb/> (* remove (non-root) nodes all of whose children have been removed and *) (* their incident edges from current topology *)<lb/> CNodes := ;; for node x 2 CurrentNodes do if distance(x) &gt; 0 and distance(x) &lt; ht then CNodes := CNodes fxg;<lb/> CNodes2 := CNodes; d := ht;<lb/>

			<note place="headnote">Protocols for Collecting Responses in Multi-hop Radio Networks<lb/></note>

			<page>35<lb/></page>

			while CNodes 6 = ; do (* Is there a change in topology? *) d := d &#x6EF59; 1; for node x 2 CNodes do if distance(x) = d then<lb/> SNodes := curneighbor(x);<lb/> CNodes2 := CNodes2 fxg; if distance(y) &#x6EF59; distance(x) for all y 2 SNodes then (* all remaining neighbors have at most its distance *) CurrentNodes := CurrentNodes fxg; for node y 2 SNodes do curneighbor(y) := curneighbor(y) fxg; curneighbor(x) := ;;<lb/> CNodes := CNodes2;<lb/> 8.3 The Protocol at Non-source Node i<lb/> Variables at node i &#x6EF59; neighbor i : a set of i's neighbors. neighbor i is known initially. &#x6EF59; response i : i's response &#x6EF59; parent i : parent of node i in the tree &#x6EF59; children i : children of node i in the tree &#x6EF59; numwaitslot i : number of timeslots to wait before sending Reply when ready. &#x6EF59; Tree : a set of nodes in the tree. For node x 2 Tree, children(x) and numwaitslot(x)<lb/> are stored.<lb/> &#x6EF59; noresponses i : the number of responses received currently &#x6EF59; Responses i : a list of responses from diierent nodes &#x6EF59; Neighbors i : a list of neighbors of diierent nodes &#x6EF59; NoReply i : number of Reply messages expected<lb/> 1. On Receiving Collect(sender; dests; Tree) if i 2 dests then<lb/> children i := children(i);<lb/>

			<page>36<lb/></page>

			<note place="headnote">Lee, Burns, and Ammar<lb/></note> 
			
			numwaitslot i := numwaitslot(i);<lb/> if children i = ; then (* i is a leaf node *)<lb/> parent i := sender;<lb/> wait until the next numwaitslot i timeslots; send Reply(i; parent i ; 1; response i ; (i; neighbor i )); else (* i is an internal node *)<lb/> parent i := sender; Neighbors i := null; Responses i := null; noresponses i := 0; NoReply i := 0;<lb/> send Collect(i; children i ; Tree) in the following timeslot;<lb/> 2. On receiving Reply(sender; dest; numresponses; responses; neighbors) if i 2 dest then (* i must process Reply message and forward it *)<lb/> NoReply i := NoReply i + 1; noresponses i := noresponses i + numresponses;<lb/> Append responses to Responses i ; Append neighbors to Neighbors i ; if NoReply i = jchildren i j then (* received Reply from all children *) wait until the next numwaitslot i timeslots; send Reply(i; parent i ; noresponses i ; Responses i ; Neighbors i );</div>
		</back>
	</text>
</tei>
