%!PS-Adobe-3.0 Resource-ProcSet
%%BeginResource: procset WRI-Post-startup 1.0 0

% Post V1.7 initialisation file
% (C) Adrian Aylward 1989, 1991
%
% You may freely copy, use, and modify this file
%
% This file should be run before most programs

% Version string, real number for programs that check it

/version (48.0) def

% Ignore CTRL/D

<04> cvn {} def

% A dummy status dictionary

/statusdict 10 dict dup begin
/waittimeout 0 def
/checkpassword { 0 eq } bind def
/product (Post V1.7) def
end def

% A dummy server dictionary

/serverdict 5 dict dup begin
/exitserver { pop } bind def
end def

% A scratch string

/=string 256 string def

% ISO Latin 1 encoding vector

systemdict
/ISOLatin1Encoding [
StandardEncoding 0 144 getinterval aload pop
/dotlessi/grave/acute/circumflex/tilde/macron/breve/dotaccent
/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut/ogonek/caron
/space/exclamdown/cent/sterling
/currency/yen/brokenbar/section
/dieresis/copyright/ordfeminine/guillemotleft
/logicalnot/hyphen/registered/macron
/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered
/cedilla/onesuperior/ordmasculine/guillemotright
/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde
/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis
/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute
/Ocircumflex/Otilde/Odieresis/multiply
/Oslash/Ugrave/Uacute/Ucircumflex
/Udieresis/Yacute/Thorn/germandbls
/agrave/aacute/acircumflex/atilde
/adieresis/aring/ae/ccedilla
/egrave/eacute/ecircumflex/edieresis
/igrave/iacute/icircumflex/idieresis
/eth/ntilde/ograve/oacute
/ocircumflex/otilde/odieresis/divide
/oslash/ugrave/uacute/ucircumflex
/udieresis/yacute/thorn/ydieresis
] put

systemdict
/WindowsANSIEncoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quotesingle
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven
/eight/nine/colon/semicolon/less/equal/greater/question
/at/A/B/C/D/E/F/G
/H/I/J/K/L/M/N/O
/P/Q/R/S/T/U/V/W
/X/Y/Z/bracketleft/backslash/bracketright/asciicircum/underscore
/grave/a/b/c/d/e/f/g
/h/i/j/k/l/m/n/o
/p/q/r/s/t/u/v/w
/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
/.notdef/.notdef/quotesinglbase/florin/quotedblbase/ellipsis/dagger/daggerdbl
/circumflex/perthousand/Scaron/guilsinglleft/OE/.notdef/Zcaron/.notdef
/.notdef/quoteleft/quoteright/quotedblleft/quotedblright/bullet/endash/emdash
/tilde/trademark/scaron/guilsinglright/oe/.notdef/zcaron/Ydieresis
/.notdef/exclamdown/cent/sterling/currency/yen/brokenbar/section
/dieresis/copyright/ordfeminine/guillemotleft/logicalnot/hyphen/registered/macron
/degree/plusminus/twosuperior/threesuperior/acute/.notdef/paragraph/dotaccent
/ogonek/onesuperior/ring/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex/Idieresis
/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis/multiply
/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla
/egrave/eacute/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis
/eth/ntilde/ograve/oacute/ocircumflex/otilde/odieresis/divide
/oslash/ugrave/uacute/ucircumflex/udieresis/yacute/thorn/ydieresis
] bind put

systemdict
/MacintoshRomanEncoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quotesingle
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven
/eight/nine/colon/semicolon/less/equal/greater/question
/at/A/B/C/D/E/F/G
/H/I/J/K/L/M/N/O
/P/Q/R/S/T/U/V/W
/X/Y/Z/bracketleft/backslash/bracketright/asciicircum/underscore
/grave/a/b/c/d/e/f/g
/h/i/j/k/l/m/n/o
/p/q/r/s/t/u/v/w
/x/y/z/braceleft/bar/braceright/asciitilde/.notdef
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/.notdef/AE/Oslash
/.notdef/plusminus/.notdef/.notdef/yen/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/ordfeminine/ring/.notdef/ae/oslash
/questiondown/exclamdown/logicalnot/.notdef/florin/.notdef/.notdef/guillemotleft
/guillemotright/ellipsis/.notdef/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/.notdef
/ydieresis/Ydieresis/.notdef/currency/guilsinglleft/guilsinglright/.notdef/.notdef
/daggerdbl/dotaccent/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute
/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex
/.notdef/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/.notdef/.notdef/.notdef/ogonek/.notdef/.notdef/.notdef
] bind put

% EPS File input -- from Red & White book p. 726

/BeginEPSF {
    /b4_Inc_state save def
    /dict_count countdictstack def
    /op_count count 1 sub def
    userdict begin
    /showpage {} def
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [] 0 setdash newpath
    % /languagelevel stuff omitted
} bind def

/EndEPSF {
    count op_count sub { pop } repeat
    countdictstack dict_count sub { end } repeat
    b4_Inc_state restore
} bind def

% New cache parameters ops

systemdict
/setcacheparams
{ counttomark 1 ge { dup setcachelimit } if
  cleartomark
} bind put

systemdict
/currentcacheparams
{ mark cachestatus 6 { exch pop} repeat dup
} bind put

% setglobal, globaldict implementation

/setglobal where
{ pop }
{ /setshared where
  { /setglobal /setshared get def }
  { /setglobal { pop } bind def }
  ifelse
}
ifelse

/globaldict where
{ pop }
{ /shareddict where
  { /globaldict shareddict def }
  { /globaldict userdict def }
  ifelse
}
ifelse

systemdict begin	% define Level 2 ops in systemdict

% Resource implementation

true setglobal

/.resources 20 dict def

.resources begin
  /Category 20 dict def
  Category begin
    /Generic 7 dict def
    Generic begin

      /Category /Generic def

      % category is known to be valid in these procedures
      % resource implementation dictionary is on top of the dict stack

      /DefineResource % <key> <instance> <category> | instance
      { % do the typecheck
	currentdict /InstanceType known
	{ currentdict /InstanceType get
	  2 index type
	  eq not { typecheck } if
	} if
        .resources exch get
	begin
	  2 copy	% leave instance on stack
	  def
	  exch pop
        end
      } bind def

      /UndefineResource % <key> <category> | -
      { pop pop
      } bind def

      /FindResource % <instance> <category> | instance
      {
	dup .resources exch get
	2 index known
	{ .resources exch get exch get } % get dict then resource
	{ /ResourceFileName where
	  { pop
	    1 index =string /ResourceFileName load
	    { exec } stopped
	    { undefinedresource }
	    if
	    { fontfile } stopped
	    { undefinedresource }
	    if
	    cvx exec
	    dup .resources exch get	% look for it again
	    2 index known
	    { .resources exch get exch get } % get dict then resource
	    { undefinedresource }
	    ifelse
	  }
	  { undefinedresource }
	  ifelse
	} 
	ifelse
      } bind def

      /ResourceStatus % <key> <category> | [ status size true ] [ false ]
      { dup .resources exch get
  	2 index known
	{ pop pop 0 -1 true }
	{ /ResourceFileName where
	  { pop
	    1 index =string /ResourceFileName load
	    { exec } stopped
	    { pop pop false }
	    { pop pop pop 2 -1 true }
	    ifelse
	  }
	  { false }
	  ifelse
	}
	ifelse
      } bind def

      /ResourceForAll % <template> <proc> <scratch> <category> | -
      { pop pop pop pop
      } bind def

      /ResourceFileName % <key> <scratch> | filename
      { /Category load 3 1 roll 
        { .resourcefilename } stopped
	{ pop pop pop undefinedresource }
	{ not { undefinedresource } if }
	ifelse
      } bind def

    end % Generic
  end % Category
end % .resources

% Resource operators

/.resourceexec
{ 1 index .resources /Category get exch get
  begin
    load exec
  end
} bind def

/defineresource % <key> <instance> <category>
{ /DefineResource .resourceexec
} bind def

/undefineresource % <key> <category> | -
{ /UndefineResource .resourceexec
} bind def

/findresource % <instance> <category>
{ /FindResource .resourceexec
} bind def

/resourcestatus % <key> <category> | [ status size true ] [ false ]
{ dup .resources /Category get exch known {
    /ResourceStatus .resourceexec
  } { pop pop false }
  ifelse
} bind def

/resourceforall % <template> <proc> <scratch> <category> | -
{ /ResourceForAll .resourceexec
} bind def

% Category implementation

.resources /Category get /Generic get
dup length 1 add dict copy
dup /InstanceType /dicttype put
/Category exch /Category	% set up stack for defineresource
.resources /Category get /Generic get /DefineResource get exec pop

/Category /Category findresource
begin

  /DefineResource % <key> <instance> <category> | instance
  { 3 copy
    /Generic /Category findresource /DefineResource get exec
    dup /Category 5 index put		% set Category entry
    .resources 4 index 40 dict put	% add .resource dict
    4 1 roll pop pop pop
  } def

end

% ProcSet implementation

/Generic /Category findresource
dup length 1 add dict copy
dup /InstanceType /dicttype put
/ProcSet exch /Category defineresource pop

% Font implementation

/Generic /Category findresource
dup length 1 add dict copy
dup /InstanceType /dicttype put
/Font exch /Category defineresource pop

systemdict /.findfont systemdict /findfont get put
systemdict /.definefont systemdict /definefont get put

/Font /Category findresource
begin

  /DefineResource % <key> <instance> <category> | instance
  { 3 copy
    2 index 2 index .definefont pop
    /Generic /Category findresource /DefineResource get exec
    4 1 roll pop pop pop
  } def

  % KLUDGE Need to do dictstack stuff here to support type 3 fonts
  /FindResource % <instance> <category> | instance
  { 2 copy
    /Generic /Category findresource /FindResource get
    { exec } stopped
    { 1 index
      userdict /DefaultFontName get eq         % DefaultFont?
      { 1 index /DummyFont eq
	{ undefinedresource }
	{ pop pop /DummyFont /Font findresource }
	ifelse
      }
      { .FontMap 2 index known
	{ pop .FontMap exch get }
        { pop pop
	  userdict /DefaultFontName get          % Substitute DefaultFont
	} ifelse
	.FontMapped 3 index known not
	{ .FontMapped 3 index true put
	  (%stderr) (w) file
	  dup (Warning: substituting font ) writestring
	  dup 2 index =string cvs writestring
	  dup ( for ) writestring
	  dup 4 index =string cvs writestring
	  (\n) writestring
	} if
        /Font findresource                     % Recurse so it gets loaded
	% Substitute the requested font name for the real one if indicated
	.FontNameSub {
	  dup length dict begin
	  { 1 index dup
	    /FID eq exch /UniqueID eq or
	    { pop pop } { def } ifelse
	  } forall
	  /FontName 2 index def
	  currentdict
	  end
	  2 index exch definefont
	} if
      }
      ifelse
    }
    if
    3 1 roll pop pop
  } bind def

  /ResourceFileName % <key> <scratch> | filename
  { /FontOutline 3 1 roll 
    { .resourcefilename } stopped
    { undefinedresource }
    { pop }
    ifelse
  } bind def

end

% end resource implementation

% Reimplement font operators

/findfont {
  /Font findresource
} bind def

/definefont {
  /Font defineresource
} bind def

/selectfont				% No bind so psconv.ps works.
{ exch findfont exch
  dup type /arraytype eq
  { makefont }
  { scalefont }
  ifelse
  setfont
} def

% Font replacement mapping

/.FontMap <<
  /Helvetica /Swiss721BT-Roman
  /Helvetica-Bold /Swiss721BT-Bold
  /Helvetica-BoldOblique /Swiss721BT-BoldItalic
  /Helvetica-Oblique /Swiss721BT-Italic
  /Times-Roman /Utopia-Regular
  /Times-Bold /Utopia-Bold
  /Times-BoldItalic /Utopia-BoldItalic
  /Times-Italic /Utopia-Italic
  /Symbol /Math1
>> def

/.FontMapped 100 dict def
/.FontNameSub false def

false setglobal
end	% systemdict


% Define a dummy font - prints out big dots ...

/DummyFont 10 dict dup begin
/FontName /DummyFont def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontType 3 def
/FontBBox [0 -300 500 700] def
/Encoding StandardEncoding def
/BuildChar
{ pop pop
  500 0 50 0 450 400 setcachedevice
  250 200 200 0 360 arc fill
} bind def
/Painttype 0 def
end definefont pop

/DefaultFontName /Courier def

% Error handler

serverdict begin statusdict begin
/$brkpage 64 dict def

$brkpage begin

/$errfp (%stderr) (w) file def
/prnt {
  dup type /stringtype ne { =string cvs} if
  $errfp exch writestring
} bind def
/nl { (\n) prnt } bind def
/typeprint { dup type exec } readonly def
/== /typeprint load def
/cvsprint{ =string cvs prnt ( ) prnt } readonly def
/integertype /cvsprint load def
/realtype /cvsprint load def
/booleantype /cvsprint load def
/operatortype{ (--) prnt =string cvs prnt (-- ) prnt } readonly def
/marktype { pop (-mark- ) prnt } readonly def
/dicttype { pop (-dictionary- ) prnt } readonly def
/nulltype { pop (-null- ) prnt } readonly def
/filetype { pop (-filestream- ) prnt } readonly def
/savetype { pop (-savelevel- ) prnt } readonly def
/fonttype { pop (-fontid- ) prnt } readonly def
/nametype { dup xcheck not { (/) prnt } if cvsprint } readonly def
/stringtype {
  dup rcheck { (\() prnt prnt (\)) prnt } { pop (-string- ) prnt } ifelse
} readonly def
/arraytype {
  dup rcheck{
    dup xcheck
    { ({ ) prnt { typeprint } forall (}) prnt }
    { ([ ) prnt { typeprint } forall (]) prnt }
    ifelse
  } {
    pop (-array- ) prnt
  } ifelse
} readonly def
/packedarraytype {
  dup rcheck { arraytype } { pop (-packedarray- ) prnt } ifelse
} readonly def
end %$brkpage

errordict
/handleerror {
  systemdict begin $error begin $brkpage begin
  newerror {
    /newerror false store 
    (PostScript Error: ) prnt errorname prnt nl
    (Offending Command: ) prnt /command load prnt nl
    $error /errorline known {
      (\(Line ) prnt $error /errorline get prnt ( of input file\)) prnt
    } if
    $error /ostack known {
      nl (Stack:) prnt nl
      $error /ostack get length 1 sub
      dup 8 sub dup 2 lt { pop 0 } if
      -1 exch {
        $error /ostack get exch get
        (  ) prnt typeprint nl
      } for
      $error /ostack get length dup 10 gt {
        9 sub
        (  << ) prnt cvsprint (stack elements omitted >>) prnt nl
      } if
      pop
    } if
    (%%[ Error: ) prnt errorname prnt
    (; OffendingCommand: ) prnt /command load prnt ( ]%%) prnt flush
  } if
  end end end
}
dup 0 systemdict put dup 4 $brkpage put bind readonly put
end end

% Some horrible Mathematica stuff

/MathPictureStart
{ /WRI-Mathematica-prolog /ProcSet findresource
  /MathPictureStart get exec
} bind def

/sampledsound where
{ pop }
{ /sampledsound {
    0 7 1 roll		% add return thing
    6 0 .callextfunc
    pop			% lose return thing
  } bind def
}
ifelse
