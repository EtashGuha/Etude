(* ::Package:: *)

General::settf = "Cannot set `1` to `2`; value must be True or False."
$BatchInput::bitf = "Cannot set `1` to `2`; value must be True or False."
$BoxForms::formset = "Cannot set `1` to `2`; value must be a list that includes TraditionalForm and StandardForm."
$CharacterEncoding::charcode = "`1` is not a valid character encoding. Possible settings are the names given by $CharacterEncodings or None."
$CharacterEncoding::charfile = "The file `1` contains an invalid character encoding. A valid encoding is {\"type\", {{n1, \"c1\"}, ...}}."
$CharacterEncoding::sjis = "The byte sequence `1` could not be interpreted as a character in the `2` character encoding."
$CharacterEncoding::utf8 = "The byte sequence `1` could not be interpreted as a character in the UTF-8 character encoding."
$ContextPath::cxlist = $Packages::cxlist = "Cannot set `1` to `2`; value must be a list of strings ending in `3`."
$DateStringFormat::fmt = "`1` is not a valid date format."
$HistoryLength::limset = "Cannot set $HistoryLength to `1`; value must be Infinity or a non-negative machine-sized integer."
Internal`$FactorStandardComponent::scset = "Cannot set `1` to `2`; value must be True or False."
Internal`$FactoredNumberSieveMax::smset = "Cannot set `1` to `2`; value must be a positive machine-sized integer between `3` and `4`."
$IterationLimit::itlim = "Iteration limit of `1` exceeded."
$IterationLimit::aitlim = "Iteration limit of `1` exceeded during evaluation with assumptions."
$IterationLimit::limset = $RecursionLimit::limset = "Cannot set `1` to `2`; value must be Infinity or an integer at least `3`."
$Language::noset = "The license configuration for the kernel does not allow $Language to be changed to `1`. All messages will be displayed in English."
$Language::notstr = "`1` is not a string. Only strings can be set as the value of $Language."
Internal`$MinExponent::minexp = "Cannot set `1` to `2`; value must be a negative number or -Infinity."
Internal`$MaxExponent::maxexp = "Cannot set `1` to `2`; value must be a positive number or Infinity."
$MaxPrecision::prec = "In increasing internal precision while attempting to evaluate `1`, the limit $MaxPrecision = `2` was reached. Increasing the value of $MaxPrecision may help resolve the uncertainty."
$MaxPrecision::precset = "Cannot set `1` to `2`; value must be a positive number or Infinity."
$MaxExtraPrecision::precset = $MinPrecision::precset = "Cannot set `1` to `2`; value must be a non-negative number or Infinity."
$MaxPiecewiseCases::npi = "The new value `1` of $MaxPiecewiseCases is not a positive integer or Infinity."
$MaxRootDegree::npi = "The new value `1` of $MaxRootDegree is not a positive machine-sized integer."
$MinPrecision::preccon = $MaxPrecision::preccon = "Cannot set `1` such that $MaxPrecision < $MinPrecision."
$MinPrecision::preclck = $MaxPrecision::preclck = "`1` is currently under the control of internal routines. You cannot change it at this time."
$ModuleNumber::set = "Cannot set `1` to `2`; value must be a positive machine integer."
NumericalMath`$NumberBits::realx = "`1` is not an inexact real number."
$OutputSizeLimit::nosess = "This output can only be updated in the same kernel session that generated it."
$OutputSizeLimit::noout = "This output cannot be updated because Out[`1`] has no value."
$ParentLink::lnset = "Cannot set $ParentLink to `1`; value is not a LinkObject."
$ParentLink::notfe = "`1` has refused the responsibility of $ParentLink."
$PreRead::prstr = "$PreRead[\"`1`\"] results in `2`, which is not a string."
$RandomState::rndst = "`1` is not a valid random state."
$RecursionLimit::areclim = "Recursion depth of `1` exceeded during evaluation with assumptions."
General::reclim2 = $RecursionLimit::reclim2 = "Recursion depth of `1` exceeded during evaluation of `2`."
$RecursionLimit::reclim = "Recursion depth of `1` exceeded."
$SyntaxHandler::sntxh = "$SyntaxHandler returned `1`, which is not a string or $Failed."
$SyntaxHandler::sntxnc = "$SyntaxHandler could not correct syntax error."
$SyntaxHandler::sntxrun = "Trying to correct syntax using the specified $SyntaxHandler."
AbsoluteTime::arg = "Argument `1` cannot be interpreted as a date or time input."
AbsoluteTime::str = "String `1` cannot be interpreted as a date in format `2`."
General::zone = "Time zone specification `1` should be a real number, integer, or time zone string."
General::tzpo = "Offset `2` for time zone `1` does not match actual offset of `3` for `4`.";
General::expint = "Result `1` obtained by applying the value of the ExponentFunction option to `2` should be an integer or Null."
General::iprf = "Formatting specification `1` should be a positive integer or a pair of positive integers."
Accumulate::bdmtd = "Value of option Method -> `1` is not Automatic or \"CompensatedSummation\"."
Accuracy::mnprec = Precision::mnprec = "Value `1` would be inconsistent with $MinPrecision; bounding by $MinPrecision instead."
Accuracy::mxprec = Precision::mxprec = "Value `1` would be inconsistent with $MaxPrecision; bounding by $MaxPrecision instead."
AlgebraicNumber::cfls = "`1` is not a list of rational numbers."
AlgebraicRules::algdat = "`1` is not a valid AlgebraicRules object obtained from AlgebraicRules."
AlgebraicRules::newv = "`1` involves variables not among `2`."
Animate::unknop = ListAnimate::unknop = "`1` is not a recognized option."
Animate::vsform = "Animate argument `1` does not have the correct form for a variable specification."
General::asyncinv = "Argument `1` is not a valid AsynchronousTask object."
General::asyncobj = "Asynchronous task object `1` has an invalid identification number. It may have been removed."
General::asyncsess = "Asynchronous task object `1` has an invalid session identifier. It may have been created in a different session."
StartAsynchronousTask::pre = StopAsynchronousTask::pre = StartAsynchronousTask::post = StopAsynchronousTask::post = RemoveAsynchronousTask::pre = RemoveAsynchronousTask::post = "The setting for the option `1` could not be run."
TriggerAsynchronousTask::notask = "Could not find asynchronous task object when doing `1`."
CreateAsynchronousTask::id = "Asynchronous task ID is not an integer."
CreateAsynchronousTask::noid = "Could not find asynchronous task object for identification number `1`."
CreateArchive::chtype = ExtractArchive::chtype = "Argument `1` at position `2` is not a valid file or directory specification."
General::filex = "`1` already exists."
General::filex2 = "`1` already exists. Use OverwriteTarget -> True to overwrite the existing file."
CreateArchive::infer = ExtractArchive::infer = "Cannot infer file format of `1`."
CreateArchive::nodir = "Directories cannot be compressed using the `1` format."
CreateArchive::nonewdir = AudioCapture::nonewdir = SpeechSynthesize::nonewdir = AudioRecord::nonewdir = AudioStream::nonewdir = "Cannot create directory `1`."
ExtractArchive::fmterr = "Invalid `1` file."
ArrayFlatten::depth = "The ArrayDepth of the expression at position 1 of `1` must be at least equal to the specified rank `2`. (The rank is given by the optional second argument, which defaults to 2.)"
ArrayFlatten::match = "`1` fails the matching condition for ArrayFlatten[a,n]: if b = a[[i_1,i_2,...,i_n]], c = a[[j_1,j_2,...,j_n]], Head[a] == Head[b] == Head[c], Length[Dimensions[b]] >= n, Length[Dimensions[c]] >= n, and i_k = j_k, then Dimensions[b][[k]] must equal Dimensions[c][[k]]. Here the condition fails for k = `2` and i_k = j_k = `3`."
MatrixPlot::mat0 = "Argument `1` at position `2` is not a matrix."
ArrayPlot::mat = "Argument `1` at position `2` is not a list of lists."
MatrixPlot::drev = ArrayPlot::drev = ReliefPlot::drev = "The value of DataReversed -> `1` must be True, False, or a length-two list of True or False."
MatrixPlot::maxpt = ArrayPlot::maxpt = "The value of MaxPlotPoints -> `1` must be a positive real number, Infinity, or a list containing positive real numbers or Infinity."
MatrixPlot::dr = ArrayPlot::dr = "The value of DataRange -> `1` must be of the form {xrange, yrange}, with xrange and yrange either All or of the form {xmin, xmax} with xmin <= xmax."
MatrixPlot::crule = ArrayPlot::crule = Colorize::crule = "Value of option ColorRules -> `1` is not a valid list of color rules."
MatrixPlot::mesh = ArrayPlot::mesh = "Value of option Mesh -> `1` is not All, None, n, or a valid list of mesh specifications; using All instead."
MatrixPlot::imgsz = ArrayPlot::imgsz = "Value of option ImageSize -> `1` is not Automatic or a valid image size specification."
MatrixPlot::pixv = ArrayPlot::pixv = "Value of option PixelConstrained -> `1` is not True, False, a positive integer, or a list of two positive integers."
ReliefImage::input = ReliefPlot::input = "Argument `1` at position 1 is not a 2 x 2 or larger numerical matrix of real values."
ReliefImage::langle = ReliefPlot::langle = "Value of option LightingAngle -> `1` is not Automatic, a real number, or a pair of real numbers."
ReliefImage::mtd = NDSolve`FEM`PDESolve::mtd = "Value of option Method -> `1` is invalid."
AspectRatio::aspr = "Value of option AspectRatio -> `1` is not a finite positive number or Automatic."
AsymptoticSolve::indv = "The independent variable list should be nonempty."
AsymptoticSolve::depv = "The dependent variable list should be nonempty."
AsymptoticSolve::dupv = "The variable list `1` contains duplicates."
AsymptoticSolve::cmvs = "The independent variable list `1` and the dependent variable list `2` contain common elements."
AsymptoticSolve::vcnt = "The center point specification `1` involves the variables `2`."
AsymptoticSolve::vlen = "The variable list `1` and the value list `2` have different lengths."
AsymptoticSolve::doms = "The domain specification `1` should be Reals or Complexes."
AsymptoticSolve::ordl = "The order specification `1` and the variable list `2` have different lengths."
AsymptoticSolve::ords = "The order specification `1` is not a positive integer."
AsymptoticSolve::dirl = "The direction specification `1` and the variable list `2` have different lengths."
AsymptoticSolve::eqns = "`1` is not a system of equations."
AsymptoticSolve::rltc = "Warning: AsymptoticSolve was unable to prove that the asymptotic solutions correspond to real-valued exact solutions in the allowed time of `1` seconds. The time constraint can be specified with SetSystemOptions[\"AsymptoticSolveOptions\" -> {\"VerifyRealTimeConstraint\" -> tsec}]."
AsymptoticSolve::real = "Warning: AsymptoticSolve was unable to prove that the asymptotic solutions correspond to real-valued exact solutions."
Attributes::attnf = "`1` is not a known attribute."
Attributes::attsl = "`1` is not a symbol, string, or list of symbols and strings."
Attributes::locked = ClearAll::locked = Protect::locked = SetOptions::locked = "Symbol `1` is locked."
Assert::asrte = "Assertion `1` had no test."
Assert::asrttf = "Assertion test `1` evaluated to `2` that is neither True nor False."
Assert::asrtf = "Assertion `1` failed."
Assert::asrtfl = "Assertion `1` at line `2` in `3` failed."
Assert::asrtfe = "Assertion `1` in `2` failed."
AuthenticationDialog::nauthd = "`1` is not a recognized AuthenticationDialog specification."
Axes::axes = "`1` is not a valid axis specification."
AxesEdge::axedg = "`1` is not a valid axis edge specification."
BellY::mat = "Argument `1` at position `2` is not a matrix."
BellY::mat1 = "Argument `1` at position `2` is neither a vector nor a matrix."
BaseForm::basf = IntegerString::basf = "Requested base `1` should be an integer between 2 and `2`."
FileHash::take = "Cannot take positions `1` through `2` in the file."
BinaryRead::format = BinaryReadList::format = BinaryWrite::format = "`1` is not a recognized binary format."
General::bfmt  = "The stream `1` has been opened with BinaryFormat -> False and cannot be used with binary data."
General::cfstr = "The stream `1` is closed and cannot be read."
BinaryRead::unicode = BinaryReadList::unicode = BinaryWrite::unicode = "The stream `1` is a 16-bit Unicode data stream and cannot be used with binary data."
BinaryWrite::nocoerce = "`1` cannot be coerced to the specified format."
BinaryWrite::memavail = "Could not allocate memory for BinaryWrite."
BinaryWrite::errfile = "Could not access file `1`."
Block::lockt = Dialog::lockt = "Cannot localize locked symbol `1` in assignment `3` from local variable specification `2`."
Block::lockv = Dialog::lockv = "Cannot localize locked symbol `1` in local variable specification `2`."
Block::lvlist = Dialog::lvlist = Module::lvlist = With::lvlist = "Local variable specification `1` is not a List."
Block::lvset = Dialog::lvset = With::lvset = Module::lvset = "Local variable specification `1` contains `2`, which is an assignment to `3`; only assignments to symbols are allowed."
Block::lvsym = Dialog::lvsym = Module::lvsym = DynamicModule::lvsym = Interpretation::lvsym = "Local variable specification `1` contains `2`, which is not a symbol or an assignment to a symbol."
$BlockchainBase::bbase = "Invalid BlockchainBase specification `1`.";
Break::nofunc = "Function `1` not found enclosing `2`."
Break::nofwd = "No enclosing For, While, or Do found for `1`."
Developer`CalendarData::cal = "`1` is not supported in the `2` calendar."
Developer`CalendarData::nohday = "`1` was not a recognized holiday in `2`."
Developer`CalendarData::ijtime = DatePlus::ijtime = DateDifference::ijtime = DateRange::ijtime = DayName::ijtime = LeapYearQ::ijtime = DayRange::ijtime = DayPlus::ijtime = DayCount::ijtime = DayMatchQ::ijtime = BusinessDayQ::ijtime = DayRound::ijtime = "`1` dates cannot have hours, minutes, seconds."
Developer`CalendarData::month = DatePlus::month = DateDifference::month = DateRange::month = DayName::month = LeapYearQ::month = DayRange::month = DayPlus::month = DayCount::month = DayMatchQ::month = BusinessDayQ::month = DayRound::month = "`1` is not a known month for the `2` calendar. Use CalendarData[\"`2`\", \"MonthList\"] for a list of months."
DateRange::gran = "`1` is not a recognized calendar granularity specification.";
DayPlus::nint = "Invalid day increment specification `1`; value must be an integer.";
DayPlus::dtype = DayRound::dtype = DayCount::dtype = DayRange::dtype = "Unrecognized day type specification `1`.";
DatePlus::nint = "Argument `1` should be an integer value for `2`.";
DayRound::badinc = "The rounding `1` does not apply to the selected day type; changed to `2`.";
DayRound::rnd = "Invalid rounding specification `1`; value should be \"Next\", \"Following\", \"ModifiedFollowing\", \"Preceding\", \"Previous\", or \"ModifiedPreceding\".";
CellularAutomaton::ospec = "The specified order `1` should be a positive machine integer."
CellularAutomaton::rspec = "The neighbor specification at position 3 of rule specification `1` should be a radius, a non-empty list of radii, or a non-empty list of offsets. A radius must be (d - 1)/2 for some positive machine integer d. The offsets are non-empty lists of machine integers."
CellularAutomaton::offfo = "Because rule specification `1` has no specified order, the offsets at position 3 must have the same length."
CellularAutomaton::offho = "Because rule specification `1` has the specified order `2`, the offsets at position 3 must have lengths differing by at most 1. Those of maximum length must have length at least 2; their first coordinate t (time) must satisfy -`2` < t <= 0. The shorter offsets are taken to have t = 0."
CellularAutomaton::offrep = "The offsets at position 3 in rule specification `1` (after adding any missing 0 time coordinates in the higher-order case) must be distinct."
CellularAutomaton::nhdm = "Each dimension of the smallest rectangle enclosing the cells in the neighborhood specified by rule `1` must be a machine integer."
CellularAutomaton::wtspec = "The weight specification at position {2, 2} of rule specification `1` should be 1 or an array of non-negative machine integers with dimensions `2`."
CellularAutomaton::nocol = "Since position 2 of rule specification `1` is not {}, position 1 must be an integer or a pure Boolean function."
CellularAutomaton::kspec = "Since position 1 of rule specification `1` is not a function or rule list, position 2 (if present) must be of the form k, {k, 1}, or {k, wts} where k is a machine integer > 1 and wts is a non-empty array of non-negative machine integers."
CellularAutomaton::rlist = "The neighborhood specification cannot be computed from the list of rules `1`."
CellularAutomaton::rsize = "The specified rule number `1` is greater than the largest possible rule number (`2`)."
CellularAutomaton::rneg = "The specified rule number `1` should be non-negative."
CellularAutomaton::nspec = "If rule specification `1` is a List that is not a list of rules, it must have between 2 and 4 elements."
CellularAutomaton::nspecnl = "Rule specification `1` should be an Integer, a List, a pure Boolean function, a String, or an Association.";
CellularAutomaton::wtlen = "The length of the weight list `1` does not match the number of cells in the neighborhood `2`."
CellularAutomaton::offg= "The offset specification `1` should be an integer or {offt, offx1, offx2, ... offxk}, where offt is present and k does not exceed `2`, the number of spatial dimensions."
CellularAutomaton::offg4= "Since four arguments are used, the third argument `1` must be a non-negative machine integer, and the fourth argument `2` must be an integer or {offt, offx1, offx2, ... offxk}, where offt is present and k does not exceed `3`, the number of spatial dimensions. Note that the four-argument form of CellularAutomaton is being discontinued."
CellularAutomaton::offtg = "Temporal offset specification `1` should be t, {t}, {{t}}, {t1, t2}, or {t1, t2, dt} where t, t1, t2, and dt are machine integers and dt is positive."
CellularAutomaton::offtm = "Temporal offset specification `1` requests step `2` but the lowest step is `3`."
CellularAutomaton::offts = "The number of steps `2` requested by temporal offset specification `1` must be a positive machine integer."
CellularAutomaton::offtg4 = "Temporal offset specification `2` should be All, Automatic, t, {t}, {{t}}, {t1, t2}, or {t1, t2, dt}. If t, t1, or t2 is negative, then the step size `1` plus 1 is added to it. The resulting t, t1, t2, and dt must be machine integers with dt > 0. Note that the four-argument form of CellularAutomaton is being discontinued."
CellularAutomaton::offtm4 = "Step size `1` and temporal offset specification `2` request step `3` but the lowest step is `4`. Note that the four-argument form of CellularAutomaton is being discontinued."
CellularAutomaton::offts4 = "The number of steps `3` requested by step size `1` and temporal offset specification `2` must be a positive machine integer. Note that the four-argument form of CellularAutomaton is being discontinued."
CellularAutomaton::offxg = "The spatial offset specification `1` for dimension `2` should be x, {x}, {{x}}, {x1, x2}, or {x1, x2, dx} where x, x1, x2, and dx are machine integers and dx is positive."
CellularAutomaton::offxs = "The number of cells `3` requested by the spatial offset specification `1` for dimension `2` must be a positive machine integer."
CellularAutomaton::initn = "The initial condition specification `1` should be of the form aspec, {aspec, bspec}, or {{{aspec1, off1}, {aspec2, off2},... {aspecn, offn}}, bspec} (n > 0). Each aspec must be a non-empty rank `2` array whose elements at level `2` are integers i in the range 0 <= i <= `3`."
CellularAutomaton::initno = "The initial condition specification `1` should be of the form aspec, {aspec, bspec}, or {{{aspec1, off1}, {aspec2, off2},... {aspecn, offn}}, bspec} (n > 0). Each aspec must be a non-empty rank `2` array whose first dimension (time) has length `3` and whose elements at level `2` are integers i in the range 0 <= i <= `4`."
CellularAutomaton::inite = "The initial condition specification `1` should be of the form aspec, {aspec, bspec}, or {{{aspec1, off1}, {aspec2, off2},... {aspecn, offn}}, bspec} (n > 0). Each aspec must be a non-empty rank `2` array whose elements at level `2` do not have head List."
CellularAutomaton::initeo = "The initial condition specification `1` should be of the form aspec, {aspec, bspec}, or {{{aspec1, off1}, {aspec2, off2},... {aspecn, offn}}, bspec} (n > 0). Each aspec must be a non-empty rank `2` array whose first dimension (time) has length `3` and whose elements at level `2` do not have head List."
CellularAutomaton::initm = "When the nonbackground parts `1` of the initial conditions are assembled into a contiguous block, each of the dimensions `2` of the resulting array must be a machine integer."
CellularAutomaton::bkgdn = "The background `1` should be an integer i, 0 <= i <= `3`, or a non-empty rank `2` array whose elements at level `2` are integers i in the range 0 <= i <= `3`."
CellularAutomaton::bkgdno = "The background `1` should be an integer i, 0 <= i <= `4`, or a non-empty rank `2` array whose first dimension (time) has length `3` and whose elements at level `2` are integers i in the range 0 <= i <= `4`."
CellularAutomaton::bkgde = "The background `1` should be an expression whose head is not List or a non-empty rank `2` array whose elements at level `2` do not have head List."
CellularAutomaton::bkgdeo = "The background `1` should be an expression whose head is not List or a non-empty rank `2` array whose first dimension (time) has length `3` and whose elements at level `2` do not have head List."
CellularAutomaton::stoff = "The offset `1` at position `2` in the initial condition specification should be a length `3` list of machine integers."
CellularAutomaton::rank = "The rule `1` has spatial rank `2`, which is greater than the maximum allowed spatial rank `3`."
CellularAutomaton::mes = "During the evaluation of step `2` of `1` one or more messages were issued. When this happens the original expression is returned unevaluated. One may avoid this behavior by using Quiet to suppress the messages."
CellularAutomaton::outdim = "The spatial dimensions `2` of the result of evaluating `1` must be a list of machine integers."
CellularAutomaton::rmem = "The algorithm for computing rule `1` requires at least `2` bytes of memory, which is more than is currently available."
CellularAutomaton::nhdsize = "The number of elements `2` in the neighborhood for rule `1` must be a machine integer."
CellularAutomaton::nbsize = "The number of elements `2` in the smallest box bounding the cells in the neighborhood for rule `1` must be a machine integer."
CellularAutomaton::tsize = "The number of elements `2` in the rule table used to compute rule `1` must be a machine integer."
CellularAutomaton::boolk = "Since position 2 of rule specification `1` is not 2, position 1 cannot be a pure Boolean function."
CellularAutomaton::boolr = "In rule specification `1` there are `2` cells in the neighborhood, which is fewer than the number of cells `3` required by the Boolean function rule."
CellularAutomaton::znhd = "In rule specification `1` the neighborhood contains no cells."
CellularAutomaton::invk = "Invalid keys in rule specification `1`.";
CellularAutomaton::keytm = "Expecting only one of the keys `1` in rule specification `2`.";
CellularAutomaton::kord = "Key \"Order\" in `1` can only be given for a rule specified by \"RuleNumber\".";
CellularAutomaton::invrn = "Value `1` of key \"RuleNumber\" should be a non-negative integer.";
CellularAutomaton::invd = "Value `1` of key \"Dimension\" should be a positive integer.";
CellularAutomaton::invc = "For a rule specified by `1`, value `2` of key \"Colors\" should be `3`.";
CellularAutomaton::invrg = "Value `1` of key \"Range\" should be a radius, a non-empty list of radii, or a non-empty list of offsets. A radius must be (d - 1)/2 for some positive machine integer d. The offsets are non-empty lists of machine integers.";
CellularAutomaton::invorep = "Offset values `1` of key \"Range\" should be distinct.";
CellularAutomaton::invn = "Value `1` of key \"Neighborhood\" should be an array of non-negative machine integers, \"Moore\", \"VonNeumann\", or a size of a \"Moore\" or \"VonNeumann\" neighborhood."
CellularAutomaton::invord = "Value `1` of key \"Order\" should be a positive integer.";
CellularAutomaton::invgen = "Value `1` of key \"GenerationSpan\" should be an integer greater than or equal to 2.";
CellularAutomaton::invgc = "Value `1` of key `2` should be an empty list or a list of distinct non-negative integers.";
CellularAutomaton::invgsc = "Value `1` of key `2` should be a list of two elements, with each element an empty list or a list of distinct non-negative integers. The second element can also be All.";
CellularAutomaton::invgdc = "Value `1` of key `2` should be a list of two elements, with each element an empty list or a list of distinct non-negative integers.";
CellularAutomaton::invglsc = "Value `1` of key `2` should be a list of two elements, with the first element an empty list or a list of distinct non-negative integers, and the second element an integer greater than 1.";
CellularAutomaton::nbrsize = "Value `1` of key `2` should be a list of distinct positive integers smaller than or equal to `3`.";
CellularAutomaton::otcoff = "Range `1` cannot be a list of offsets for rules specified by \"OuterTotalisticCode\".";
CharacterRange::argtype = "Arguments `1` and `2` of `3` should be either non-negative integers or one-character strings."
General::tolnn = "Tolerance specification `1` must be a non-negative number."
Circle::angle = "Starting angle is larger than ending angle in angle specification `1`."
Circle::radius = "Radius `1` is not a positive number or a pair of positive numbers."
Clear::spsym = ClearAll::spsym = "Special symbol `1` cannot be cleared."
Clear::ssym = ClearAll::ssym = "`1` is not a symbol or a string."
ClearAll::clloc = "Cannot clear local variable `1`."
ClebschGordan::phy = "`1` is not physical."
SixJSymbol::tri = ClebschGordan::tri = "`1` is not triangular."
ImageClip::rtwo = Clip::rtwo = "The argument `1` at position `2` is expected to be a list of a lower clip bound and an upper clip bound."
ImageClip::vtwo = Clip::vtwo = "The argument `1` at position `2` is expected to be a list of a lower replacing value and an upper replacing value."
Clock::period = "Clock period `1` is not a finite positive number."
Clock::vals = "Clock called with illegal iterator values, `1`."
Clock::length = "The length of the Clock, `1`, cannot be computed."
Clock::inf = "It is not allowed to specify the period or count with an infinite clock."
Close::spfile = "Cannot close special file `1`."
Coefficient::numv = Exponent::numv = "`1` takes exactly one variable."
CoefficientList::pad1="Padding `1` for CoefficientList is not a non-negative machine integer."
CoefficientList::padlist="Padding `1` for CoefficientList is not a list of non-negative machine integers."
CoefficientArrays::eelist = "The first argument `1` should be a list of polynomials or equations."
ColorOutput::colpn = ToColor::colpn = "Result `1` obtained during color conversion by applying function `2` to color `3` contains a non-numerical argument."
ColumnForm::colmh = "Horizontal alignment specification `1` is not Left, Center, or Right."
ColumnForm::colmv = "Vertical alignment specification `1` is not Below, Center, or Above."
CreateNotebook::badtype = "`1` is not a type recognized by CreateNotebook."
CreateNotebook::nbnfnd = "Unable to find the notebook `1`."
CreateNotebook::noconv = "Converting `1` to type `2` is not supported yet."
CreateDialog::mpfns = "CreateDialog does not currently support multipage forms."
DialogInput::mpfns = "DialogInput does not currently support multipage forms."
General::invspatt = "The argument `1` is not a valid string pattern."
General::array = "The array dimensions `2` given in position 2 of `1` should be a list of non-negative machine-sized integers giving the dimensions for the result."
General::nspec = "`1` is not a valid `2` specification."
General::invrk = "The argument `1` is not a valid rule."
General::invak = "The argument `1` is not a valid Association."
General::inval = "The argument `1` is not a valid AmbiguityList."
General::invlc = "The argument `1` is not a list of Associations."
General::invas = "The argument `1` is not a valid Association or rule."
General::invaa = "The argument `1` is not a valid Association or a list of Associations."
General::invrl = "The argument `1` is not a valid Association or a list of rules."
General::invrp = "The argument `1` is not a valid Association or a list."
General::invdt = "The argument `1` is not a rule or a list of rules."
General::invdt1 = "The argument `1` is not a valid list of rules."
General::invar = "The argument `1` is not a valid list of Associations or rules."
General::invl = "The argument `1` is not a list."
General::invlb = "The argument `1` is not a list, Rule, or Association."
General::invla = "The argument `1` contains incompatible elements."
General::incpt = "Incompatible elements in `1` cannot be joined."
General::invjs = "The argument `1` is not a valid join specification."
General::invru = "The argument `1` is not a valid Association or a list of rules."
General::keynx = "Key `1` does not exist in Association `2`."
General::kvlen = "Key specification `1` has unequal lengths."
General::nprec = "The value `2` of the option `1` should be a positive machine integer or Automatic."
General::expons = "The value `2` of the option `1` should be a list of two values. Each can be a machine integer or +/- Infinity."
Lookup::luarg = "`1` has an incorrect number of arguments."
General::incmp = "The arguments `1` and `2` in `3` are incompatible."
General::list1 = "The argument `1` is not a valid list of Associations or rules or lists of rules."
JoinAcross::jbspc = "The join method `1` is not \"Inner\", \"Outer\", \"Left\", or \"Right\"."
JoinAcross::jfun = "The value `1` of the option `2` does not evaluate to a list of length 2."
JoinAcross::jkspc = "`1` is not a valid key specification."
JoinAcross::keynx1 = "Key `1` does not exist."
Compile::argcomp = "The comparison, `1`, is invalid for arguments of type `2`."
Compile::argcompten = "The comparison, `1`, is invalid for tensor arguments."
Compile::argset = "The assignment to `1` is illegal; it is not valid to assign a value to an argument."
Compile::attnrt = "`1` is not a known runtime attribute and will be ignored."
Compile::iterset = "The assignment to `1` is illegal; the compiler cannot assign a value to an iterator variable."
Compile::ccon = "Non-numerical object `1` with attribute Constant cannot be compiled."
Compile::cfinll = "The CompiledFunction `1` could not be inlined because its use requires threading with the Listable runtime attribute."
Compile::cif = "The types of the two results in `1` are incompatible because their ranks are different. Evaluation will use the uncompiled function."
Compile::compfail = "Compilation of `1` failed because `2` was not a form suitable for the compiler."
Compile::cpapot = "Compilation of `1` is not supported for the function argument `2`. The only function arguments supported are Times, Plus, or List. Evaluation will use the uncompiled function."
Compile::cpbool = "`1` at position `2` of `3` should be of type True | False; evaluation will use the uncompiled function."
Compile::cpdsts = "Compile cannot determine the rank of the result of `1`; evaluation will use the uncompiled function."
Compile::cpint = "`1` at position `2` of `3` should be a machine-sized integer; evaluation will use the uncompiled function."
Compile::cpintlt = "`1` at position `2` of `3` should be either a nonzero integer or a vector of nonzero integers; evaluation will use the uncompiled function."
Compile::cpintlt2 = "`1` at position `2` of `3` should be a nonzero integer, or a vector or matrix of nonzero integers; evaluation will use the uncompiled function."
Compile::cpiter = "Iterator at position `1` of `2` cannot be compiled; evaluation will use the uncompiled function."
Compile::cplist = "`1` should be a tensor of type Integer, Real, or Complex; evaluation will use the uncompiled function."
Compile::cpout = "Compile cannot work on Outer for tensors of different rank; evaluation will use the uncompiled function."
Compile::cppat = "Compile does not support patterns: `1` cannot be compiled; evaluation will use the uncompiled function."
Compile::cprank = "Compile cannot determine the rank of the result tensor. The length of `1` in `2` is unknown at compiling time; evaluation will use the uncompiled function."
Compile::cpts = "The result after evaluating `1` should be a tensor. Nontensor lists are not supported at present; evaluation will proceed with the uncompiled function."
Compile::cptype = "`2` is not supported for type `1`; evaluation will use the uncompiled function."
Compile::cpw = "Cannot compile raw expression `1` of type `2`."
Compile::cret = "The type of return values in `1` are different. Evaluation will use the uncompiled function."
Compile::cret1 = "The type of Return expression `1` is incompatible with a previous Return expression."
Compile::cset = "Variable `1` of type `2` encountered in assignment of type `3`."
Compile::ctyp1 = "Number `1` in `2` is an invalid compiler variable. A symbol can be used as a valid variable."
Compile::ctyp2 = "Invalid type or rank specification in `1`."
Compile::ctyps = "Invalid subexpression type specification `1`."
Compile::exttensor = "`1` cannot be compiled and will be evaluated externally. The result is assumed to be a rank `3` tensor of type `2`."
Compile::extscalar = "`1` cannot be compiled and will be evaluated externally. The result is assumed to be of type `2`."
Compile::fun = "Compilation of `1` cannot proceed. It is not possible to compile pure functions with arguments that represent the function itself."
Compile::maxrank = "Rank specification `1` in `2` exceeds the rank limit (`3`)."
Compile::realcoerce = "Warning: compilation of `1` has coerced an exact number to an approximate real number."
Compile::cxcoerce = "Warning: compilation of `1` has coerced an exact number to an approximate complex number."
Compile::defn = "CompileValue `1` for `2` is not an expression of length 2."
Compile::part = "Part specification `1` cannot be compiled since the argument is not a tensor of sufficient rank. Evaluation will use the uncompiled function."
Compile::symdef = "The symbol `1` used in assignment `2` has not been declared as a local variable."
Compile::type = "Type specification `1` is not legal. A legal type is of the form {name, typepattern} or {name, typepattern, rank}."
Compile::initvar = "The variable `1` has not been initialized or has been initialized to Null."
Compile::nocomp = "The expression `1` cannot be compiled due to the presence of `2`. Evaluation will use the uncompiled function."
Compile::noinfo = "No information is available for compilation of `1`. The compiler will use an external evaluation and make assumptions about the return type."
Compile::bdtarg = "The value given in CompilationTarget->`1` should be \"WVM\" or \"C\"."
Compile::bdrt = "The value given in RuntimeOptions->`1` should be Automatic, \"Quality\", or \"Speed\", possibly followed by nested options."
Compile::nogen = "A library could not be generated from the compiled function."
Compile::cpseed = "Compilation of SeedRandom is only supported for integer seeds and methods `1`; evaluation will use the uncompiled function."
FindCharacterEncoding`FindCharacterEncoding::insuffinfo = "The classifier needs more bytes to accurately predict the encoding."
FindCharacterEncoding`FindCharacterEncoding::improperdata = "Byte values must lie within the range 0-255."
FindCharacterEncoding`FindCharacterEncoding::frstarg = "The first argument `1` of `2` should be a list of integers, a byte array, or a file object."
LibraryFunction::arglist = "The function arguments `1` should be given as a list."
LibraryFunction::ffsload = "The function name `1` and the file name `2` should be strings."
LibraryFunction::btype = "Invalid type and/or rank specification in `1`."
LibraryFunction::pass = "The argument passing method `1` should be Automatic, \"Shared\", or \"Manual\"."
LibraryFunction::rpass = "The passing method for the result was not Automatic or \"Shared\"; it will be treated as Automatic."
LibraryFunction::rtypes = "The return type `1` specifies an undetermined type for a scalar. You must specify the type explicitly for scalars."
Compile::boolt = "The specification `1` specifies a tensor of Boolean type. Only Boolean scalars are allowed."
LibraryFunction::lfie = "The argument `1` is not `2`."
LibraryFunction::mman = "The argument passing method `1` for `2` should be Automatic, or \"Manual\"."
LibraryFunction::dsnull = "A DataStore node that has an unset or cleared value was encountered and converted to the expression Null."
LibraryFunction::dsself = "A DataStore that has a node referring to the DataStore itself was enountered. The node was converted to the expression Null."
CompiledFunction::typerr = "An error caused by inconsistent types was encountered evaluating the generated C function `1`; proceeding with uncompiled evaluation."
LibraryFunction::typerr = "An error caused by inconsistent types was encountered evaluating the function `1`."
CompiledFunction::rnkerr = "An error caused by inconsistent tensor rank was encountered evaluating the generated C function `1`; proceeding with uncompiled evaluation."
LibraryFunction::rnkerr = "An error caused by inconsistent tensor rank was encountered evaluating the function `1`."
CompiledFunction::dimerr = "An error caused by inconsistent dimensions or exceeding array bounds was encountered evaluating the generated C function `1`; proceeding with uncompiled evaluation."
LibraryFunction::dimerr = "An error caused by inconsistent dimensions or exceeding array bounds was encountered evaluating the function `1`."
CompiledFunction::numerr = "A numerical error was encountered evaluating the generated C function `1`; proceeding with uncompiled evaluation."
LibraryFunction::numerr = "An numerical error was encountered evaluating the function `1`."
LibraryFunction::rterr = "An error with return code `2` was encountered evaluating the function `1`."
LibraryFunction::rnoset = "The function was executed but it failed to set a value for the result."
LibraryFunction::strnull = "The function was executed but the returned value was not a string."
LibraryFunction::strerr = "An error occurred during the conversion of the result to a string expression."
LibraryFunction::imgerr = "An error occurred during the conversion of the result to an image expression."
LibraryFunction::imgnull = "The function was executed but the returned value was not an image expression."
LibraryFunction::reserrt = "The result was of type `1` instead of the specified type `2`."
LibraryFunction::reserrr = "The result had rank `1` instead of the specified rank `2`."
LibraryFunction::imgerrd = "The rank `1` of the result does not match the `2` expression."
LibraryFunction::shrnopack = "The argument `1` at position `2` was not a PackedArray but was successfully converted to a PackedArray."
LibraryFunction::libload = "The function `2` was not loaded from the file `1`."
LibraryFunction::initerr = "A nonzero error code `1` was returned during the initialization of the library `2`."
LibraryFunction::funloaded = "The function `1` has already been loaded with an incompatible type of argument structure."
LibraryFunction::nofun = "The function `1` is not a valid LibraryFunction."
LibraryFunction::nolib = "The library `1` cannot be found."
LibraryFunction::load = "The library `1` cannot be loaded."
LibraryFunction::unloadfun = "The function `1` cannot be unloaded."
LibraryFunction::unloadlib = "The library `1` cannot be unloaded."
LibraryFunction::overload = "The function `1` has already been loaded with argument types `2`. The new function will be an overload for different types."
LibraryFunction::version = "The version number `1` of the library is not consistent with the current or any previous WolframLibraryVersion."
LibraryFunction::verserr = "An error due to an incompatible function call was encountered evaluating the function `1`. The library was compiled with a previous WolframLibrary version. Recompile with the current version to fix the error."
LibraryFunction::viniterr = "The version number `1` of the library `2` is from a previous WolframLibrary and an error due to an incompatible function call was encountered during the initialization of the library. Recompile with the current version to fix the error."
LibraryFunction::versint = "The version number `1` of the library is from a previous WolframLibrary that cannot support integers as large as `2`."
LibraryFunction::pversion = "The version number `1` of the library is from a previous WolframLibrary. Recompilation is recommended to get optimal performance with the current version."
CompiledFunction::cversion = "The library compiled with CompilationTarget->\"C\" is failing because it was compiled with a previous version, `1`, of WolframLibrary that uses incompatible types. Recompilation is recommended to get optimal performance with the current version."
CompiledFunction::ccf = "Result `1` of external evaluation does not have the correct form."
CompiledFunction::cfcode = "Invalid opcode `1`; a non-negative integer less than `2` is expected."
LibraryFunction::cfct = CompiledFunction::cfct = "Number of arguments `1` does not match the length `2` of the argument template."
CompiledFunction::cfex = "Could not complete external evaluation at instruction `1`; proceeding with uncompiled evaluation."
CompiledFunction::cfexe = "Could not complete external evaluation; proceeding with uncompiled evaluation."
CompiledFunction::cfff = "Fifth argument `1` should be of the form Function[{args}, expr]."
CompiledFunction::cffv = "First operation `1` does not check for correct version number."
CompiledFunction::cfins = "Arguments in instruction number `1` do not have the correct form."
CompiledFunction::cflist = "Nontensor object generated; proceeding with uncompiled evaluation."
CompiledFunction::cfn = "Numerical error encountered at instruction `1`; proceeding with uncompiled evaluation."
CompiledFunction::cfne = "Numerical error encountered; proceeding with uncompiled evaluation."
CompiledFunction::cfnlts = "Null tensor with rank > 1 encountered at instruction `1`; proceeding with uncompiled evaluation."
CompiledFunction::cfnv = "CompiledFunction object is invalid and cannot be used."
CompiledFunction::initf = "Initialization failure in CompiledFunction; uncompiled evaluation will be used."
CompiledFunction::cfver = "Incorrect version number; CompiledFunction object cannot be used."
CompiledFunction::mldot = "WSTP compiler cannot interpret Dot, Det, and Inverse operations; proceeding with uncompiled evaluation."
LibraryFunction::cfsa = CompiledFunction::cfsa = "Argument `1` at position `2` should be a `3`."
LibraryFunction::cfta = CompiledFunction::cfta = "Argument `1` at position `2` should be a rank `3` tensor of `4`s."
LibraryFunction::cfna = CompiledFunction::cfna = "Argument `1` at position `2` should be a rank `3` NumericArray of type `4`."
LibraryFunction::lfspar = "Argument `1` at position `2` is not a SparseArray or a list representation that can be converted into a SparseArray."
ConnectLibraryCallbackFunction::lcfcf = "`1` is not a valid CompiledFunction."
ConnectLibraryCallbackFunction::nrname = "The name `1` is not registered as a library callback manager."
CreateManagedLibraryExpression::nrname = "The name `1` is not registered as a library expression manager."
CreateManagedLibraryExpression::alman = "The evaluated expression `1` is already a managed library expression."
CompiledFunction::cfse = "Compiled expression `1` should be a `2`."
CompiledFunction::cfte = "Compiled expression `1` should be a rank `2` tensor of `3`s."
CompiledFunction::cfnae = "Compiled expression `1` should be a rank `2` NumericArray of type `3`."
CompiledFunction::cfsec = "Warning: compiled expression `1` was coerced to a `2`."
CompiledFunction::cftec = "Warning: compiled expression `1` was packed to a rank `2` tensor of `3`s."
CompiledFunction::orank = "The result of compiled Array or Outer has encountered a result of lower rank than expected due to a zero-length list; proceeding with uncompiled evaluation."
CompiledFunction::pext = "Instruction `2` in `1` calls ordinary code that can be evaluated on only one thread at a time."
CompiledFunction::npext = "`1` will not execute in parallel with the setting Parallelization->Automatic because it contains a call to ordinary code in instruction `2`."
CompiledFunction::nprng = "`1` will not execute in parallel with the setting Parallelization->Automatic because it uses random number generators and so would give different results when run in parallel."
CompiledFunction::plrng = "`1` uses the legacy function Random that can only be executed on one thread at once. RandomInteger, RandomReal, and RandomComplex are recommended instead."
CompiledFunction::psbrng = "SeedRandom and BlockRandom used in `1` in parallel only affect a single thread at a time. It is recommended that you use these outside of the parallel function call."
CompiledFunction::prngd = "Warning: `1` uses random numbers in parallel that will give different results than run serially."
CompiledFunction::tdlen = "Arguments of unequal length in `1` cannot be combined."
SeedRandom::pgmthd = "Method->\"ParallelGenerator\" cannot be used in a parallel computation. In a parallel computation, SeedRandom will only affect the generator for the thread in which it is run."
ComplexExpand::exf = "Value of option TargetFunctions -> `1` does not contain any of the allowed functions `2`."
ControllerState::csmal = "The file `1` does not contain a properly formatted device mapping table."
ControllerState::csnon = "The file `1` does not contain any valid device configurations."
RootIntervals::nupr = "`1` is not a univariate polynomial with rational number coefficients."
RootIntervals::bdom = "Domain specification `1` should be Reals or Complexes."
CountRoots::vbds = "The second argument `1` is expected to be a list of a variable, a Gaussian rational lower bound, and a Gaussian rational upper bound."
CountRoots::nmero = "CountRoots was unable to show that `1` is a univariate meromorphic function of `2` in [`3`, `4`]."
CountRoots::nuniv = "`1` is not a univariate function of `2`."
CountRoots::nmet = "Unable to compute the number of roots with the available methods."
Compress::comprfail = "The compressor failed when it tried to compress `1`."
Compress::comprver = "Value of Method option \"Version\" -> `1` should be an integer between 1 and 6."
CompressedData::corrupt = Uncompress::corrupt = "Compressed data \"`1`\" is corrupt and does not represent an expression."
General::wxfcor = "File `1` is corrupt and does not contain a properly serialized expression."
General::corrupt = "Serialized data `1` is corrupt and does not represent an expression."
General::invpainttype = "Unknown packed array integer type `1`. Using default setting Automatic. Additional valid settings include \"Integer8\", \"Integer16\", \"Integer32\", \"Integer64\"."
General::invpainttype32 = "Unknown packed array integer type `1`. Using default setting Automatic. Additional valid settings include \"Integer8\", \"Integer16\", \"Integer32\"."
General::invparealtype = "Unknown packed array real type `1`. Using default setting Automatic. Additional valid settings include \"Real32\", \"Real64\"."
General::invpacomplextype = "Unknown packed array complex type `1`. Using default setting Automatic. Additional valid settings include \"Complex64\", \"Complex128\"."
General::moptrs = "Ignoring `1` in `2` which is not a rule for a known method suboption."
General::bdmtd = "Value of option Method -> `1` should be Automatic or a list of rules with possible left hand sides: \"PackedArrayIntegerType\", \"PackedArrayRealType\", \"PackedArrayComplexType\". Using default setting Automatic."
General::invpacoerce = "Could not coerce PackedArray data to type `1`."
General::perfg = "Invalid performance goal specification `1`. The performance goal should be set to \"Speed\", \"Size\" or Automatic."
General::serializefail = "Cannot serialize `1`."
Condition::condp = "Pattern `1` appears on the right-hand side of condition `2`."
ConstrainedMax::cmnov = ConstrainedMin::cmnov = "No variables found."
ConstrainedMax::cmcons = ConstrainedMin::cmcons = "`1` is not a list of valid equalities or inequalities."
ConstrainedMax::cmfun = ConstrainedMin::cmfun = "`1` is not a linear function of `2` with real coefficients."
ConstrainedMax::cmnc = ConstrainedMin::cmnc = "Non-numerical constraint `1` encountered."
Context::cxdup = "Cannot set `1` to `2`, since a symbol already exists with name `3` and context `4`."
Context::cxname = "`1` is not a parsable context name ending in `2`."
Context::cxset = $Context::cxset = "Cannot set `1` to `2`; value is not a parsable context name ending in `3`."
Context::quote = "Warning: `1` is not a valid context. A valid context uses back quotes instead of forward quotes as in `2`."
Context::quote1 = "Warning: `1` is not a valid context. A valid context uses back quotes instead of forward quotes and ends in a back quote as in `2`."
ContextToFileName::cxfil = "ContextToFileName[`1`] evaluated to `2`; a string is expected; the system will use `3`."
Continue::nofunc = "Function `1` not found enclosing `2`."
Continue::nofwd = "No enclosing For, While, or Do found for `1`."
ContinuedFraction::incomp = "Warning: ContinuedFraction terminated before `` terms."
ContinuedFraction::noterms = "`` does not have a terminating or periodic continued fraction expansion; specify an explicit number of terms to generate."
ContinuedFraction::start = "Warning: ContinuedFraction was unable to obtain at least one term using precision `1`.`2`"
ContinuedFraction::terms = "Warning: ContinuedFraction only obtained `1` of `2` requested terms using precision `3`.`4`"
ContinuedFractionK::div = "The continued fraction `1` does not converge."
ContourGraphics::ctpnt = "The contour is attempting to traverse a cell in which some of the points have not evaluated to numbers, and they will be dropped."
ContourGraphics::ctsm = "It is not possible to shade a ContourGraphics object if some of the mesh points do not evaluate to numbers."
ContourGraphics::meshr = DensityGraphics::meshr = SurfaceGraphics::meshr = "Value of option MeshRange -> `1` is not of the form {{xmin, xmax}, {ymin, ymax}}."
DefineInputStreamMethod::methnf = "Input stream method `1` must have method `2` defined."
DefineInputStreamMethod::methig = DefineOutputStreamMethod::methig = "Ignoring `1`, which is not a recognized stream method function definition."
DefineInputStreamMethod::name = "An input stream method named `1` has already been registered."
DefineOutputStreamMethod::methnf = "Output stream method `1` must have method `2` defined."
DefineOutputStreamMethod::name = "An output stream method named `1` has already been registered."
RemoveInputStreamMethod::rmx = "Input stream method `1` does not exist."
RemoveOutputStreamMethod::rmx = "Output stream method `1` does not exist."
General::instrmres = "Result `1` returned by `2` of input stream method `3` is not a list with two elements of the form {result,newstate}."
General::outstrmres = "Result `1` returned by `2` of output stream method `3` is not a list with two elements of the form {result,newstate}."
General::instrmrdfmt = "Read result `1` returned by `2` of input stream method `3` is not a list of integers in the range 0 to 255."
General::instrmopt = "Option changes result `1` returned by `2` of input stream method `3` is not a list of rules."
General::outstrmopt = "Option changes result `1` returned by `2` of output stream method `3` is not a list of rules."
ListPlot3D::arrayerr = ListPointPlot3D::arrayerr = "`1` must be a valid array or a list of valid arrays."
ListContourPlot::arrayerr = ListDensityPlot::arrayerr = ArrayFilter::array = "`1` must be a valid array."
General::pllim = "Range specification `1` is not of the form {x, xmin, xmax}."
LogLogPlot::llplim = LogLinearPlot::llplim = "Range specification `1` is not of the form {x, xmin, xmax} with xmin and xmax positive."
ContourPlot::pptt = DensityPlot::pptt = Plot3D::pptt = "Value of option PlotPoints -> `1` is not an integer >= 2 or a list of two such integers."
Contours::ctnl = "Value of option Contours -> `1` is not a positive integer or a list of numbers."
ContourSmoothing::ctnsm = "Value of option ContourSmoothing -> `1` is not True, Automatic, False, or None."
IsolatingInterval::npos = "`1` is not a positive number."
Convergents::terms = "`` does not have a terminating or periodic continued fraction expansion; specify an explicit number of terms to generate."
CopulaDistribution::dim2 = "Copula kernel `1` is specific to two dimensions."
CopulaDistribution::umd = "Univariate marginal distributions are expected at position `1` of `2`."
CopulaDistribution::unskrn = "Copula kernel specification `1` is not supported."
MarginalDistribution::bdc = "The marginal specification `1` is expected to be a positive integer or a list of distinct positive integers not exceeding the distribution dimensionality `2`."
CopyDirectory::dirne = DeleteDirectory::dirne = RenameDirectory::dirne = "Directory `1` not empty."
CopyDirectory::dirfl = CopyFile::dirfl = RenameDirectory::dirfl = RenameFile::dirfl = "File types of `1` and `2` are incompatible."
CopyFile::filex = RenameFile::filex = "Cannot overwrite existing file `1`."
CopyFile::noscheme = "URL scheme in `1` is not supported in CopyFile."
CopyDirectory::filex = RenameDirectory::filex = "Cannot overwrite existing directory `1`."
Encode::noclob = "The output file `2` is the same as the source `1`."
(* Cryptography paclet messages begin *)
Encrypt::libopenssl = "Couldn't load OpenSSL library."
Encrypt::invkeyspec = Decrypt::invkeyspec = "Key should be a string or valid SymmetricKey, PrivateKey, or PublicKey."
Encrypt::ecckeyspec = Decrypt::ecckeyspec = "Encryption is not available with elliptic curves."
Encrypt::failed = "Data could not be encrypted."
Decrypt::failed = "Data could not be decrypted."
Decrypt::key = "Key is not compatible with the encrypted data." 
Encrypt::keylen = Decrypt::keylen = "Key is not of suitable length."
Encrypt::ivlen = Decrypt::ivlen = "Initialization vector is not of suitable length."
Encrypt::padding = Decrypt::padding = "Specified padding could not be used."
Encrypt::len = Decrypt::len = "Input too long for this encryption method."
Encrypt::invdata = "Input is not a valid ByteArray."
Decrypt::invdata = "`` is not a ByteArray or valid EncryptedObject."
EncryptFile::overwrite = DecryptFile::overwrite = "Set OverwriteTarget -> True to allow overwriting."
EncryptFile::source = "Could not read plaintext from source `1`."
EncryptFile::target = "Could not write ciphertext to target `1`."
DecryptFile::source = "Could not read ciphertext from source `1`."
DecryptFile::target = "Could not write plaintext to target `1`."
DecryptFile::perm = "Default permissions not set to \"Private\".  Decrypted plaintext may be publicly available on the cloud.  Specify permissions with the Permissions option to stop this message."
General::invba = "`1` is not a valid ByteArray."
GenerateAsymmetricKeyPair::failure = "Couldn't generate a key pair."
GenerateAsymmetricKeyPair::invcipher = "`1` is not a valid \"Cipher\"." 
GenerateAsymmetricKeyPair::invcompress = "The value of \"Compressed\" `1` should be either True or False"
GenerateAsymmetricKeyPair::invcurvename = "`1` is not a valid \"CurveName\"."
GenerateAsymmetricKeyPair::invkeysize = "`1` is not a valid \"KeySize\"."
GenerateAsymmetricKeyPair::invmethod = "The value of the option Method -> `` should be a string or an association."
GenerateAsymmetricKeyPair::invpexp = "The \"PublicExponent\" `1` should be an odd integer greater than 3."
GenerateAsymmetricKeyPair::invpadding = "The \"Padding\" `1` should be one of ``."
GenerateAsymmetricKeyPair::invspecs = "The value of the option Method -> `` is not a valid combination of specifications."
GenerateAsymmetricKeyPair::invtype = "`1` is not a valid \"Type\"."
GenerateAsymmetricKeyPair::nocipher = "No cipher or elliptic curve specified."
GenerateAsymmetricKeyPair::notype = "Warning: \"Type\" parameter is not provided. Assuming \"`1`\""
PublicKeyFormat::invpubkey = "`1` is not a valid public key format"
GenerateDerivedKey::optx1 = "Unknown option `1`."
GenerateDerivedKey::nassoc = "`1` is not an Association."
GenerateDerivedKey::nparm = "Incorrect parameters for `1` specified."
GenerateDerivedKey::keysize = "No output key size specified."
GenerateDerivedKey::passwd = VerifyDerivedKey::passwd = "Password is not a string, a list of positive integers, or a ByteArray."
GenerateDerivedKey::salt = "Salt is not a string, a list of positive integers, or a ByteArray."
GenerateDerivedKey::alg = "Unknown key derivation algorithm `1`."
GenerateDerivedKey::msize = "Parameters specified in `1` must be machine-size integers."
GenerateDerivedKey::nbyte = "`1` is not a list of integer values between 0 and 255."
GenerateDerivedKey::tmax = "The value `1` of `2` is too large."
GenerateDerivedKey::tpos = "The value `1` of `2` must be a positive integer."
GenerateDerivedKey::tmin = "The value of t is too small."
GenerateDerivedKey::mmin = "The value of m is too small."
GenerateDerivedKey::pmin = "The value of p is too small."
GenerateDerivedKey::sout = "Output size is too small."
GenerateDerivedKey::lout = "Output size is too large."
GenerateDerivedKey::spwd = "Password size is too small."
GenerateDerivedKey::lpwd = "Password size is too large."
GenerateDerivedKey::sslt = "Salt size is too small."
GenerateDerivedKey::lslt = "Salt size is too large."
GenerateDerivedKey::type = "Unknown algorithm `1`."
GenerateDerivedKey::invn = "The value `1` of N must be a power of 2 greater than 1."
GenerateDerivedKey::err = "Could not compute derived key."
DerivedKey::invstr = "String `1` cannot be interpreted as a derived key."
GenerateSymmetricKey::invcipher = "`1` is not a valid cipher."
GenerateSymmetricKey::invmethodkey = GenerateAsymmetricKeyPair::invmethodkey = GenerateDigitalSignature::invmethodkey = "The method key `1` is not one of ``."
GenerateSymmetricKey::invblockmode = "`1` is not a known block mode for this cypher."
GenerateSymmetricKey::invivlen = "Cipher requires initialization vector of `1` bytes; `2` bytes given."
GenerateSymmetricKey::inviv = "Initialization vector `` should be Automatic, None, or a valid ByteArray."
GenerateSymmetricKey::invkeysize = "`1` is not a valid key size."
GenerateSymmetricKey::nocipher = "No cipher given."
GenerateSymmetricKey::invdkey = "Derived key `1` is not valid."
GenerateSymmetricKey::invkeysz = "`1` has length `2`; `3` is expected."
GenerateSymmetricKey::nbyte = "`1` is not a list of integer values between 0 and 255."
GenerateDigitalSignature::invec = "`1` is not a supported elliptic curve specification."
GenerateDigitalSignature::invkey = "`1` is not a valid elliptic curve private key."
GenerateDigitalSignature::invmethod = "The value of the option Method -> `` should be an association or Automatic."
GenerateDigitalSignature::invmode = "The value of the option \"SignatureType\" -> `1` should be either Deterministic or NonDeterministic."
GenerateDigitalSignature::invarg = "Invalid set of arguments."
GenerateDigitalSignature::invdeterk = "Failed to calculate deterministic signature."
GenerateDigitalSignature::invtype = GenerateAsymmetricKeyPair::invtype
GenerateDigitalSignature::invcurvename = GenerateAsymmetricKeyPair::invcurvename
GenerateDigitalSignature::invhash = "`1` is not a valid hashing method."
GenerateDigitalSignature::hashnone = VerifyDigitalSignature::hashnone =
		"Input `1` should be a string of hexadecimal characters or a ByteArray."
VerifyDigitalSignature::invsig = "Signature `1` should be a valid DigitalSignature object."
VerifyDigitalSignature::invpubkey = "`1` is not a valid elliptic curve public key."
VerifyDigitalSignature::invarg = "`1` is not a pair {expr, sig} or a list of such pairs."
(* Cryptography paclet messages end *)
CopyDirectory::nodir = DeleteDirectory::nodir = RenameDirectory::nodir = "Directory `1` not found."
Internal`CreateAsynchronousTask::id = "Value `1` returned from `2` was not an integer."
Internal`CreateAsynchronousTask::noid = "Asynchronous task ID `1` returned from `2` is not an active asynchronous task."
Cross::nonn1 = "The arguments are expected to be vectors of equal length, and the number of arguments is expected to be 1 less than their length."
CylindricalDecomposition::nrtpi = GenericCylindricalDecomposition::nrtpi = "`1` is not a logical formula consisting of polynomial equations and inequalities in `2` with rational number coefficients."
CylindricalDecomposition::cadop = "`1` is not a valid topological operation specification."
CylindricalDecomposition::nmet = "Unable to compute a cylindrical decomposition of the result of applying the topological operation `1` to the solution set."
General::disj = "Variable lists `1` and `2` should be disjoint."
D::dvar = "Multiple derivative specifier `1` does not have the form {variable, n}, where n is symbolic or a non-negative integer."
D::dup = "Array differentiation specification `1` contains repeated variables."
DifferenceDelta::dvar = "Difference specifier `1` does not have the form {variable, n} or {variable, n, h}, where n is a non-negative machine integer."
Differences::depth = "Requested differences `1` exceeds the array depth, `2`, of the input."
Ratios::depth = "Requested ratios `1` exceeds the array depth, `2`, of the input."
Dashing::dshn = AbsoluteDashing::dshn = "Argument in `1` is not a list of numbers."
Date::zspec = "Time zone specification `1` cannot be converted to a valid date."
DateDifference::cal = DatePlus::cal = "The time unit `1` is not supported in the `2` calendar."
DateDifference::twoarg = "Argument `1` is not a time unit or a list of time units, nor can it be interpreted as a date."
DateList::arg = "Argument `1` cannot be interpreted as a date or time input."
DateList::str = "String `1` cannot be interpreted as a date in format `2`."
$TimeZone::tznan = "$TimeZone specification `1` is not a number. Using the system time zone instead."
DateList::ambig = DateString::ambig = AbsoluteTime::ambig = UnixTime::ambig = JulianDate::ambig = "Warning: the interpretation of the string `1` as a date is ambiguous."
DateList::zspec = "Time zone specification `1` cannot be converted to a valid date."
DateList::unkn = "String `1` cannot be interpreted as part of the date or time."
DateString::arg = "Argument `1` cannot be interpreted as a date or time input or as a date string format."
DateString::fmt = "`1` is not a valid date format."
General::datenx = "Specification `1` cannot be resolved to an exact date."
General::stspec = "`1` cannot be interpreted as a ScheduledTask specification."
General::date = "Expression `1` cannot be interpreted as a date specification."
DateString::fmtarg = "`1` specifies the date format twice."
DateString::str = "String `1` cannot be interpreted as a date in format `2`."
General::prs = "The Unicode library cannot be loaded. The result will be computed without using it."
DateListPlot::ntdt = "The first argument to DateListPlot should be a list of pairs of dates and real values, a list of real values, or a list of several such lists."
DateListLogPlot::ntdt = "The first argument to DateListLogPlot should be a list of pairs of dates and real values, a list of real values, or a list of several such lists."
General::ntstep = "The value `1` is not a valid date step specification."
General::dtvals = "Unable to automatically determine horizontal coordinates for the given data and DataRange."
General::dtspec = "The date coordinates could not be determined from the date specification `1`."
General::notdtf = "The specified value of the option DateTicksFormat -> `1` should be Automatic or a valid date format."
DateListStepPlot::step = "The step specification `1` should be Right, Left, or Center."
DateListStepPlot::opttf = "Value of option Joined -> `1` should be True or False."
Debug::dbug = "To inspect an expression, just evaluate it normally."
DeclarePackage::aldec = "Symbol `1` in `2` has already been declared."
Internal`WithTimestampsPreserved::symlist = "The symbol list `1` at position 1 of `2` should be a List of symbols.  (It may also be a Hold expression, and each symbol may be wrapped in Hold.)"
DefaultFont::dfont = "$DefaultFont specification `1` is not of the form {\"name\", size}."
DefaultFont::font = "Value of option DefaultFont -> `1` cannot be used as a font; using global $DefaultFont instead."
DefineExternal::des = "External function `1` of `2` could not be defined; it may still be called with ExternalCall[`2`, CallPacket[`1`, {args}]]."
Derivative::novar = "`1` cannot be interpreted. A partial derivative requires a subscript differentiation variable."
General::novar = "`1` cannot be interpreted. The operator `2` requires a subscript with a variable specification."
General::nolimvar= "`1` cannot be interpreted. The operator `2` requires a subscript or underscript a limit variable and point."
Div::novars = "`1` cannot be interpreted. In a divergence, the del operator requires a subscript with differentiation variables."
Curl::novars = "`1` cannot be interpreted. In a curl, the del operator requires a subscript with differentiation variables."
Laplacian::novars = "`1` cannot be interpreted. The Laplacian operator must include a superscript 2 and a subscript with differentiation variables."
Del::delpow = "`1` cannot be interpreted. The only valid power of the del operator is 2.";
General::malfop = "`1` cannot be interpreted. It is not a known operator constructed from the del operator.";
General::prebin = "`1` cannot be interpreted. The prefix operator `2` cannot be combined with the binary operator `3`.";
DiagonalMatrix::offdim = "The matrix dimension `1` is not a machine-sized integer."
Dialog::dpa = "Abort while evaluating DialogProlog `1` caught in dialog."
Dialog::exd = "To exit a dialog, use Return[] or Return[expr]. To exit the entire session, type Exit[]."
DifferenceRoot::pfn = DifferentialRoot::pfn = "`1` is not a pure function."
DifferentialRoot::deqn = "`1` is not a well-formed linear differential equation with initial conditions."
DifferenceRoot::deqn = "`1` is not a well-formed linear difference equation with initial conditions."
DifferentialRoot::ieqn = "The supplied equation in `1` is not a linear differential equation with polynomial coefficients."
DifferenceRoot::ieqn = "The supplied equation in `1` is not a linear difference equation with polynomial coefficients."
DifferenceRoot::icond = "Initial conditions should be of the form y[a] == b0, y[a + 1] == b1, ..."
DifferentialRoot::icond = "Initial conditions should be of the form y[a] == b0, y'[a] == b1, ..."
DifferentialRoot::inbrc = "Cannot interpret the given branch cuts in `1`."
DifferenceRoot::ifprec = DifferentialRoot::ifprec = "Parameters in `1` are not exact numbers."
DifferentialRoot::undef = "`1` does not define a suitable differential root object."
DifferenceRoot::undef = "`1` does not define a suitable difference root object."
DigitCount::base = "The base `1` at position 2 of `2` should be an integer greater than 1."
DigitCount::digp = "Positive integer or list of non-negative integers less than the base `1` expected at position 3 in `2`."
Directory::dirx = "`1`."
DirichletCharacter::invl = DirichletL::invl = "Argument `2` at position `3` in `1` should be a positive integer less than or equal to `4`."
Disk::angle = "Starting angle is larger than ending angle in angle specification `1`."
Disk::radius = "Radius `1` is not a positive number or a pair of positive numbers."
Display::badargs = "`1`."
Display::dispgif = "Too many arguments for GIF conversion."
Display::dopen = "Could not open the output file \"`1`\"."
Display::dwrite = "Could not write to the output file \"`1`\"."
Display::fname = "Filename `1` is not a string."
Display::gfile = "`1` is not a valid filename."
Display::image = "Value of option `1` -> `2` is not a list of two numbers or Automatic."
Display::noform = "`1` is not a recognized Display format. The available formats include `2`."
Display::nolink = "Link to display device could not be opened."
Display::pserr = "`1`."
Display::type = "`1` is not a graphics, notebook, cell, or box expression."
DivisorSum::pfn = "`1` is not a pure function."
DMSString::qua = DMSList::qua = FromDMS::qua = "`1` cannot be interpreted as a Quantity angle specification."
DMSString::num = DMSList::num = FromDMS::num = "`1` cannot be interpreted as a numerical angle specification."
DMSString::dms = DMSList::dms = FromDMS::dms = "`1` cannot be interpreted as a degree-minute-second list specification."
DMSString::str = DMSList::str = FromDMS::str = "`1` cannot be interpreted as a degree-minute-second string specification."
DMSString::ang = DMSList::ang = FromDMS::ang = "`1` cannot be interpreted as a degree-minute-second angle specification."
DMSString::prec = "Precision specification `1` should be a non-negative integer."
DMSString::form = "Invalid formatting specification `1`."
Dot::dotsh = "Tensors `1` and `2` have incompatible shapes."
Dot::dotpat = "Cannot combine array of pattern type with an ordinary array."
DownValues::itloc = UpValues::itloc = OwnValues::itloc = FormatValues::itloc = DefaultValues::itloc = NValues::itloc = Messages::itloc = SubValues::itloc = "`1` currently contains iterator localizations, and cannot be set (to `2`)."
DownValues::vlist = UpValues::vlist = OwnValues::vlist = FormatValues::vlist = DefaultValues::vlist = NValues::vlist = Messages::vlist = SubValues::vlist = "Cannot set `1` to `2`; value must be a list of rules."
DownValues::vrule = UpValues::vrule = OwnValues::vrule = FormatValues::vrule = DefaultValues::vrule = NValues::vrule = Messages::vrule = SubValues::vrule = "Cannot set `1` to `2`; value contains `3`, which is not a rule."
Drop::drop = "Cannot drop positions `1` through `2` in `3`."
NDSolve::badiseed = NDSolveValue::badiseed = ParametricNDSolve::badiseed = ParametricNDSolveValue::badiseed = NDSolve`ProcessEquations::badiseed = "Initial seeding `1` should be given as an equation or list of equations."
NDSolve::derivs = NDSolveValue::derivs = ParametricNDSolve::derivs = ParametricNDSolveValue::derivs = NDSolve`ProcessEquations::derivs = "No derivatives of dependent variables were found in the equations. `1` is designed to solve differential or differential algebraic equations. Use NSolve or FindRoot to numerically solve algebraic equations."
DSolve::dsfun = NDSolve::dsfun = NDSolveValue::dsfun = ParametricNDSolve::dsfun = ParametricNDSolveValue::dsfun = NDSolve`ProcessEquations::dsfun = RSolve::dsfun = RecurrenceTable::dsfun = "`1` cannot be used as a function."
DSolveValue::dsfun = RSolveValue::dsfun = "The function specification is not valid."
DSolve::dsvar = NDSolve::dsvar = NDSolveValue::dsvar = ParametricNDSolve::dsvar = ParametricNDSolveValue::dsvar = NDEigensystem::dsvar = NDEigenvalues::dsvar = NDSolve`ProcessEquations::dsvar = RSolve::dsvar = RecurrenceTable::dsvar = "`1` cannot be used as a variable."
DSolveValue::dsvar = RSolveValue::dsvar = "The variable specification is not valid."
ParametricNDSolve::dspar = ParametricNDSolveValue::dspar = "`1` cannot be used as a parameter."
NDSolve::deqx = NDSolveValue::deqx = ParametricNDSolve::deqx = ParametricNDSolveValue::deqx = NDSolve`ProcessEquations::deqx = "Supplied equations are not differential equations of the given functions."
DSolve::deqx = DSolveValue::deqx = "Supplied equations are not differential or integral equations of the given functions."
RSolve::deqx = RSolveValue::deqx = "Supplied equations are not difference equations of the given functions."
DSolve::dsmsm = RSolve::dsmsm = DSolveValue::dsmsm = "Built-in routines cannot solve this problem. There is an equation that involves none of the dependent variables or there is a dependent variable that does not appear in any equation."
DSolve::underdet = RSolve::underdet = RecurrenceTable::underdet = DSolveValue::underdet = "There are more dependent variables than equations, so the system is underdetermined."
NDSolve::underdet = NDSolveValue::underdet = ParametricNDSolve::underdet = ParametricNDSolveValue::underdet = NDSolve`ProcessEquations::underdet = "There are more dependent variables, `1`, than equations, so the system is underdetermined."
DSolve::overdet = RSolve::overdet = RecurrenceTable::overdet = DSolveValue::overdet = "There are fewer dependent variables than equations, so the system is overdetermined."
NDSolve::overdet = NDSolveValue::overdet = ParametricNDSolve::overdet = ParametricNDSolveValue::overdet = NDSolve`ProcessEquations::overdet = NDEigensystem::overdet = NDEigenvalues::overdet = "There are fewer dependent variables, `1`, than equations, so the system is overdetermined."
DSolve::deqn = NDSolve::deqn = NDSolveValue::deqn = ParametricNDSolve::deqn = ParametricNDSolveValue::deqn = NDEigensystem::deqn = NDEigenvalues::deqn = NDSolve`ProcessEquations::deqn = NDSolve`Reinitialize::deqn = RSolve::deqn = RecurrenceTable::deqn = NDSolve`Shooting::deqn = "Equation or list of equations expected instead of `1` in the first argument `2`."
DSolveValue::deqn = RSolveValue::deqn = "Equation or list of equations expected in the first argument."
DSolve::ivar2 = NDSolve::ivar2 = NDSolveValue::ivar2 = ParametricNDSolve::ivar2 = ParametricNDSolveValue::ivar2 = NDSolve`ProcessEquations::ivar2 = RSolve::ivar2 = RecurrenceTable::ivar2 = "The independent variable `1` should not appear in two different arguments of the dependent variable `2`."
DSolve::pde = DSolveValue::pde = "Partial differential equation may not have a general solution. Try loading Calculus`DSolveIntegrals` to find special solutions."
DSolve::twoivarg = NDSolve::twoivarg = NDSolveValue::twoivarg = ParametricNDSolve::twoivarg = ParametricNDSolveValue::twoivarg = NDSolve`ProcessEquations::twoivarg = RSolve::twoivarg = DSolveValue::twoivarg = "The function `1` has two independent variables in one argument. The independent variables should be in separate arguments."
DSolve::alliv = NDSolve::alliv = NDSolveValue::alliv = ParametricNDSolve::alliv = ParametricNDSolveValue::alliv = NDSolve`ProcessEquations::alliv = RSolve::alliv = DSolveValue::alliv = "The function `1` was specified without dependence on all the independent variables. Each function must depend on all the independent variables."
DSolve::baddv = NDSolve::baddv = NDSolveValue::baddv = ParametricNDSolve::baddv = ParametricNDSolveValue::baddv = NDSolve`ProcessEquations::baddv = RSolve::baddv = DSolveValue::baddv = "The dependent variable `1` is not clearly specified in the form `2`."
DSolve::ndord = NDSolve::ndord = NDSolveValue::ndord = ParametricNDSolve::ndord = ParametricNDSolveValue::ndord = NDSolve`ProcessEquations::ndord = NDSolve`Reinitialize::ndord = DSolveValue::ndord = "Derivative order `1` in term `2` should be a non-negative machine-sized integer."
DSolve::maxev = DSolveValue::maxev = "The maximum number of events has been reached. The currently computed solution has been returned."
RSolve::rord = "Recurrence order `1` of equation `2` is not a machine-sized integer."
RSolve::piarg = "All arguments in position `1` of `2` should be either of the form `3` + integer or q^integer * `3`. Mixtures of these forms are not allowed."
RecurrenceTable::excptn = "Value `1` is a numerical exception."
RecurrenceTable::piarg = "All arguments in position `1` of `2` should be in the form `3` + integer."
RecurrenceTable::bdmtd = "Value of option Method -> `1` is not a recognized method for RecurrenceTable."
RecurrenceTable::rtde = "Equations `1` are not recognized as simple difference equations."
RecurrenceTable::rtnc = "The number of constraints or initial conditions given, `1`, should be the same as the total order of the system, `2`."
DSolve::pdord = DSolveValue::pdord = "The differential order of functions `1` is 0. All the functions must have positive differential order."
RSolve::pdord = "The recurrence order of functions `1` is 0. All the functions must have positive recurrence order."
NDSolve::pdord = NDSolveValue::pdord = ParametricNDSolve::pdord = ParametricNDSolveValue::pdord = NDSolve`ProcessEquations::pdord = "Some of the functions have zero differential order, so the equations will be solved as a system of differential-algebraic equations."
NDSolve::regivc = NDSolveValue::regivc = ParametricNDSolve::regivc = ParametricNDSolveValue::regivc = NDSolve`ProcessEquations::regivc = "The independent variables from `2` must be ordered consecutively in the dependent variable arguments `1`."
DSolve::litarg = NDSolve::litarg = NDSolveValue::litarg = ParametricNDSolve::litarg = ParametricNDSolveValue::litarg = NDSolve`ProcessEquations::litarg = RSolve::litarg = RecurrenceTable::litarg = DSolveValue::litarg = "To avoid possible ambiguity, the arguments of the dependent variable in `1` should literally match the independent variables."
DSolve::bvimp = RSolve::bvimp = DSolveValue::bvimp = RSolveValue::bvimp = "General solution contains implicit solutions. In the boundary value problem, these solutions will be ignored, so some of the solutions will be lost."
DSolve::bvlim = RSolve::bvlim = DSolveValue::bvlim = RSolveValue::bvlim = "For some branches of the general solution, unable to compute the limit at the given points. Some of the solutions may be lost."
DSolve::bvfail = RSolve::bvfail = DSolveValue::bvfail = RSolveValue::bvfail = "For some branches of the general solution, unable to solve the conditions."
DSolve::bvnul = RSolve::bvnul = DSolveValue::bvnul = RSolveValue::bvnul = "For some branches of the general solution, the given boundary conditions lead to an empty solution."
DSolve::bvnr = RSolve::bvnr = DSolveValue::bvnr = RSolveValue::bvnr = "For some branches of the general solution, the given boundary conditions do not restrict the existing freedom in the general solution."
DSolve::bvsing = RSolve::bvsing = DSolveValue::bvsing = RSolveValue::bvsing = "Unable to resolve some of the arbitrary constants in the general solution using the given boundary conditions. It is possible that some of the conditions have been specified at a singular point for the equation."
DSolve::nolist = "List encountered within `1`. There should be no lists on either side of the equations."
DSolveValue::nolist = "There should be no lists on either side of the equations."
DSolve::nlpde = DSolveValue::nlpde = "Solution requested to nonlinear partial differential equation. Trying to build a special solution."
DSolve::pcju = DSolveValue::pcju = "Unable to detect the jumps in the piecewise differential equation. The solution may be discontinuous."
DumpGet::bgabi = "File `1` was written with ABI `2`, which is not compatible with this version of the Wolfram Language."
DumpGet::bgbf = "File `1` is corrupted and cannot be loaded."
DumpGet::bgcor = "Binary file `1` is corrupted."
DumpGet::bgcom = "Binary file `1` is corrupted: unable to read compression information."
DumpGet::bginc = "Incompatible binary file `1`."
DumpGet::bgmx = "File `1` does not appear to be a binary file or is corrupted."
DumpGet::bgnew = "File `1` has been written by a newer version of DumpSave and cannot be loaded."
DumpGet::bgsid = "Binary file `1` is corrupted: unable to read $SystemID information."
DumpGet::bgsys = "Binary file `1` is corrupted: unable to read system information."
DumpGet::bgver = "Binary file `1` is corrupted: unable to read version information."
DumpSave::bschk = "Could not write to output file."
DumpSave::bschk1 = "Could not write expr `1` of type `2` to output file."
DumpSave::bsnosym = "`1` is not defined as a symbol or a context."
DumpSave::bsstm = "DumpSave will not write out stream information `1`."
DumpSave::outref = "Encountered references to an external object `1` such as a file that will not be saved in the output."
SparseArray`SVDArnoldi::svdwop = SingularValueList::svdwop = SingularValueDecomposition::svdwop = "The option `1` with value `2` is not accepted by `3`."
SparseArray`SVDArnoldi::noimp = SingularValueList::noimp = SingularValueDecomposition::noimp = "The generalized `1` for sparse matrices is not implemented."
SparseArray`SVDArnoldi::emeth = SparseArray`Arnoldi::emeth = SingularValueList::emeth = SingularValueDecomposition::emeth = "The method specified by Method -> `1` should be either Automatic or Arnoldi."
Eigenvalues::emeth = Eigenvectors::emeth = Eigensystem::emeth = "The method specified by Method -> `1` should be Automatic, Arnoldi, Banded, or FEAST."
SparseArray`SVDArnoldi::genbd = SparseArray`Arnoldi::genbd = SingularValueList::genbd = SingularValueDecomposition::genbd = Eigenvalues::genbd = Eigenvectors::genbd = Eigensystem::genbd = "The generalized `1` for band matrices is not implemented."
Eigenvalues::chnpdef = Eigenvectors::chnpdef = Eigensystem::chnpdef = "Warning: there is a possibility that the second matrix `1` in the first argument is not positive definite, which is necessary for the Arnoldi method to give accurate results."
SingularValueList::take = "Cannot take singular values `1` through `2` out of the total of `3` singular values."
SingularValueDecomposition::take = "Cannot take singular values and singular vectors `1` through `2` out of the total of `3` singular values and singular vectors."
MatrixRank::cflsvd = SingularValueDecomposition::cflsvd = SingularValueList::cflsvd = SingularValues::cflsvd = "Machine-precision algorithm failed to converge. Arbitrary-precision algorithm is called, which is slower but more accurate."
Eigenvalues::take = "Cannot take eigenvalues `1` through `2` out of the total of `3` eigenvalues."
Eigenvectors::take = "Cannot take eigenvectors `1` through `2` out of the total of `3` eigenvectors."
CharacteristicPolynomial::cpneig = "Cannot compute all the eigenvalues of the matrix `1`."
CharacteristicPolynomial::cpneig2 = "Cannot compute all the eigenvalues of the pair of matrices `1` and `2`."
CharacteristicPolynomial::cpnscr = "Cannot compute the Schur decomposition of the matrix `1`."
CharacteristicPolynomial::cpnscr2 = "Cannot compute the Schur decomposition of the pair of matrices `1` and `2`."
SparseArray`Arnoldi::take = Eigensystem::take = "Cannot take eigenvectors and eigenvalues `1` through `2` out of the total of `3` eigenvectors and eigenvalues."
SparseArray`SVDArnoldi::take = "Cannot take singular vectors and singular values `1` through `2` out of the total of `3` singular vectors and singular values."
SparseArray`Arnoldi::ars = Eigenvalues::ars = Eigenvectors::ars = Eigensystem::ars = "Method -> Arnoldi is typically only effective for finding a few eigenvalues and/or eigenvectors. Finding the requested `1` out of `2` eigenvalues and eigenvectors may be faster with dense matrix methods."
SparseArray`SVDArnoldi::ars = SingularValueList::ars = SingularValueDecomposition::ars = "Method -> Arnoldi is typically only effective for finding a few singular values and/or singular vectors. Finding the requested `1` out of the `2` singular values and singular vectors may be faster with dense matrix methods."
SparseArray`Arnoldi::arall = Eigenvalues::arall = Eigenvectors::arall = Eigensystem::arall = "Method -> Arnoldi cannot be used to compute more than `1` out of the `2` eigenvalues and/or eigenvectors."
SparseArray`SVDArnoldi::arall = SingularValueDecomposition::arall = SingularValueList::arall = "Method -> Arnoldi cannot be used to compute more than `1` out of the `2` singular values and/or singular vectors."
SparseArray`SVDArnoldi::arfac = SparseArray`Arnoldi::arfac = SingularValueDecomposition::arfac = SingularValueList::arfac = Eigenvalues::arfac = Eigenvectors::arfac = Eigensystem::arfac = "Arnoldi algorithm failed because it could not build an Arnoldi factorization."
SparseArray`Arnoldi::arh = Eigenvalues::arh = Eigenvectors::arh = Eigensystem::arh = "Because finding `1` out of the `2` eigenvalues and/or eigenvectors is likely to be faster with dense matrix methods, the sparse input matrix will be converted. If fewer eigenvalues and/or eigenvectors would be sufficient, consider restricting this number using the second argument to `3`."
SparseArray`SVDArnoldi::arh = SingularValueDecomposition::arh = SingularValueList::arh = "Because finding `1` out of the `2` singular values and/or singular vectors is likely to be faster with dense matrix methods, the sparse input matrix will be converted. If fewer singular values and/or singular vectors would be sufficient, consider restricting this number using the second argument to `3`."
SparseArray`Arnoldi::arhm = Eigenvalues::arhm = Eigenvectors::arhm = Eigensystem::arhm = "Because finding `1` out of the `2` eigenvalues and/or eigenvectors is likely to be faster with dense matrix methods, the sparse input matrix will be converted. If fewer eigenvalues and/or eigenvectors at machine precision would be sufficient, consider using N on the matrix and restricting this number using the second argument to `3`."
SparseArray`SVDArnoldi::arhm = SingularValueDecomposition::arhm = SingularValueList::arhm = "Because finding `1` out of the `2` singular values and/or singular vectors is likely to be faster with dense matrix methods, the sparse input matrix will be converted. If fewer singular values and/or singular vectors at machine precision would be sufficient, consider using N on the matrix and restricting this number using the second argument to `3`."
SparseArray`SVDArnoldi::arm = SparseArray`Arnoldi::arm = SingularValueDecomposition::arm = SingularValueList::arm = Eigenvalues::arm = Eigenvectors::arm = Eigensystem::arm = "Method -> Arnoldi can only be used for matrices of machine- or arbitrary-precision real numbers."
SparseArray`SVDArnoldi::armc = SparseArray`Arnoldi::armc = SingularValueDecomposition::armc = SingularValueList::armc = Eigenvalues::armc = Eigenvectors::armc = Eigensystem::armc = "The Arnoldi method has encountered an intermediate value that is not a machine-precision number."
SparseArray`Arnoldi::argpd = Eigenvalues::argpd = Eigenvectors::argpd = Eigensystem::argpd = "The input matrices are sufficiently sparse that it is likely that the Arnoldi method would be faster for computing the requested eigenvalues and eigenvectors. However, the algorithm requires that the second matrix be positive definite, so dense methods will be used. If you know that the second matrix is positive definite, it is recommended that you use Method -> Arnoldi in `1`."
SparseArray`SVDArnoldi::argpd = SingularValueDecomposition::argpd = SingularValueList::argpd = "The input matrices are sufficiently sparse that it is likely that the Arnoldi method would be faster for computing the requested singular values and singular vectors. However, the algorithm requires that the second matrix be positive definite, so dense methods will be used. If you know that the second matrix is positive definite, it is recommended that you choose Method -> Arnoldi in `1`."
SparseArray`Arnoldi::arconv = Eigenvalues::arconv = Eigenvectors::arconv = Eigensystem::arconv = "Could not find any eigenvalues to sufficient accuracy."
SparseArray`SVDArnoldi::arconv = SingularValueDecomposition::arconv = SingularValueList::arconv = "Could not find any singular values to sufficient accuracy."
SparseArray`SVDArnoldi::aribs = SparseArray`Arnoldi::aribs = SingularValueDecomposition::aribs = SingularValueList::aribs = Eigenvalues::aribs = Eigenvectors::aribs = Eigensystem::aribs = "Warning: cannot compute all the required eigenvalues and/or eigenvectors because no shifts could be applied during a cycle of the implicitly restarted Arnoldi iteration. Increasing the number of basis vectors with the options Method -> {Arnoldi, BasisSize -> n}, where n is an integer no greater than the dimension of the matrix, may help."
SparseArray`SVDArnoldi::maxit = SparseArray`Arnoldi::maxit = SingularValueDecomposition::maxit = SingularValueList::maxit = Eigenvalues::maxit = Eigenvectors::maxit = Eigensystem::maxit = "Maximum number of iterations, `1`, has been reached by the Arnoldi algorithm without convergence to the specified tolerance. You can use method options with Method -> {Arnoldi, opts) to increase the basis size or the maximum number of iterations, reduce the tolerance, or choose an appropriate shift, any of which may help."
SparseArray`SVDArnoldi::maxit2 = SparseArray`Arnoldi::maxit2 = SingularValueDecomposition::maxit2 = SingularValueList::maxit2 = Eigenvalues::maxit2 = Eigenvectors::maxit2 = Eigensystem::maxit2 = "Warning: maximum number of iterations, `1`, has been reached by the Arnoldi algorithm without convergence to the specified tolerance, but the current best computed value has been returned. You can use method options with Method -> {Arnoldi, opts} to increase the size of basis vectors, the maximum number of iterations, reduce the tolerance, or use an estimate as a shift, any of which may help."
SparseArray`SVDArnoldi::arstv = SparseArray`Arnoldi::arstv = SingularValueDecomposition::arstv = SingularValueList::arstv = Eigenvalues::arstv = Eigenvectors::arstv = Eigensystem::arstv = "The starting vector must have at least one nonzero component."
SparseArray`SVDArnoldi::arbsym = SparseArray`Arnoldi::arbsym = SingularValueDecomposition::arbsym = SingularValueList::arbsym = Eigenvalues::arbsym = Eigenvectors::arbsym = Eigensystem::arbsym = "You can only choose the Arnoldi method option Criteria -> BothEnds for real symmetric matrices."
SparseArray`Arnoldi::arb2 = Eigenvalues::arb2 = Eigenvectors::arb2 = Eigensystem::arb2 = "With the Arnoldi method option Criteria -> BothEnds, you need to request two or more eigenvalues and/or eigenvectors."
SparseArray`SVDArnoldi::arb2 = SingularValueDecomposition::arb2 = SingularValueList::arb2 = "With the Arnoldi method option Criteria -> BothEnds, you need to request two or more singular values and/or singular vectors."
SparseArray`SVDArnoldi::arerr = SparseArray`Arnoldi::arerr = SingularValueDecomposition::arerr = SingularValueList::arerr = Eigenvalues::arerr = Eigenvectors::arerr = Eigensystem::arerr = "Could not continue Arnoldi algorithm because the required eigenvectors cannot be computed."
SparseArray`SVDArnoldi::arbss = SingularValueDecomposition::arbss = SingularValueList::arbss = "The value of the option BasisSize -> `1` should be an integer greater than `2`, and cannot exceed `3`."
SparseArray`Arnoldi::arbss = Eigenvalues::arbss = Eigenvectors::arbss = Eigensystem::arbss = "The value of the option BasisSize -> `1` should be an integer greater than `2`, and cannot exceed the dimension of the matrix, `3`."
SparseArray`SVDArnoldi::arbs = SingularValueDecomposition::arbs = SingularValueList::arbs = "The value of the option BasisSize -> `1` should be an integer greater than `2`, and cannot exceed `3`."
SparseArray`Arnoldi::arbs = Eigenvalues::arbs = Eigenvectors::arbs = Eigensystem::arbs = "The value of the option BasisSize -> `1` should be an integer greater than `2`, and cannot exceed the dimension of the matrix, `3`."
SparseArray`SVDArnoldi::lsgma = SingularValueDecomposition::lsgma = SingularValueList::lsgma = "The option Shift is used only for computing a few singular values close to the value of Shift. The second argument of `1` should be a positive small integer because computing other singular values may not be accurate."
SparseArray`Arnoldi::lsgma = Eigenvalues::lsgma = Eigenvectors::lsgma = Eigensystem::lsgma = "The option Shift is used only for computing a few eigenvalues close to the value of Shift; the second argument of `1` should be a positive small integer because computing other eigenvalues may not be accurate."
SparseArray`Arnoldi::bsing = Eigenvalues::bsing = Eigenvectors::bsing = Eigensystem::bsing = "The right-hand side matrix of the generalized eigenvalue problem is singular."
SparseArray`SVDArnoldi::bsing = SingularValueDecomposition::bsing = SingularValueList::bsing = "The right-hand side matrix of the generalized singular value problem is singular."
SparseArray`Arnoldi::eslct = Eigenvalues::eslct = Eigenvectors::eslct = Eigensystem::eslct = "A value of the option Criteria must be one of \"Magnitude\", \"RealPart\", \"ImaginaryPart\", or \"BothEnds\", with \"BothEnds\" appropriate for real symmetric eigenvalue problems only."
SparseArray`SVDArnoldi::eslct = SingularValueDecomposition::eslct = SingularValueList::eslct = "A value of the option Criteria must be one of \"Magnitude\", \"RealPart\", or \"BothEnds\"."
SparseArray`SVDArnoldi::mcsgma = SparseArray`Arnoldi::mcsgma = SingularValueDecomposition::mcsgma = SingularValueList::mcsgma = Eigenvalues::mcsgma = Eigenvectors::mcsgma = Eigensystem::mcsgma = "Value of option Shift -> `1` must be a number."
SparseArray`Arnoldi::svecnm = Eigenvalues::svecnm = Eigenvectors::svecnm = Eigensystem::svecnm = "A value of the option StartingVector -> `1` must be a vector of machine numbers, of the same length as the row dimension of the matrix."
SparseArray`SVDArnoldi::svecnm = SingularValueDecomposition::svecnm = SingularValueList::svecnm = "A value of the option StartingVector -> `1` must be a vector of numbers, of the length equal to the sum of the row and column dimensions of the matrix."
SparseArray`Arnoldi::ssing = Eigenvalues::ssing = Eigenvectors::ssing = Eigensystem::ssing = "Failed to factor the matrix involving the shift. This may be caused by the shift, `1`, corresponding exactly to an eigenvalue. Changing the shift value slightly might help."
SparseArray`SVDArnoldi::ssing = SingularValueDecomposition::ssing = SingularValueList::ssing = "Failed to factor the matrix involving the shift. This may be caused by the shift, `1`, corresponding exactly to a singular value. Changing the shift value slightly might help."
SparseArray`KrylovLinearSolve::kryzrow = LinearSolve::kryzrow = SparseArray`SparseMatrixILU::kryzrow = "Each row of the sparse matrix `1` must contain at least one nonzero element."
SparseArray`KrylovLinearSolve::kryinz = LinearSolve::kryinz = SparseArray`SparseMatrixILU::kryinz = "The sparse matrix `1` must have an implicit value equal to zero."
SparseArray`KrylovLinearSolve::krypat = LinearSolve::krypat = SparseArray`SparseMatrixILU::krypat = "The sparse matrix `1` cannot contain a pattern."
SparseArray`KrylovLinearSolve::krylfil = LinearSolve::krylfil = SparseArray`SparseMatrixILU::krylfil = "The value of the option FillIn must be a non-negative integer."
SparseArray`KrylovLinearSolve::krynfl0 = LinearSolve::krynfl0 = SparseArray`SparseMatrixILU::krynfl0 = "The option FillIn is not a valid option for the preconditioner ILU0."
SparseArray`KrylovLinearSolve::krynpmt = LinearSolve::krynpmt = SparseArray`SparseMatrixILU::krynpmt = "The option PermutationTolerance is not a valid option for the preconditioner ILU0 or ILUT."
SparseArray`KrylovLinearSolve::kryptol = LinearSolve::kryptol = SparseArray`SparseMatrixILU::kryptol = "Value of option PermutationTolerance -> `1` is not a non-negative real number or Automatic."
SparseArray`KrylovLinearSolve::kryzspd = LinearSolve::kryzspd = SparseArray`SparseMatrixILU::kryzspd = SparseArray`SparseMatrixApplyILU::kryzspd = "The sparse matrix `1` has zero element(s) on the main diagonal."
SparseArray`KrylovLinearSolve::kryzspd2 = LinearSolve::kryzspd2 = SparseArray`SparseMatrixILU::kryzspd2 = SparseArray`SparseMatrixApplyILU::kryzspd2 = "Warning: the sparse matrix `1` has zero element(s) on the main diagonal. The zero diagonal elements are replaced with a small number."
SparseArray`KrylovLinearSolve::kryprtl = LinearSolve::kryprtl = SparseArray`SparseMatrixILU::kryprtl = "Initial preconditioned residual is `1` times larger than unpreconditioned residual. The GMRES method will not converge."
SparseArray`SparseMatrixILU::krynilu = "`1` is not a valid ILU method."
SparseArray`SparseArraySort::bdmtd = "Value of option Method -> `1` is not \"MergeSort\", \"PermutationSort\", \"TransposeSort\" or Automatic."
Eigensystem::geidm = Eigenvectors::geidm = Eigenvalues::geidm = "Incompatible matrix dimensions."
Eigensystem::geinsl = Eigenvectors::geinsl = Eigenvalues::geinsl = "Cannot find a solution for the generalized eigenproblem."
Eigensystem::geinsl1 = Eigenvectors::geinsl1 = Eigenvalues::geinsl1 = "Warning: a solution for the generalized eigenproblem may be incorrect."
Eigensystem::geinzv = Eigenvectors::geinzv = Eigenvalues::geinzv = "Warning: cannot find all the generalized eigenvectors."
LinearAlgebra`Private`Orthogonalize::orbop = Orthogonalize::orbop = "`1` is not a valid value for the Method option."
LinearAlgebra`Private`Orthogonalize::ornex = Orthogonalize::ornex = "The option Method -> Reorthogonalization cannot be used with exact precision vectors. It is replaced with Method -> GramSchmidt."
LinearAlgebra`Private`Orthogonalize::ornh = Orthogonalize::ornh = "The option Method -> Householder cannot be used with symbolic or exact precision vectors."
LinearAlgebra`Private`Orthogonalize::ornhip = Orthogonalize::ornhip = "The option Method -> Householder can only be used with the default (Automatic) inner product."
LinearAlgebra`Private`Orthogonalize::ornfa = Orthogonalize::ornfa = "The second argument `1` is not an inner product function, which always should return a number or symbol. If its two numeric arguments are the same, it should return a non-negative real number."
LinearAlgebra`Private`Orthogonalize::orwdt = Orthogonalize::orwdt = "At least one element of the first argument cannot be used with the Dot inner product."
LinearAlgebra`Private`Orthogonalize::ornvm = Orthogonalize::ornvm = "The first argument is not a vector or matrix."
LinearAlgebra`Private`Orthogonalize::ornt = Orthogonalize::ornt = "The first argument `1` is incorrect. It should be a vector, matrix, or tensor."
LinearAlgebra`Private`Orthogonalize::orsym = Orthogonalize::orsym = "The option Method -> `1` is replaced by Method -> GramSchmidt."
LinearAlgebra`Private`Orthogonalize::ornhsl = Orthogonalize::ornhsl = "The Householder method called by the option Method -> Householder cannot orthogonalize this set of vectors. Try another orthogonalization method."
Normalize::nlnfa = "The second argument `1` is not a norm function that always returns a non-negative real number for any numeric argument."
Normalize::nlnmat = "The first argument must be a number or a vector."
Normalize::nlnmt2 = "The first argument is not a number or a vector, or the second argument is not a norm function that always returns a non-negative real number for any numeric argument."
Projection::prnv = "The first or second argument or both are not vectors, or they are not vectors of equal length."
Projection::prnve = "The first and/or second argument is not an expression or a vector."
Projection::prne = "The first and/or second argument is not an expression."
Projection::prnip = "The inner product seems to be incorrect for the given two expressions/vectors. It cannot provide a reasonable result."
TransformationFunction::comp = "`1` and `2` in Composition have incompatible dimensions."
TransformationFunction::fdim = "`1` is not a vector of length `2` or a list of length `2` vectors."
TransformationFunction::inverse = "`1` is not invertible."
TransformationMatrix::inpf = "`1` is not a valid TransformationFunction object."
TransformationMatrix::nonlinfrac = "`1` is not a linear-fractional TransformationFunction object."
GeometricTransformation::nonaffine = "`1` is not an affine transformation function."
General::inps = "`1` is not a scalar."
General::inpv = "`1` is not a vector."
General::idim = "`1` and `2` must have the same length."
General::idim3 = "`1` , `2`, and `3` must have the same length."
General::idir = "Direction vector `1` has zero magnitude."
AffineTransform::idimr = LinearFractionalTransform::idimr = "The number of rows in `1` is not equal to the length of `2`."
AffineTransform::inpf = "`1` is not a matrix or a list containing a matrix and a vector."
General::idimc = "The number of columns in `1` is not equal to the length of `2`."
LinearFractionalTransform::inpf = "`1` is not a matrix or a list containing a matrix, two vectors, and a scalar."
RotationMatrix::v3d = RotationTransform::v3d = "`1` is not a vector of length 3."
RotationMatrix::spln = RotationTransform::spln = "Vectors `1` and `2` do not define a plane."
RotationMatrix::rdim = RotationTransform::rdim = "Vector `1` must have a length greater than 1."
RotationMatrix::sdir = RotationTransform::sdir = "Vectors `1` and `2` do not define a rotation direction."
RotationMatrix::inpf = RotationTransform::inpf = "`1` is not a scalar or a list of two vectors."
RotationMatrix::inpf2 = RotationTransform::inpf2 = "`1` is not a vector or a list of two vectors."
ShearingMatrix::proj = ShearingTransform::proj = "The projection of `1` onto the plane defined by `2` has zero magnitude."
RotationTransform::inpf12 = "For the given first argument `1`, the second argument `2` must be a vector."
ScalingTransform::inpf = StateSpaceModel::inpf = "`1` is not a scalar or a vector."
RescalingTransform::imap = "Range `1` has an infinite bound."
RescalingTransform::smap = "Cannot map zero range `1` to `2`."
RescalingTransform::sfac = "Zero ranges `1` and `2` do not define a scaling factor."
RescalingTransform::idiml = "The lists `1` and `2` must have the same length."
RescalingTransform::inpf = "`1` is not a list of length 2 vectors."
LeastSquares::lsnomtd = "A wrong value of the option Method. The acceptable methods are Automatic, Direct, Krylov, and NormalizedColumns."
LeastSquares::lsspmtd = "The option Method with value \"Krylov\" can be used only with a first argument that is a sparse matrix."
LeastSquares::lsnspmtd = "The option Method with value \"IterativeRefinement\" can be used only with a first argument that is a dense matrix."
LeastSquares::lszimp = "The option Method -> NormalizedColumns cannot be used with a sparse matrix having nonzero implicit value `1`."
LeastSquares::lsncex = "The option Method -> NormalizedColumns has no effect because exact array columns will not be normalized."
LeastSquares::lslmw = "For the option Method -> IterativeRefinement an auxiliary matrix is built that requires at least `1` Megabytes of memory."
Element::bset = "The second argument `1` of Element should be one of: Primes, Integers, Rationals, Algebraics, Reals, Complexes, or Booleans."
EllipticLog::elld = "The arguments to `1` are inconsistent with the defining equation y^2 == x^3 + a x^2 + b x."
EllipticLog::ellnp = EllipticExp::ellnp = "The argument `1` is not an ordered pair; a list of length 2 is expected."
EllipticReducedHalfPeriods::nind = "Half-periods `1` are not independent."
EllipticTheta::etype = EllipticThetaPrime::etype = "The first argument `1` is expected to be 1, 2, 3, or 4."
EmbeddedHTML::invarg = "The first argument of EmbeddedHTML should be a string, a CloudObject, or a URL."
End::noctx = EndAdd::noctx = EndPackage::noctx = "No previous context defined."
Except::named = "Named pattern variables are not allowed in the first argument of `1`."
Except::lenmod = "A variable-length pattern is not allowed as the second argument in `1`."
ExitDialog::cant = "No dialog to exit from."
Rasterize::nofe = "A front end is not available; Rasterize requires a front end."
Rasterize::pxarr = "The pixel array dimension `1` is not a positive integer or a list of two positive integers."
Rasterize::noelem = "The element `1` is not a valid element for Rasterize."
Rasterize::type = "`1` cannot be rasterized."
ExtendedGCD::egcd = "Arguments in `1` should be integers."
ExtendedGCD::egcdz = "ExtendedGCD[0,0] has no unique solution."
LinearSolve::notrhsm = "Incorrect value of the second argument. Only the strings \"N\", \"T\", \"C\", or \"J\" are valid."
LinearSolve::rmeth = "Value of option Method -> `1` should be \"Cholesky\", \"Multifrontal\", \"Krylov\", \"CofactorExpansion\", \"OneStepRowReduction\", \"DivisionFreeRowReduction\", \"Direct\", \"IterativeRefinement\", \"Banded\", or Automatic."
LinearSolve::mronly = "Only machine-real code is available for sparse matrices. If your matrix is not too large, consider trying again after using Normal on the matrix."
LinearSolve::exanexb = "The factorized exact matrix may generate an incorrect result for an inexact right-hand side. Either use the two-argument form of LinearSolve, or use an approximate matrix in the one-argument form."
Eigenvalues::bdnziv = Eigenvectors::bdnziv = Eigensystem::bdnziv = LinearSolve::bdnziv = "The method \"Banded\" does not accept a sparse matrix with a nonzero implicit value."
Eigenvalues::bdnmt = Eigenvectors::bdnmt = Eigensystem::bdnmt = LinearSolve::bdnmt = "The method \"Banded\" accepts only sparse matrices with elements that are machine-real or machine-complex numbers."
LinearSolveFunction::mconly = LinearSolve::mconly = "Only machine number code is available for sparse matrices. If your matrix is not too large, consider trying again after using Normal on the matrix."
LinearSolveFunction::spfac = "The sparse LU factors are not available separately."
General::mcovl = "The computation encountered machine-number overflow. Only machine-number code is available for sparse matrices. If your matrix is not too large, consider trying again after using Normal on the matrix."
LinearSolve::nolib = "The library for the sparse method chosen is not available on this platform. Try choosing another method."
LinearSolve::lupat = "Cannot compute solutions for Pattern type sparse matrices."
LinearSolve::sqmat = "The matrix `1` is not square. A square matrix is needed to compute a factorization."
LinearSolve::woflow = "Warning: machine overflow encountered during computations. Computations are continued with the equivalent arbitrary precision."
General::npdef = "The matrix `1` is not positive definite."
General::npsdef = "The matrix `1` is not positive semi-definite."
General::nsym = "The matrix `1` is not symmetric."
LinearSolve::tmm = "Pre-factorization analysis indicates that the solution will require too much memory."
LinearSolve::sing1 = "The matrix `1` is singular so a factorization will not be saved."
LinearSolve::sqmat1 = "The matrix `1` is not square so a factorization will not be saved."
LinearSolve::psol = "The solution may contain significant numerical errors because the residual is too large."
SparseArray`KrylovLinearSolve::krynfa = LinearSolve::krynfa = "The first argument `1` is not a square matrix or a function generating a vector of length equal to the length of the second argument."
SparseArray`KrylovLinearSolve::krycomp = LinearSolve::krycomp = "There are expressions generated by the Krylov method that are too complex to be compared."
SparseArray`KrylovLinearSolve::kryme = LinearSolve::kryme = "`1` is not a supported Krylov method."
SparseArray`KrylovLinearSolve::kryit = LinearSolve::kryit = "Value of option MaxIterations -> `1` should be a positive integer or Automatic."
SparseArray`KrylovLinearSolve::krypre = LinearSolve::krypre = "Value of option Preconditioner -> `1` is not ILU0, ILUT, ILUTP, or a user-defined function."
SparseArray`KrylovLinearSolve::krynor = LinearSolve::krynor = "Value of option ResidualNormFunction -> `1` is not a valid function."
SparseArray`KrylovLinearSolve::krynorv = LinearSolve::krynorv = "The result of applying the user-specified norm function `1` is not a valid number."
SparseArray`KrylovLinearSolve::krydia = LinearSolve::krydia = "ILU preconditioner is specified, but since there are missing diagonal entries in the input matrix, no preconditioner will be used."
SparseArray`KrylovLinearSolve::krymit = LinearSolve::krymit = "The maximum number of iterations, `1`, has been reached by the Krylov algorithm without convergence to a solution within the required tolerance. The currently computed solution has been returned."
SparseArray`KrylovLinearSolve::krypr = LinearSolve::krypr = "The result of applying the user-specified preconditioner `1` is not a list with length equal to the row dimension of the matrix."
SparseArray`KrylovLinearSolve::kryma = LinearSolve::kryma = "The result of applying the user-specified matrix `1` is not a list with length equal to the row dimension of the matrix."
SparseArray`KrylovLinearSolve::krynom = LinearSolve::krynom = "Non-numerical quantities were encountered during Krylov iteration. This could be because these linear equations have no solution."
SparseArray`KrylovLinearSolve::krynum = LinearSolve::krynum = "Input to Krylov algorithm contains elements that are not explicit numbers."
SparseArray`KrylovLinearSolve::kryivec = LinearSolve::kryivec = "An initial vector should be a vector of numbers."
SparseArray`KrylovLinearSolve::kryinfp = LinearSolve::kryinfp = "Input to Krylov algorithm is of infinite precision. Iterations may become very slow due to expression size growth."
SparseArray`KrylovLinearSolve::krynpd = LinearSolve::krynpd = "The input matrix is not positive definite. The conjugate gradient method cannot continue computations."
SparseArray`KrylovLinearSolve::krybsv = LinearSolve::krybsv = "The value of the option BasisSize must be a positive integer."
SparseArray`KrylovLinearSolve::krystg = LinearSolve::krystg = "The iterative method stagnates and cannot find a better solution."
SparseArray`KrylovLinearSolve::krybrk = LinearSolve::krybrk = "The iterative method breaks down and cannot continue computations. You can restart the method with another initial vector or change the method."
SparseArray`KrylovLinearSolve::kryexn = LinearSolve::kryexn = "This Krylov method does not work with exact numbers."
SparseArray`KrylovLinearSolve::krytol = LinearSolve::krytol = "Cannot compute a solution with the required tolerance. The current solution has been returned."
SparseArray`KrylovLinearSolve::kryinter = LinearSolve::kryinter = "Internal error."
SparseArray`KrylovLinearSolve::kryintwr = LinearSolve::kryintwr = "Internal warning."
SparseArray`KrylovLinearSolve::kryprsd = LinearSolve::kryprsd = "PreconditionerSide option value is not Left or Right."
SparseArray`KrylovLinearSolve::krynrpr = LinearSolve::krynrpr = "The option PreconditionerSide cannot be used with the method `1`."
SparseArray`KrylovLinearSolve::krymbs = LinearSolve::krymbs = "The suboption BasisSize cannot be used with the method `1`."
SparseArray`KrylovLinearSolve::krymbs1 = LinearSolve::krymbs1 = "Wrong suboption for the method `1`."
SparseArray`KrylovLinearSolve::krypo = LinearSolve::krypo = "Suboptions cannot be used with the preconditioner method `1`."
SparseArray`KrylovLinearSolve::krypo1 = LinearSolve::krypo1 = "Wrong suboption(s) for the preconditioner method `1`."
SparseArray`KrylovLinearSolve::krymre = LinearSolve::krymre = "This Krylov method works only with real machine numbers."
SparseArray`KrylovLinearSolve::krymilu = LinearSolve::krymilu = "An incorrect ILU option for this Krylov method."
SparseArray`KrylovLinearSolve::kryiluie = LinearSolve::kryiluie = "ILU internal error."
SparseArray`KrylovLinearSolve::krynimp = LinearSolve::krynimp = "This method is not implemented."
SparseArray`KrylovLinearSolve::kryiluiw = LinearSolve::kryiluiw = "An ILU option internal warning."
SparseArray`KrylovLinearSolve::kryilucg = LinearSolve::kryilucg = "This ILU option may not work correctly with the ConjugateGradient method."
SparseArray`KrylovLinearSolve::krynoilu = LinearSolve::krynoilu = "Warning: No ILU method is used."
General::lsnmod = "The option Modulus may be specified only for integer or rational matrices."
LinearSolve::lsnzt = "The option ZeroTest may be specified only for integer or rational matrices."
LinearAlgebra`LinearSolve`IterativeRefinement::maxit = "Maximum number of iterations `1` reached without convergence."
LinearAlgebra`LinearSolve`IterativeRefinement::slwconv = "Slow convergence (less than `1` digits per iteration)."
LinearAlgebra`LinearSolve`IterativeRefinement::infprec = "Computations cannot be carried out in infinite precision."
LinearAlgebra`LinearSolve`IterativeRefinement::lcondn = "The matrix condition number `1` is too large for starting precision `2`. The method may not converge."
General::wrgopt = "The value `1` of the option `2` is incorrect."
LinearAlgebra`LinearSolve`IterativeRefinement::wrgopt1 = "Incorrect IterativeRefinement method option(s)."
LinearAlgebra`Private`MatrixConditionNumber::nrmp = "The value `1` of the option Norm is incorrect. It should be 1 or Infinity."
Developer`SparseLinearSolve::lsvs = "Argument `1` is neither a non-empty vector of machine-sized numbers nor a list of same-length vectors of machine-sized numbers."
BooleanFunction::bspec = BooleanCountingFunction::bspec = BooleanConsecutiveFunction::bspec = BooleanMaxterms::bspec = BooleanMinterms::bspec = "`1` is not a valid `2` specification."
BooleanFunction::bcerr = "Boolean computations failed due to limitations of the current implementation."
BooleanFunction::bfrep = "Unable to represent a Boolean function with `1` arguments."
BooleanConvert::bform = BooleanMinimize::bform = "`1` is not a valid Boolean expression form specification."
BooleanMinimize::bmni = "Minimization of `1` form of Boolean expressions is not implemented."
BooleanConvert::bfun = BooleanMinimize::bfun = BooleanVariables::bfun = SatisfiabilityCount::bfun = SatisfiabilityInstances::bfun = SatisfiableQ::bfun = TautologyQ::bfun = UnateQ::bfun = "`1` is not a Boolean-valued pure function."
BooleanConvert::fargn = BooleanMinimize::fargn = SatisfiabilityCount::fargn = SatisfiabilityInstances::fargn = SatisfiableQ::fargn = TautologyQ::fargn = UnateQ::fargn = "The number of arguments `1` of the pure function `2` is not a positive machine-sized integer."
BooleanConvert::fcinc = BooleanMinimize::fcinc = "`1` and `2` should be Function objects with identical variable lists."
BooleanMinimize::maxit = "Warning: maximum number of iterations, `1`, has been reached by the Boolean minimization algorithm. The result returned may not be minimal."
BooleanTable::bvar = Conjunction::bvar = Disjunction::bvar = SatisfiabilityInstances::bvar = SatisfiabilityCount::bvar = SatisfiableQ::bvar = TautologyQ::bvar = UnateQ::bvar = "`1` is not a valid Boolean variable."
BooleanTable::vindx = "Variable index `1` is not a positive integer."
BooleanTable::vundf = "The variable index `1` is not included in the BooleanTable specification."
SatisfiabilityInstances::boolv = SatisfiableQ::boolv = TautologyQ::boolv = "`1` is not Boolean valued at `2`."
SatisfiabilityInstances::nmint = "The number `1` of instances is not a machine-sized integer."
UnateQ::indl = "`1` should be a list of indicator values True (or 1), False (or 0), or _, corresponding to the Boolean variables of `2`."
Internal`StraightLineProgram::slot = "`1` (in `2`) should contain an integer between 1 and `3`."
Internal`ToStraightLineProgram::incdim = "StraightLineProgram objects of unequal output length in `1` cannot be combined."
DiscreteMath`DecisionDiagram`BDDExpand::bexpr = DiscreteMath`DecisionDiagram`ToXorForm::bexpr = DiscreteMath`DecisionDiagram`PrimeImplicants::bexpr = DiscreteMath`DecisionDiagram`CyclicCore::bexpr = DiscreteMath`DecisionDiagram`BDDMinimize::bexpr = DiscreteMath`DecisionDiagram`ToBDD::bexpr= "`1` should be a Boolean expression or a list of two Boolean expressions."
GraphUtilities`GraphCoordinateRules1D::tsf = GraphUtilities`GraphCoordinateRules::tsf = GraphUtilities`GraphCoordinateRules3D::tsf = GraphUtilities`GraphCoordinates::tsf = GraphUtilities`GraphCoordinates3D::tsf = GraphUtilities`GraphCoordinates1D::tsf = TreePlot::tsf = GraphPlot::tsf = SparseArray`GraphPlacement::tsf = GraphPlot3D::tsf = SparseArray`GraphPlacement3D::tsf = "The value of option \"LayerSizeFunction\" -> `1` does not evaluate to a machine-sized real number at `2`."
GraphUtilities`GraphCoordinateRules1D::grph = GraphUtilities`GraphCoordinateRules::grph = GraphUtilities`GraphCoordinateRules3D::grph = GraphUtilities`GraphCoordinates::grph = GraphUtilities`GraphCoordinates3D::grph = GraphUtilities`GraphCoordinates1D::grph = TreePlot::grph = LayeredGraphPlot::grph = GraphPlot::grph = SparseArray`GraphPlacement::grph = GraphPlot3D::grph = SparseArray`GraphPlacement3D::grph = "`1` is not a valid graph."
GraphUtilities`GraphCoordinateRules1D::sqma = GraphUtilities`GraphCoordinateRules::sqma = GraphUtilities`GraphCoordinateRules3D::sqma = GraphUtilities`GraphCoordinates::sqma = GraphUtilities`GraphCoordinates3D::sqma = GraphUtilities`GraphCoordinates1D::sqma = TreePlot::sqma = LayeredGraphPlot::sqma = GraphPlot::sqma = SparseArray`GraphPlacement::sqma = GraphPlot3D::sqma = SparseArray`GraphPlacement3D::sqma = "First argument `1` is not a square matrix."
GraphUtilities`GraphCoordinateRules1D::coord = GraphUtilities`GraphCoordinateRules::coord = GraphUtilities`GraphCoordinateRules3D::coord = GraphUtilities`GraphCoordinates::coord = GraphUtilities`GraphCoordinates3D::coord = GraphUtilities`GraphCoordinates1D::coord = TreePlot::coord = LayeredGraphPlot::coord = GraphPlot::coord = SparseArray`GraphPlacement::coord = GraphPlot3D::coord = SparseArray`GraphPlacement3D::coord = "The second argument of `1` must be a matrix of real machine numbers with the same row dimension as the first argument and a column dimension of 2 or 3."
GraphUtilities`GraphCoordinateRules1D::coord3 = GraphUtilities`GraphCoordinateRules::coord3 = GraphUtilities`GraphCoordinateRules3D::coord3 = GraphUtilities`GraphCoordinates::coord3 = GraphUtilities`GraphCoordinates3D::coord3 = GraphUtilities`GraphCoordinates1D::coord3 = TreePlot::coord3 = LayeredGraphPlot::coord3 = GraphPlot::coord3 = SparseArray`GraphPlacement::coord3 = GraphPlot3D::coord3 = SparseArray`GraphPlacement3D::coord3 = "Warning: the second argument of `1` has a column dimension of 3. It will be treated as 3D instead."
GraphUtilities`GraphCoordinateRules1D::coord2 = GraphUtilities`GraphCoordinateRules::coord2 = GraphUtilities`GraphCoordinateRules3D::coord2 = GraphUtilities`GraphCoordinates::coord2 = GraphUtilities`GraphCoordinates3D::coord2 = GraphUtilities`GraphCoordinates1D::coord2 = TreePlot::coord2 = LayeredGraphPlot::coord2 = GraphPlot::coord2 = SparseArray`GraphPlacement::coord2 = GraphPlot3D::coord2 = SparseArray`GraphPlacement3D::coord2 = "Warning: the second argument of `1` has a column dimension of 2. It will be treated as 3D instead."
GraphUtilities`GraphCoordinateRules1D::vcoord = GraphUtilities`GraphCoordinateRules::vcoord = GraphUtilities`GraphCoordinateRules3D::vcoord = GraphUtilities`GraphCoordinates::vcoord = GraphUtilities`GraphCoordinates3D::vcoord = GraphUtilities`GraphCoordinates1D::vcoord = TreePlot::vcoord = LayeredGraphPlot::vcoord = GraphPlot::vcoord = SparseArray`GraphPlacement::vcoord = GraphPlot3D::vcoord = SparseArray`GraphPlacement3D::vcoord = "Value of option VertexCoordinateRules -> `1` must be either a list of rules or a matrix of real machine numbers with a row dimension of `2` and a column dimension of `3`."
GraphUtilities`GraphCoordinateRules1D::mlv = GraphUtilities`GraphCoordinateRules::mlv = GraphUtilities`GraphCoordinateRules3D::mlv = GraphUtilities`GraphCoordinates::mlv = GraphUtilities`GraphCoordinates3D::mlv = GraphUtilities`GraphCoordinates1D::mlv = LayeredGraphPlot::mlv = GraphPlot::mlv = SparseArray`GraphPlacement::mlv = GraphPlot3D::mlv = SparseArray`GraphPlacement3D::mlv = "The value of option RecursionMethod -> `1` should be \"Multilevel\", Automatic, or None."
GraphUtilities`GraphCoordinateRules1D::mlvcrs = GraphUtilities`GraphCoordinateRules::mlvcrs = GraphUtilities`GraphCoordinateRules3D::mlvcrs = GraphUtilities`GraphCoordinates::mlvcrs = GraphUtilities`GraphCoordinates3D::mlvcrs = GraphUtilities`GraphCoordinates1D::mlvcrs = LayeredGraphPlot::mlvcrs = GraphPlot::mlvcrs = SparseArray`GraphPlacement::mlvcrs = GraphPlot3D::mlvcrs = SparseArray`GraphPlacement3D::mlvcrs = "The value of option CoarseningScheme -> `1` should be \"MaximalIndependentVertexSet\", \"MaximalIndependentVertexSetInjection\", \"MaximalIndependentVertexSetRugeStuben\", \"MaximalIndependentVertexSetRugeStubenInjection\", \"MaximalIndependentEdgeSet\", \"MaximalIndependentEdgeSetHeavyEdge\", \"MaximalIndependentEdgeSetSmallestVertexWeight\", or \"Hybrid\"."
GraphUtilities`GraphCoordinateRules1D::mlvran = GraphUtilities`GraphCoordinateRules::mlvran = GraphUtilities`GraphCoordinateRules3D::mlvran = GraphUtilities`GraphCoordinates::mlvran = GraphUtilities`GraphCoordinates3D::mlvran = GraphUtilities`GraphCoordinates1D::mlvran = LayeredGraphPlot::mlvran = GraphPlot::mlvran = SparseArray`GraphPlacement::mlvran = GraphPlot3D::mlvran = SparseArray`GraphPlacement3D::mlvran = "The value of option Randomize -> `1` should be Automatic, True, or False."
GraphUtilities`GraphCoordinateRules1D::mlvmsz = GraphUtilities`GraphCoordinateRules::mlvmsz = GraphUtilities`GraphCoordinateRules3D::mlvmsz = GraphUtilities`GraphCoordinates::mlvmsz = GraphUtilities`GraphCoordinates3D::mlvmsz = GraphUtilities`GraphCoordinates1D::mlvmsz = LayeredGraphPlot::mlvmsz = GraphPlot::mlvmsz = SparseArray`GraphPlacement::mlvmsz = GraphPlot3D::mlvmsz = SparseArray`GraphPlacement3D::mlvmsz = "The value of option MinSize -> `1` should be Automatic or a positive machine integer."
GraphUtilities`GraphCoordinateRules1D::step = GraphUtilities`GraphCoordinateRules::step = GraphUtilities`GraphCoordinateRules3D::step = GraphUtilities`GraphCoordinates::step = GraphUtilities`GraphCoordinates3D::step = GraphUtilities`GraphCoordinates1D::step = LayeredGraphPlot::step = GraphPlot::step = SparseArray`GraphPlacement::step = GraphPlot3D::step = SparseArray`GraphPlacement3D::step = "The value of option StepLength -> `1` should be Automatic or a positive machine real."
GraphUtilities`GraphCoordinateRules1D::miter = GraphUtilities`GraphCoordinateRules::miter = GraphUtilities`GraphCoordinateRules3D::miter = GraphUtilities`GraphCoordinates::miter = GraphUtilities`GraphCoordinates3D::miter = GraphUtilities`GraphCoordinates1D::miter = LayeredGraphPlot::miter = GraphPlot::miter = SparseArray`GraphPlacement::miter = GraphPlot3D::miter = SparseArray`GraphPlacement3D::miter = "The value of option MaxIterations -> `1` should be Automatic or a positive machine integer."
GraphUtilities`GraphCoordinateRules1D::stepc = GraphUtilities`GraphCoordinateRules::stepc = GraphUtilities`GraphCoordinateRules3D::stepc = GraphUtilities`GraphCoordinates::stepc = GraphUtilities`GraphCoordinates3D::stepc = GraphUtilities`GraphCoordinates1D::stepc = LayeredGraphPlot::stepc = GraphPlot::stepc = SparseArray`GraphPlacement::stepc = GraphPlot3D::stepc = SparseArray`GraphPlacement3D::stepc = "The value of option StepControl -> `1` should be Automatic, \"NonMonotonic\", \"Monotonic\", or \"StrictlyMonotonic\"."
GraphUtilities`GraphCoordinateRules1D::engctl = GraphUtilities`GraphCoordinateRules::engctl = GraphUtilities`GraphCoordinateRules3D::engctl = GraphUtilities`GraphCoordinates::engctl = GraphUtilities`GraphCoordinates3D::engctl = GraphUtilities`GraphCoordinates1D::engctl = LayeredGraphPlot::engctl = GraphPlot::engctl = SparseArray`GraphPlacement::engctl = GraphPlot3D::engctl = SparseArray`GraphPlacement3D::engctl = "The value of option EnergyControl -> `1` should be Automatic, \"NonMonotonic\", or \"Monotonic\"."
GraphUtilities`GraphCoordinateRules1D::infd = GraphUtilities`GraphCoordinateRules::infd = GraphUtilities`GraphCoordinateRules3D::infd = GraphUtilities`GraphCoordinates::infd = GraphUtilities`GraphCoordinates3D::infd = GraphUtilities`GraphCoordinates1D::infd = LayeredGraphPlot::infd = GraphPlot::infd = SparseArray`GraphPlacement::infd = GraphPlot3D::infd = SparseArray`GraphPlacement3D::infd = "The value of option InferentialDistance -> `1` should be Automatic or a positive machine number."
GraphUtilities`GraphCoordinateRules1D::octr = GraphUtilities`GraphCoordinateRules::octr = GraphUtilities`GraphCoordinateRules3D::octr = GraphUtilities`GraphCoordinates::octr = GraphUtilities`GraphCoordinates3D::octr = GraphUtilities`GraphCoordinates1D::octr = LayeredGraphPlot::octr = GraphPlot::octr = SparseArray`GraphPlacement::octr = GraphPlot3D::octr = SparseArray`GraphPlacement3D::octr = "The value of option Octree -> `1` should be Automatic, True, or False."
GraphUtilities`GraphCoordinateRules1D::rfp = GraphUtilities`GraphCoordinateRules::rfp = GraphUtilities`GraphCoordinateRules3D::rfp = GraphUtilities`GraphCoordinates::rfp = GraphUtilities`GraphCoordinates3D::rfp = GraphUtilities`GraphCoordinates1D::rfp = LayeredGraphPlot::rfp = GraphPlot::rfp = SparseArray`GraphPlacement::rfp = GraphPlot3D::rfp = SparseArray`GraphPlacement3D::rfp = "The value of option RepulsiveForcePower -> `1` should be a negative machine number."
GraphUtilities`GraphCoordinateRules1D::refm = GraphUtilities`GraphCoordinateRules::refm = GraphUtilities`GraphCoordinateRules3D::refm = GraphUtilities`GraphCoordinates::refm = GraphUtilities`GraphCoordinates3D::refm = GraphUtilities`GraphCoordinates1D::refm = LayeredGraphPlot::refm = GraphPlot::refm = SparseArray`GraphPlacement::refm = GraphPlot3D::refm = SparseArray`GraphPlacement3D::refm = "The value of option RefinementMethod -> `1` should be None, \"SpringElectricalEmbedding\", or \"SpringEmbedding\"."
GraphUtilities`GraphCoordinateRules1D::mthd = GraphUtilities`GraphCoordinateRules::mthd = GraphUtilities`GraphCoordinateRules3D::mthd = GraphUtilities`GraphCoordinates::mthd = GraphUtilities`GraphCoordinates3D::mthd = GraphUtilities`GraphCoordinates1D::mthd = LayeredGraphPlot::mthd = GraphPlot::mthd = SparseArray`GraphPlacement::mthd = GraphPlot3D::mthd = SparseArray`GraphPlacement3D::mthd = "The value of option Method -> `1` should be Automatic, \"SpringElectricalEmbedding\", \"SpringEmbedding\", \"LayeredDrawing\", \"LayeredDigraphDrawing\", \"RadialDrawing\", \"HighDimensionalEmbedding\", \"CircularEmbedding\", \"SpiralEmbedding\", \"LinearEmbedding\", or \"RandomEmbedding\"."
GraphUtilities`GraphCoordinateRules1D::eig = GraphUtilities`GraphCoordinateRules::eig = GraphUtilities`GraphCoordinateRules3D::eig = GraphUtilities`GraphCoordinates::eig = GraphUtilities`GraphCoordinates3D::eig = GraphUtilities`GraphCoordinates1D::eig = LayeredGraphPlot::eig = GraphPlot::eig = SparseArray`GraphPlacement::eig = GraphPlot3D::eig = SparseArray`GraphPlacement3D::eig = "HighDimensionalEmbedding method failed because eigenvectors of the covariant matrix cannot be calculated."
General::rseed = "Value of option RandomSeed -> `1` is not an integer or Automatic."
General::seeding = "Value of option RandomSeeding -> `1` is not Automatic, Inherited, an integer, or a string. Using the default seeding for `2` instead."
GraphUtilities`GraphCoordinateRules1D::rooti = GraphUtilities`GraphCoordinateRules::rooti = GraphUtilities`GraphCoordinateRules3D::rooti = GraphUtilities`GraphCoordinates::rooti = GraphUtilities`GraphCoordinates3D::rooti = GraphUtilities`GraphCoordinates1D::rooti = TreePlot::rooti = LayeredGraphPlot::rooti = GraphPlot::rooti = GraphPlot3D::rooti = "Value of method option Root -> `1` is not a vertex."
GraphUtilities`GraphCoordinateRules1D::loop = GraphUtilities`GraphCoordinateRules::loop = GraphUtilities`GraphCoordinateRules3D::loop = GraphUtilities`GraphCoordinates::loop = GraphUtilities`GraphCoordinates3D::loop = GraphUtilities`GraphCoordinates1D::loop = LayeredGraphPlot::loop = GraphPlot::loop = GraphPlot3D::loop = SparseArray`GraphPlacement::loop = SparseArray`GraphPlacement3D::loop = "Value of option Loops -> `1` is not True, False, Automatic, or a positive machine number."
GraphUtilities`GraphCoordinateRules1D::medge = GraphUtilities`GraphCoordinateRules::medge = GraphUtilities`GraphCoordinateRules3D::medge = GraphUtilities`GraphCoordinates::medge = GraphUtilities`GraphCoordinates3D::medge = GraphUtilities`GraphCoordinates1D::medge = LayeredGraphPlot::medge = GraphPlot::medge = GraphPlot3D::medge = SparseArray`GraphPlacement::medge = SparseArray`GraphPlacement3D::medge = "Value of option Multiedges -> `1` is not True, False, Automatic, or a positive machine number."
GraphUtilities`GraphCoordinateRules1D::rot = GraphUtilities`GraphCoordinateRules::rot = GraphUtilities`GraphCoordinateRules3D::rot = GraphUtilities`GraphCoordinates::rot = GraphUtilities`GraphCoordinates3D::rot = GraphUtilities`GraphCoordinates1D::rot = LayeredGraphPlot::rot = GraphPlot::rot = GraphPlot3D::rot = SparseArray`GraphPlacement::rot = SparseArray`GraphPlacement3D::rot = "Value of option Rotation -> `1` is not a machine-sized real number."
GraphUtilities`GraphCoordinateRules1D::vtxsz = GraphUtilities`GraphCoordinateRules::vtxsz = GraphUtilities`GraphCoordinateRules3D::vtxsz = GraphUtilities`GraphCoordinates::vtxsz = GraphUtilities`GraphCoordinates3D::vtxsz = GraphUtilities`GraphCoordinates1D::vtxsz = LayeredGraphPlot::vtxsz = GraphPlot::vtxsz = GraphPlot3D::vtxsz = SparseArray`GraphPlacement::vtxsz = SparseArray`GraphPlacement3D::vtxsz = "Value of option VertexSizes -> `1` is not a list of positive machine numbers, or positive machine-number pairs, of the same length as the number of vertices."
GraphUtilities`GraphCoordinateRules1D::vpr = GraphUtilities`GraphCoordinateRules::vpr = GraphUtilities`GraphCoordinateRules3D::vpr = GraphUtilities`GraphCoordinates::vpr = GraphUtilities`GraphCoordinates3D::vpr = GraphUtilities`GraphCoordinates1D::vpr = LayeredGraphPlot::vpr = GraphPlot::vpr = GraphPlot3D::vpr = SparseArray`GraphPlacement::vpr = SparseArray`GraphPlacement3D::vpr = "Value of option VertexCoordinateRules -> `1` is not a valid list of coordinate rules."
TreePlot::vprmtd = GraphUtilities`GraphCoordinateRules1D::vprmtd = GraphUtilities`GraphCoordinateRules::vprmtd = GraphUtilities`GraphCoordinateRules3D::vprmtd = GraphUtilities`GraphCoordinates::vprmtd = GraphUtilities`GraphCoordinates3D::vprmtd = GraphUtilities`GraphCoordinates1D::vprmtd = LayeredGraphPlot::vprmtd = GraphPlot::vprmtd = GraphPlot3D::vprmtd = SparseArray`GraphPlacement::vprmtd = SparseArray`GraphPlacement3D::vprmtd = "Warning: the VertexCoordinateRules option with rule list value is only supported for the SpringElectricalEmbedding method. Switching to the SpringElectricalEmbedding method."
GraphPlot::pkst = GraphPlot3D::pkst = TreePlot::pkst = LayeredGraphPlot::pkst = "Value of option PackingMethod -> `1` must be Automatic, \"ClosestPacking\", \"ClosestPackingCenter\", \"Layered\", \"LayeredLeft\", \"LayeredTop\", or \"NestedGrid\"."
GraphPlot::pnum = GraphPlot3D::pnum = TreePlot::pnum = LayeredGraphPlot::pnum = "Value of option PolominoNumber -> `1` must be Automatic or a positive machine integer."
GraphPlot::ppad = GraphPlot3D::ppad = TreePlot::ppad = LayeredGraphPlot::ppad = "Value of option Padding -> `1` must be Automatic, None, or a non-negative machine real."
TreePlot::iind = "Argument `1` at position `3` is not a vertex index between 1 and `2`."
TreePlot::rind = "Argument `1` at position `2` is not a valid vertex."
TreePlot::rp = "The second argument `1` of TreePlot must be one of Top, Bottom, Left, Right, or Center."
LayeredGraphPlot::rp2 = "The second argument `1` of LayeredGraphPlot must be Top, Bottom, Left, or Right."
GraphPlot::vlbs = GraphPlot3D::vlbs = TreePlot::vlbs = LayeredGraphPlot::vlbs = "Value of option VertexLabeling -> `1` must be Automatic, True, False, or Tooltip."
GraphPlot::elbs = GraphPlot3D::elbs = TreePlot::elbs = LayeredGraphPlot::elbs = "Value of option EdgeLabeling -> `1` must be either Automatic, True, or False."
GraphPlot::des = GraphPlot3D::des = TreePlot::des = LayeredGraphPlot::des = "Value of option DirectedEdges -> `1` must be either True or False."
FaceGrids::fglst = "Value for option FaceGrids -> `1` is not None, All, or a list with 6 or fewer elements."
FaceGrids::fgstl = "`1` is not a valid grid style specification."
FaceGrids::gface = "`1` is not a valid face specification."
Factor::facim = FactorList::facim = FactorSquareFree::facim = "Factoring non-integer polynomials with respect to a modulus is not implemented."
Factor::facmm = "Factoring multivariate polynomials with respect to a modulus is not yet implemented; FactorSquareFree will be used instead."
Factor::priml = "Prime `1` is too large for this implementation."
Factor::ufac = FactorSquareFree::ufac = "Unable to perform the square-free factorization."
Factor::extnp = FactorSquareFree::extnp = FactorList::extnp = FactorSquareFreeList::extnp = "`1` over an algebraic extension requires polynomial input; using `1` with Extension -> None instead."
FactorInteger::faccp = "Unable to factor `1` completely."
FactorInteger::facnf = "Unable to factor `1`."
FactorInteger::gfacnf = "Unable to factor `1` + `2` I."
FileDate::datetype = "Date type `1` should be \"Access\", \"Modification\", \"Creation\" (Windows only), \"Change\" (Macintosh and Unix only), or \"Rules\"."
FileDate::nochangewin = "The Change date of a file is not available on Windows."
FileDate::nocreationunix = "The Creation date of a file is not available on Macintosh and Unix."
FileFormat::chtype = "`1` is not a valid file specification."
FileFormat::fmterr = "`1` is not a recognized file format."
FilePrint::fpnsup = "Element type `1` is not supported."
FilePrint::fpspec = "`1` is not a valid range specification."
FileInformation::filepropswin = Developer`FileInformation::filepropswin = "File property `1` should be \"AbsoluteFileName\", \"AccessDate\", \"Archive\", \"Attributes\", \"ByteCount\", \"CreationDate\", \"FileAssociation\", \"FileType\", \"Hidden\", \"ModificationDate\", \"Properties\", \"RawByteCount\", \"ReadOnly\", \"Rules\", or \"System\"."
FileInformation::filepropsunix = Developer`FileInformation::filepropsunix = "File property `1` should be \"AbsoluteFileName\", \"AccessDate\", \"Attributes\", \"ByteCount\", \"ChangeDate\", \"FileType\", \"ModificationDate\", \"Properties\", \"RawByteCount\", or \"Rules\"."
FinancialData::conopen = "No internet connection can be established to the data source."
FinancialData::notdate = "`1` is not a valid date range for FinancialData."
System`FindDivisions::fdargs = Developer`FindDivisions::fdargs = "The arguments in FindDivisions[`1`, `2`, `3`] are not supported."
FindFit::bdmtd = NonlinearModelFit::bdmtd ="Value of option Method -> `1` is not Automatic, \"Gradient\", \"ConjugateGradient\", \"InteriorPoint\", \"QuasiNewton\", \"Newton\", \"NMinimize\", or \"LevenbergMarquardt\"."
FindIntegerNullVector::nlist = "The first argument `1` of FindIntegerNullVector should be a list of at least two numbers."
FindIntegerNullVector::nrnum = "The second argument `1` of FindIntegerNullVector should be a real number or Infinity."
FindIntegerNullVector::norel = "There is no integer null vector for `1` with norm less than or equal to `2`."
FindIntegerNullVector::lgrel = "FindIntegerNullVector has not found an integer null vector for `1` with norm less than or equal to `2`. Returning a null vector with larger norm."
FindIntegerNullVector::lgrelb = "FindIntegerNullVector has not found an integer null vector for `1` with norm less than or equal to `2` and has proven that no integer null vector with norm less than or equal to `3` exists. Returning a null vector with larger norm."
FindIntegerNullVector::rnf = "FindIntegerNullVector has not found an integer null vector for `1` with norm less than or equal to `2`."
FindIntegerNullVector::rnfb = "FindIntegerNullVector has not found an integer null vector for `1` with norm less than or equal to `2` and has proven that no integer null vector with norm less than or equal to `3` exists."
FindIntegerNullVector::rnfu = "FindIntegerNullVector has not found an integer null vector for `1`."
FindIntegerNullVector::lowpr = "FindIntegerNullVector cannot find an integer null vector because of insufficient precision of the input."
FindMinimum::ucmtd = FindMaximum::ucmtd = FindFit::ucmtd = NonlinearModelFit::ucmtd = FindArgMin::ucmtd = FindArgMax::ucmtd = FindMinValue::ucmtd = FindMaxValue::ucmtd = "Method -> `1` can only be used for unconstrained problems."
FindMinimum::ucmtda = FindMaximum::ucmtda = FindFit::ucmtda = NonlinearModelFit::ucmtda = FindArgMin::ucmtda = FindArgMax::ucmtda = FindMinValue::ucmtda = FindMaxValue::ucmtda = "Method -> `1` can only be used for unconstrained problems; using Method -> Automatic instead."
FindMinimum::cvecv = FindMaximum::cvecv = FindArgMin::cvecv = FindArgMax::cvecv = FindMinValue::cvecv = FindMaxValue::cvecv = FindFit::cvecv = NonlinearModelFit::cvecv = "Constrained optimization is only supported with scalar valued variables."
FindMinimum::fddis = FindMaximum::fddis = FindArgMin::fddis = FindArgMax::fddis = FindMinValue::fddis = FindMaxValue::fddis = FindFit::fddis = NonlinearModelFit::fddis = FindRoot::fddis = "The starting values `1` and `2` are not sufficiently distinct to begin a search."
FindMinimum::fdin = FindMaximum::fdin = FindArgMin::fdin = FindArgMax::fdin = FindMinValue::fdin = FindMaxValue::fdin = FindFit::fdin = NonlinearModelFit::fddis = FindRoot::fdin = "Form of start specification `1` in `2` is inconsistent with other start specifications."
FindMinimum::lss = FindMaximum::lss = FindArgMin::lss = FindArgMax::lss = FindMinValue::lss = FindMaxValue::lss = FindRoot::lss = "`1` should be a non-empty list of search specifications, each consisting of a variable and starting values."
FindFit::lss = NonlinearModelFit::lss = "`1` should be a non-empty list of search specifications, each consisting of a variable and possibly starting values."
General::fdss = "Search specification `1` should be a list with 1 to 5 elements."
FindMinimum::srect = FindMaximum::srect = FindArgMin::srect = FindArgMax::srect = FindMinValue::srect = FindMaxValue::srect = FindFit::srect = NonlinearModelFit::srect = FindRoot::srect = "Value `1` in search specification `2` is not a number or array of numbers."
FindMinimum::scdims = FindMaximum::scdims = FindArgMin::scdims = FindArgMax::scdims = FindMinValue::scdims = FindMaxValue::scdims = FindFit::scdims = NonlinearModelFit::scdims = FindRoot::scdims = "Values given in search specification `1` do not have consistent dimensions."
FindMinimum::snum = FindMaximum::snum = FindArgMin::snum = FindArgMax::snum = FindMinValue::snum = FindMaxValue::snum = FindFit::snum = NonlinearModelFit::snum = FindRoot::snum = "Value `1` in search specification `2` is not a number."
FindMinimum::fdssnv = FindMaximum::fdssnv = FindArgMin::fdssnv = FindArgMax::fdssnv = FindMinValue::fdssnv = FindMaxValue::fdssnv = FindRoot::fdssnv = FindFit::fdssnv = NonlinearModelFit::fdssnv = "Search specification `1` without variables should be a list with 1 to 4 elements."
FindMinimum::fdvc = FindMaximum::fdvc = FindArgMin::fdvc = FindArgMax::fdvc = FindMinValue::fdvc = FindMaxValue::fdvc = FindFit::fdvc = NonlinearModelFit::fdvc = FindRoot::fdvc = "Variable number `1` has value `2` that cannot be compared with the bounds `3`."
FindMinimum::bbound = FindMaximum::bbound = FindArgMin::bbound = FindArgMax::bbound = FindMinValue::bbound = FindMaxValue::bbound = FindFit::bbound = NonlinearModelFit::bbound = FindRoot::bbound = "Search region bound `1` for variable number `2` is not a number or Infinity."
FindMinimum::linf = FindMaximum::linf = FindArgMin::linf = FindArgMax::linf = FindMinValue::linf = FindMaxValue::linf = FindFit::linf = NonlinearModelFit::linf = FindRoot::linf = "Lower bound for search region for variable number `1` is Infinity, leaving no values in the region."
FindMinimum::uinf = FindMaximum::uinf = FindArgMin::uinf = FindArgMax::uinf = FindMinValue::uinf = FindMaxValue::uinf = FindFit::uinf = NonlinearModelFit::uinf = FindRoot::uinf = "Upper bound for search region for variable number `1` is -Infinity, leaving no values in the region."
FindMinimum::eqineq = FindMaximum::eqineq = FindArgMin::eqineq = FindArgMax::eqineq = FindMinValue::eqineq = FindMaxValue::eqineq = FindFit::eqineq = NonlinearModelFit::eqineq = "Constraints in `1` are not all equality or inequality constraints. With the exception of integer domain constraints for linear programming, domain constraints or constraints with Unequal (!=) are not supported."
General::cvmit = "Failed to converge to the requested accuracy or precision within `1` iterations."
FindMinimum::quadnm = FindMaximum::quadnm = FindArgMin::quadnm = FindArgMax::quadnm = FindMinValue::quadnm = FindMaxValue::quadnm = "The algorithm specified by option Method -> QuadraticProgramming can only be used to solve machine-precision problems."
General::eit = "The algorithm does not converge to the tolerance of `1` in `2` iterations. The best estimated solution, with feasibility residual, KKT residual, or complementary residual of `3`, is returned."
FindMinimum::fmdig = FindMaximum::fmdig = FindArgMin::fmdig = FindArgMax::fmdig = FindMinValue::fmdig = FindMaxValue::fmdig = FindFit::fmdig = NonlinearModelFit::fmdig = "Working precision `1` is insufficient to achieve the requested accuracy or precision."
FindMinimum::nzres = FindMaximum::nzres = FindArgMin::nzres = FindArgMax::nzres = FindMinValue::nzres = FindMaxValue::nzres = FindFit::nzres = NonlinearModelFit::nzres = "The step size for Method -> LevenbergMarquardt has become nearly zero at working precision `1`. The residual appears to be nonzero, which can lead to poor convergence of the method. It is recommended that you try Method -> Newton or Method -> QuasiNewton for better convergence."
FindMinimum::sctl = FindMaximum::sctl = FindArgMin::sctl = FindArgMax::sctl = FindMinValue::sctl = FindMaxValue::sctl = FindFit::sctl = FindRoot::sctl = NonlinearModelFit::sctl = "The value of the option StepControl -> `1` is not one of Automatic, LineSearch, TrustRegion, or None."
FindMinimum::scone = FindMaximum::scone = FindArgMin::scone = FindArgMax::scone = FindMinValue::scone = FindMaxValue::scone = FindFit::scone = NonlinearModelFit::scone = FindRoot::scone = "The method you have chosen is only compatible with StepControl -> `1`."
FindFit::sdprec = NonlinearModelFit::sdprec = FindMinimum::sdprec = FindArgMin::sdprec = FindMinValue::sdprec = "Line search unable to find a sufficient decrease in the function value with `1` digit precision."
FindMaximum::sdprec = FindArgMax::sdprec = FindMaxValue::sdprec = "Line search unable to find a sufficient increase in the function value with `1` digit precision."
FindRoot::sdprec = "The line search was unable to find a sufficient decrease in the merit function value with `1` digit precision."
FindMinimum::lstol = FindArgMin::lstol = FindMinValue::lstol = "The line search decreased the step size to within the tolerance specified by AccuracyGoal and PrecisionGoal but was unable to find a sufficient decrease in the function. You may need more than `1` digits of working precision to meet these tolerances."
LinearProgramming::lpdom = "Warning: `1` is not a valid domain specification and is ignored. Domain specification must be Reals, Integers, or of the form {dom1, dom2,...}, where dom1, doma2, etc. are either Reals or Integers."
LinearProgramming::lpdom2 = "Warning: `1` in `2` is not a valid domain specification and is ignored. Domain specification must be either Reals or Integers."
FindMinimum::nonlin = FindMaximum::nonlin = FindArgMin::nonlin = FindArgMax::nonlin = FindMinValue::nonlin = FindMaxValue::nonlin = "Value of option Method -> LinearProgramming is inconsistent with nonlinear constraints or object function in `1`."
FindMaximum::lstol = FindArgMax::lstol = FindMaxValue::lstol = "The line search decreased the step size to within the tolerance specified by AccuracyGoal and PrecisionGoal but was unable to find a sufficient increase in the function. You may need more than `1` digits of working precision to meet these tolerances."
FindFit::lstol = NonlinearModelFit::lstol = "The line search decreased the step size to within tolerance specified by AccuracyGoal and PrecisionGoal but was unable to find a sufficient decrease in the norm of the residual. You may need more than `1` digits of working precision to meet these tolerances."
FindRoot::lstol = "The line search decreased the step size to within tolerance specified by AccuracyGoal and PrecisionGoal but was unable to find a sufficient decrease in the merit function. You may need more than `1` digits of working precision to meet these tolerances."
FindFit::lsbrak = NonlinearModelFit::lsbrak = FindMinimum::lsbrak = FindArgMin::lsbrak = FindMinValue::lsbrak = "Unable to bracket a minimum along the direction `2` from the point `1`."
FindMaximum::lsbrak = FindArgMax::lsbrak = FindMaxValue::lsbrak = "Unable to bracket a maximum along the direction `2` from the point `1`."
FindRoot::btf = FindMinimum::btf = FindMaximum::btf = FindArgMin::btf = FindArgMax::btf = FindMinValue::btf = FindMaxValue::btf = FindFit::btf = NonlinearModelFit::btf = "The value of the option BacktrackingFactors -> `1` should be a list {amin, amax} with 0 < amin <= amax < 1."
FindRoot::bddir = "The search direction `1` is not a descent direction for the merit function. The step will be taken without the line search."
FindMinimum::bddir = FindArgMin::bddir = FindMinValue::bddir = FindFit::bddir = NonlinearModelFit::bddir = "The search direction `1` is not a descent direction for the function. Typically this occurs when the function is not smooth or the values of the function are much less accurate than the WorkingPrecision."
FindMaximum::bddir = FindArgMax::bddir = FindMaxValue::bddir = "The search direction `1` is not an ascent direction for the function. Typically this occurs when the function is not smooth or the values of the function are much less accurate than the WorkingPrecision."
FindMinimum::fmgl = FindMaximum::fmgl = FindArgMin::fmgl = FindArgMax::fmgl = FindMinValue::fmgl = FindMaxValue::fmgl = FindFit::fmgl = NonlinearModelFit::fmgl = "Gradient `1` is not a length `2` list of real numbers at `3` = `4`."
FindMinimum::fmgs = FindMaximum::fmgs = FindArgMin::fmgs = FindArgMax::fmgs = FindMinValue::fmgs = FindMaxValue::fmgs = FindFit::fmgs = NonlinearModelFit::fmgs = "Could not symbolically find the gradient of `1`. Try using the default method, giving two starting values for each variable."
FindMinimum::prax2 = FindMaximum::prax2 = FindArgMin::prax2 = FindArgMax::prax2 = FindMinValue::prax2 = FindMaxValue::prax2 = FindFit::prax2 = NonlinearModelFit::prax2 = "Method -> PrincipalAxis requires two starting values in each variable."
FindMinimum::fmhs = FindMaximum::fmhs = FindArgMin::fmhs = FindArgMax::fmhs = FindMinValue::fmhs = FindMaxValue::fmhs = FindFit::fmhs = NonlinearModelFit::fmhs = "Could not symbolically find the Hessian by differentiating the gradient `1`. Try using Method -> QuasiNewton instead."
FindMinimum::fmgz = FindArgMin::fmgz = FindMinValue::fmgz = FindFit::fmgz = NonlinearModelFit::fmgz = "Encountered a gradient that is effectively zero. The result returned may not be a minimum; it may be a maximum or a saddle point."
FindMaximum::fmgz = FindArgMax::fmgz = FindMaxValue::fmgz = "Encountered a gradient that is effectively zero. The result returned may not be a maximum; it may be a minimum or a saddle point."
FindMinimum::fmmp = FindMaximum::fmmp = FindArgMin::fmmp = FindArgMax::fmmp = FindMinValue::fmmp = FindMaxValue::fmmp = FindFit::fmmp = NonlinearModelFit::fmmp = "Machine precision is insufficient to achieve the requested accuracy or precision."
FindMinimum::fmns = FindMaximum::fmns = FindArgMin::fmns = FindArgMax::fmns = FindMinValue::fmns = FindMaxValue::fmns = FindFit::fmns = NonlinearModelFit::fmns = "Starting value `1` contains numbers that are not real."
FindMinimum::fmwar = FindMaximum::fmwar = FindArgMin::fmwar = FindArgMax::fmwar = FindMinValue::fmwar = FindMaxValue::fmwar = FindFit::fmwar = NonlinearModelFit::fmwar = "Only the first starting value, `1`, in each dimension is used unless Method -> PrincipalAxis or Automatic is specified."
FindMinimum::fmwarc = FindMaximum::fmwarc = FindArgMin::fmwarc = FindArgMax::fmwarc = FindMinValue::fmwarc = FindMaxValue::fmwarc = FindFit::fmwarc = NonlinearModelFit::fmwarc = "Only the first starting value, `1`, in each dimension is used for constrained problems."
FindFit::notlm = NonlinearModelFit::notlm = FindMinimum::notlm = FindArgMin::notlm = FindMinValue::notlm = "The objective function for the method LevenbergMarquardt must be in a least-squares form: Sum[f[i][x]^2, {i, 1, n}] or Sum[w[i] f[i][x]^2, {i, 1, n}] with positive w[i]."
FindMaximum::notlm = FindArgMax::notlm = FindMaxValue::notlm = "The objective function for the method LevenbergMarquardt must be in a least-squares form: Sum[-f[i][x]^2, {i, 1, n}] or Sum[w[i] f[i][x]^2, {i, 1, n}] with negative w[i]."
FindMinimum::regex1 = FindMaximum::regex1 = FindArgMin::regex1 = FindArgMax::regex1 = FindMinValue::regex1 = FindMaxValue::regex1 = FindFit::regex1 = NonlinearModelFit::regex1 = FindRoot::regex1 = "Reached the point `1` that has component `2` equal to `3`, which is outside the range `4`."
FindMinimum::regex = FindMaximum::regex = FindArgMin::regex = FindArgMax::regex = FindMinValue::regex = FindMaxValue::regex = FindFit::regex = NonlinearModelFit::regex = FindRoot::regex = "Reached the point `1`, which is outside the region `2`."
FindMinimum::reged = FindMaximum::reged = FindArgMin::reged = FindArgMax::reged = FindMinValue::reged = FindMaxValue::reged = FindFit::reged = NonlinearModelFit::reged = FindRoot::reged = "The point `1` is at the edge of the search region `3` in coordinate `2` and the computed search direction points outside the region."
FindMinimum::streg = FindMaximum::streg = FindArgMin::streg = FindArgMax::streg = FindMinValue::streg = FindMaxValue::streg = FindFit::streg = NonlinearModelFit::streg = FindRoot::streg = "The starting point `1` is not in the search region `2`."
FindFit::sszero = NonlinearModelFit::sszero = FindMinimum::sszero = FindArgMin::sszero = FindMinValue::sszero = "The step size in the search has become less than the tolerance prescribed by the PrecisionGoal option, but the gradient is larger than the tolerance specified by the AccuracyGoal option. There is a possibility that the method has stalled at a point that is not a local minimum."
FindMaximum::sszero = FindArgMax::sszero = FindMaxValue::sszero = "The step size in the search has become less than the tolerance prescribed by the PrecisionGoal option, but the gradient is larger than the tolerance specified by the AccuracyGoal option. There is a possibility that the method has stalled at a point that is not a local maximum."
FindRoot::sszero = "The step size in the search has become less than the tolerance prescribed by the PrecisionGoal option, but the function value is still greater than the tolerance prescribed by the AccuracyGoal option."
FindMinimum::stfail = FindMaximum::stfail = FindArgMin::stfail = FindArgMax::stfail = FindMinValue::stfail = FindMaxValue::stfail = FindFit::stfail = NonlinearModelFit::stfail = FindRoot::stfail = "The method `1` failed to compute the next step."
FindMinimum::umtd = FindMaximum::umtd = FindArgMin::umtd = FindArgMax::umtd = FindMinValue::umtd = FindMaxValue::umtd = FindFit::umtd = NonlinearModelFit::umtd = "The method `1` has returned `2` instead of a step for FindMinimum to use or a list {step, state}."
FindMinimum::lsm = FindMaximum::lsm = FindArgMin::lsm = FindArgMax::lsm = FindMinValue::lsm = FindMaxValue::lsm = FindFit::lsm = NonlinearModelFit::lsm = FindRoot::lsm = "The method `1` is not a line search method."
FindMinimum::trm = FindMaximum::trm = FindArgMin::trm = FindArgMax::trm = FindMinValue::trm = FindMaxValue::trm = FindFit::trm = NonlinearModelFit::trm = FindRoot::trm = "The method `1` is not a trust region method."
FindMinimum::trmss = FindMaximum::trmss = FindArgMin::trmss = FindArgMax::trmss = FindMinValue::trmss = FindMaxValue::trmss = FindFit::trmss = NonlinearModelFit::trmss = FindRoot::trmss = "The maximum trust region scaled step size `1` is not a positive real number."
FindMinimum::trsss = FindMaximum::trsss = FindArgMin::trsss = FindArgMax::trsss = FindMinValue::trsss = FindMaxValue::trsss = FindFit::trsss = NonlinearModelFit::trsss = FindRoot::trsss = "The starting trust region scaled step size `1` is not a positive real number."
FindMinimum::trasr = FindMaximum::trasr = FindArgMin::trasr = FindArgMax::trasr = FindMinValue::trasr = FindMaxValue::trasr = FindFit::trasr = NonlinearModelFit::trasr = FindRoot::trasr = "The value of the option AcceptableStepRatio -> `1` should be a real number between 0 and 1/2."
FindRoot::umtd = "The method `1` has returned `2` instead of a step for FindRoot to use or a list {step, state}."
FindRoot::bdmtd = "Value of option Method -> `1` is not Automatic, Brent, Secant, or Newton."
FindRoot::eqlist = "In the first argument `1` only some of the components are equations."
FindRoot::fdst = FindMinimum::fdst = FindMaximum::fdst = FindArgMin::fdst = FindArgMax::fdst = FindMinValue::fdst = FindMaxValue::fdst = FindFit::fdst = NonlinearModelFit::fdst = "Expression `1` in `2` is not a valid start specification; a number or pair of numbers is expected."
FindRoot::frdig = "`1` working digits is insufficient to achieve the absolute tolerance `2`."
FindRoot::sec2 = "Method -> Secant requires two starting values for each dimension."
FindRoot::bbrac = "Method -> Brent is only applicable to univariate real functions and requires two real starting values that bracket the root."
FindRoot::frn2 = "With Method -> Newton only the first starting value in each dimension will be used."
FindRoot::frmp = "Machine precision is insufficient to achieve the accuracy `1`."
FindRoot::brmp = "The root has been bracketed as closely as possible with machine precision but the function value exceeds the absolute tolerance `1`."
FindRoot::brdig = "The root has been bracketed as closely as possible with `1` working digits but the function value exceeds the absolute tolerance `2`."
FindRoot::frns = "Starting value `1` in `2` is not a number."
FindRoot::jsing = "Encountered a singular Jacobian at the point `1` = `2`. Try perturbing the initial point(s)."
FindRoot::jsing1 = "Encountered a singular Jacobian at the point `1`. Try perturbing the initial point(s)."
FindRoot::mmin = "The search appears to be stopped near a local minimum of the merit function that is not an actual root. Try using a different starting point."
FindRoot::zdamp = "The factors given in DampingFactor -> `1` must all be strictly positive."
FindRoot::dfmin = "The minimal damping factor of `1` has been reached."
FindRoot::lmin = "The minimal damping factor given as `1` should be a positive number less than or equal to 1."
FindRoot::idf = "The initial damping factor given as `1` should be a number larger than the minimal damping factor `2` and less than or equal to 1."
FindRoot::nveq = "The number of equations does not match the number of variables in `1`."
FindRoot::trcx = "The search has encountered a complex value and the trust region step control method is only implemented for real values."
FindRoot::precinc = "Increase of precision to `2` failed for method `1`."
FindRoot::agorpg = "With WorkingPrecision->Automatic, one of AccuracyGoal or PrecisionGoal must be specified explicitly."
FindFit::nlnrm = NonlinearModelFit::nlnrm = "The model `1` is linear in the parameters `2`, but because the norm specified with NormFunction -> `3` is non-Euclidean, the linear least-squares method specified with Method -> `4` cannot be used."
FindFit::lmnl = NonlinearModelFit::lmnl = "The model `1` is linear in the parameters `2`, but a nonlinear method or non-Euclidean norm was specified, so nonlinear methods will be used."
FindFit::nlmod = NonlinearModelFit::nlmod = "The model `1` is not linear in the parameters `2` so the linear least-squares method specified with Method -> `3` cannot be used."
FindFit::nlmodreg = "The model `1` is not linear in the parameters `2`.  The regularization given by FitRegularization->`3` may only be used with linear models."
General::conv = "Interior point method fails to converge."
General::grad = "Evaluation of the gradient of function `1` failed at `2`."
General::nmthd = "Warning: the value of option Method -> `1` is not valid; use Method -> Automatic instead."
FindShortestTour::ccap = "Method -> `1` can only be applied to a list of 2D points."
FindShortestTour::twod = "Method -> `1` can only be applied to a list of 2D points. Using Method -> Automatic setting instead."
FindShortestTour::badin = "The input `1` is not a list of points in the Euclidean space."
FindShortestTour::illmet = "Value of option Method -> `1` is not Automatic, \"AllTours\", \"CCA\", \"Greedy\", \"GreedyCycle\", \"IntegerLinearProgramming\", \"OrOpt\", \"OrZweig\", \"RemoveCrossings\", \"SpaceFillingCurve\", \"SimulatedAnnealing\", or \"TwoOpt\"."
FindShortestTour::reppt = "The input `1` does not contain distinct points."
FindShortestTour::dist = "The distance function `1` does not give a numerical result when applied to two points."
FindShortestTour::euc = "This method is meant for Euclidean distance only."
FindShortestTour::asymdi = "The distance function must be symmetric.";
FindShortestTour::alltr = "Input too large to try all possibilities. Using Method -> Automatic setting instead."
General::nreal = "Either the constraints, `2`, or the objective function, `1`, contain nonreal terms."
Optimization`NonlinearInteriorPoint::infea = "No solution can be found that satisfies the constraints."
Optimization`NonlinearInteriorPoint::ctype = "The list constraints `1` contain a constraint `2` that is not supported."
Optimization`NonlinearInteriorPoint::badspt = "Value of option StartingPoint -> `1` is not valid."
Optimization`NonlinearInteriorPoint::badit = "`1` is not a valid value for the MaxIterations option, which should be a positive integer."
Optimization`NonlinearInteriorPoint::uneq = "The constraints, `1`, contain unequal type constraints that are not supported."
Optimization`NonlinearInteriorPoint::elem = "The constraints, `1`, contain element type constraints that are not supported."
Optimization`NonlinearInteriorPoint::malf = "The constraints, `1`, are malformed. This may be, for example, because the constraints do not form equalities or inequalities."
General::pcone = "The value given in position `2` of `1` should be a specification of a proper convex cone."
General::pconef = "The value given in position `2` of `1` should be a specification of a proper convex cone or family of cones."
General::vcomp = "The comparison in `1` only has `2` items to compare.  At least 2 are required."
General::unbndc = "A component of the solution vector has a nonzero linear objective coefficient but all the elements of the constraint matrix corresponding to that component are zero, so the optimal value is unbounded."
SemidefiniteOptimization::cdims = Optimization`LinearMatrixInequality::cdims = "The matrices given should all have the same size.  Matrix `2` does not have dimensions {`1`,`1`}."
Optimization`LinearMatrixInequality::vmlen = "The length of the list of matrices, `1` is not the same as the number of variables, `2`."
SemidefiniteOptimization::vmlen = "The length, `1` of the list of matrices at position `2` is not the same as the length, `3`, of the vector at position `4."
SemidefiniteOptimization::spsmmp = "The argument `1` at position `2` is not a symmetric matrix of machine-sized real numbers."
SemidefiniteOptimization::spsmmpl = "The argument `1` at position `2` is not a list of symmetric matrices of machine-sized real numbers."
SemidefiniteOptimization::invldcons = "The specified constraints `1` could not be converted to semidefinite cone constraints."
ConicOptimization::sdplib = SemidefiniteOptimization::sdplib = "The library for semidefinite optimization could not be loaded.   Check that your installation is up to date."
SemidefiniteOptimization::badmtd = SecondOrderConeOptimization::badmtd = "Method `1` is not one of Automatic, \"CSDP\", \"DSDP\", \"SCS\" or \"SuperSCS\"."
LinearOptimization::badmtd = LinearFractionalOptimization::badmtd = "Method `1` is not one of Automatic, \"Simplex\", \"RevisedSimplex\", \"InteriorPoint\" or \"CLP\"."
QuadraticOptimization::badmtd = "Method `1` is not one of Automatic, \"COIN\", \"CSDP\", \"DSDP\", \"SCS\" or \"SuperSCS\"."
QuadraticOptimization::qlen = "The argument `1` at position 1 is not a two element list."
QuadraticOptimization::invldquad = "The first argument in `1` is not a matrix or a list containing a matrix or a list containing matrix and vector."
QuadraticOptimization::invldqvec = "The second argument in `1` is not a vector of real numeric values."
QuadraticOptimization::qvlen = "The vector `1` at position `2` in `3` is not a vector of length `4`."
QuadraticOptimization::unbnd = "The problem is unbounded."
QuadraticOptimization::qosnf = LinearFractionalOptimization::lpsnf = "No solution can be found that satisfies the constraint."
QuadraticOptimization::qodnf = "The dual of this problem is possibly infeasible, which implies that this problem is either unbounded or infeasible."
QuadraticOptimization::qopnf = "The problem is probably infeasible. QuadraticOptimization was unable to find a solution."
QuadraticOptimization::fail = "QuadraticOptimization was unable to find a solution."
QuadraticOptimization::qspsd = "Unable to factorize the quadratic function matrix because it was not a positive semi-definite matrix."
QuadraticOptimization::quadobj = "The objective function `1` is not a numeric valued quadratic function of the variables `2`."
QuadraticOptimization::qcoeffs = "Unable to extract quadratic coefficients from the objective `1` for variables `2`."
LinearOptimization::lcoeffs = LinearFractionalOptimization::lcoeffs = QuadraticOptimization::lcoeffs = ConicOptimization::lcoeffs = "Unable to extract linear coefficients from the constraint `1` for variables `2`."
LinearOptimization::lcdims = LinearFractionalOptimization::lcdims = QuadraticOptimization::lcdims = ConicOptimization::lcdims = "The lhs and rhs of the linear coefficients from the constraint `1` have inconsistent dimensions for variables `2`."
LinearOptimization::lincons = LinearFractionalOptimization::lincons = QuadraticOptimization::lincons = "The constraints `1` are not all linear in the variables `2` with numeric coefficients."
SecondOrderConeOptimization::lincons = "The constraints `1` are linear in the variables `2` but do not have numeric coefficients."
SemidefiniteOptimization::linobj = ConicOptimization::linobj = SecondOrderConeOptimization::linobj = LinearOptimization::linobj = "The objective function `1` is not a numeric valued linear function of the variables `2`."
LinearFractionalOptimization::mlen = "The argument `1` at position 1 is not a four element list."
LinearFractionalOptimizaion::mnval = "The argument `1` in `2` at position `3` is not a numeric value."
LinearFractionalOptimization::mnvec = "The argument `1` in `2` at position `3` is not a vector of numeric values."
LinearFractionalOptimization::mvlen = "The vector `1` in `2` at position `3` is not a vector of length `4`."
LinearFractionalOptimization::ubndf = "The feasible region includes points where the denominator \[Gamma].x + \[Delta] is zero. LinearFractionalOptimization will return a solution on the limiting line  \[Gamma].x + \[Delta] = 0, where the minimizing function is unbounded."
LinearFractionalOptimization::ubndv = "One or more elements of the solution vector is unbounded but the linear fractional function approaches a finite minimum limit."
General::ubndf = "The feasible region include points where the objective function is singular so the optimal value is unbounded."
General::ubndv = "One or more elements of the solution vector is unbounded but the objective function approaches a bounded optimal value."
LinearFractionalOptimization::lfobj = "The objective function `1` is not a numeric valued linear fractional function of the variables `2`."
LinearOptimization::bdsmplx = LinearFractionalOptimization::bdsmplx = "The \"Simplex\" method only supports input for which all numerical elements are explicitly real, integer, or rational numbers. Try using \"RevisedSimplex\" for input with NumericQ elements."
LinearOptimization::lcbad = QuadraticOptimization::lcbad = LinearFractionalOptimization::lcbad = "The second argument `1` is not a list {a,b} specifying linear inequality constraints."
LinearOptimization::lecbad = QuadraticOptimization::lecbad = LinearFractionalOptimization::lecbad = "The third argument `1` is not a list {a,b} specifying linear inequality constraints."
LinearOptimization::lcxlen = QuadraticOptimization::lcxlen = LinearFractionalOptimization::lcxlen = "The matrix `1` given for the linear inequality constraints has column dimension inconsistent with the length `2` of the minimizer required by the first argument."
LinearOptimization::lecxlen = QuadraticOptimization::lecxlen = LinearFractionalOptimization::lecxlen = "The matrix `1` given for the linear equality constraints has column dimension inconsistent with the length `2` of the minimizer required by the first argument."
LinearOptimization::lcblen = QuadraticOptimization::lcblen = LinearFractionalOptimization::lcblen = "The matrix `1` and the vector `2` given for the linear inequality constraints have inconsistent length."
LinearOptimization::lecblen = QuadraticOptimization::lecblen = LinearFractionalOptimization::lecblen = "The matrix `1` and the vector `2` given for the linear equality constraints have inconsistent length."
LinearOptimization::lcbvec = QuadraticOptimization::lcbvec = LinearFractionalOptimization::lcbvec = "The second element of the list `1` given for the linear inequality constraints should be a vector of numeric values."
LinearOptimization::lecbvec = QuadraticOptimization::lecbvec = LinearFractionalOptimization::lecbvec = "The second element of the list `1` given for the linear equality constraints should be a vector of numeric values."
LinearOptimization::lcamat = QuadraticOptimization::lcamat = LinearFractionalOptimization::lcamat = "The first element of the list `1` given for the linear inequality constraints should be a matrix of numeric values."
LinearOptimization::lecamat = QuadraticOptimization::lecamat = LinearFractionalOptimization::lecamat = "The first element of the list `1` given for the linear equality constraints should be a matrix of numeric values."
LinearOptimization::lecmatonly = QuadraticOptimization::lecmatonly = LinearFractionalOptimization::lecmatonly = "The linear equality constraints `1` were given only as a matrix instead of in the form {a, b} where a is a matrix and b is a vector. b will be taken to be a zero vector."
LinearOptimization::lcmatonly = QuadraticOptimization::lcmatonly = LinearFractionalOptimization::lcmatonly = "The linear inequality constraints `1` were given only as a matrix instead of in the form {a, b} where a is a matrix and b is a vector. b will be taken to be a zero vector."
General::coniccon = "The constraint `1` could not be converted to a ConicConstraint."
ConicOptimization::colib = "The library for conic optimization could not be loaded. Check that your installation is up to date."
SecondOrderConeOptimization::objvec = LinearOptimization::objvec = ConicOptimization::objvec = SemidefiniteOptimization::objvec = "The objective `1` is not a vector of numeric values."
ConicOptimization::conetf = "The constraint `1` is not a conic constraint."
ConicOptimization::conetfd = "The constraint `1` is not a conic constraint for vectors in dimension `2`."
ConicOptimization::bdcomtd = "The method `1` is not a conic optimization method."
ConicOptimization::iccomtd = SecondOrderConeOptimization::iccomtd = "The `1` method cannot be used for optimization with `2` constraints."
ConicOptimization::badsemirm = QuadraticOptimization::badsemirm = "The SemidefiniteResidualMethod `1` is not one of \"Eigenvalues\", \"Decomposition\" or Automatic."
ConicOptimization::badstpt = QuadraticOptimization::badstpt = "The starting point `1` is not one of Automatic, \"SCS\" or a numeric vector of length `2`."
ConicOptimization::scsfail = QuadraticOptimization::scsfail = "Could not obtain a starting point using method \"SCS\". Continuing with a zero vector starting point." 
ConicConstraint::affinetf = "The term `2` in constraint `1` is not a valid affine transform specification." 
SemidefiniteOptimization::fvspec = QuadraticOptimization::fvspec = LinearFractionalOptimization::fvspec = SecondOrderConeOptimization::fvspec = "The input for `1` is not of the correct matrix form and appears to have variables.  If you intend to specify the problem with variables, be sure to use `1`[f, constraints, vars]."
SecondOrderConeOptimization::ncon = "The constraint `2` in `1` is not a list with four elements."
SecondOrderConeOptimization::lcon = "The constraint `2` in `1` should be a real numeric vector."
SecondOrderConeOptimization::lcon1 = "The constraint `2` in `1` has dimensions inconsistent with the primal minimizer length."
SecondOrderConeOptimization::lscon = "The last element of constraint `2` in `1` is not a scalar numeric value."
SecondOrderConeOptimization::qcon1 = "The first element of constraint `2` in `1` is a matrix whose columns are not equal to the primal minimizer length."
SecondOrderConeOptimization::socconpf = "The second order cone constraints could not be processed."
SecondOrderConeOptimization::soclib = "The libraries for solving second order cone problems could not be loaded." 
SecondOrderConeOptimization::invldcons = "The specified constraints cannot be converted to linear or second order cone constraints." 
SecondOrderConeOptimization::objvlen = "The objective vector length could not be determined."
SecondOrderConeOptimization::qcvec = "The second element of constraint `2` in `1` should be a real numeric vector."
SecondOrderConeOptimization::qcmat = "The first element of constraint `2` in `1` should be a real numeric matrix."
LinearOptimization::oplotd = LinearFractionalOptimization::oplotd = QuadraticOptimiation::oplotd = SecondOrderConeOptimization::oplotd = SemidefiniteOptimization::oplotd = ConicOptimization::oplotd = "The `1` property is only available for `2` problems in 2 dimensions."
General::bdprop = "`1` is not a solution property";
General::linobj = "The objective `1` is not a linear function."
General::icopmtd = "The `1` method cannot be used for optimization of a `2` objective function with `3` constraints."
General::vardim = "The dimensionality of variables `1` could not be determined automatically.  The dimensionality may be given by specifying variables using Element."
General::vardimas = "The dimensionaliity of variables `1` was not determined automatically and they will assumed to be scalars."
General::varspec = "`1` is not a valid variable specification."
General::nvar = "`1` cannot be used as a variable."
General::dpvar = "The variable `1` has been specified more than once."
General::indvar = "To use `1` as a variable the indexes `2` must all be positive machine-sized integers."
General::indvarl = "Indexed variables with base `1` should all have the same index length. `2` has index length `3` that is inconsistent the variables `4`."
General::domdepth = "The array depth of `1` is inconsistent with the domain in `2`."
General::domdims = "The dimensions of `1` are inconsistent with the domain in `2`."
General::icdom = "The domain `1` for the variable `2` is incompatible with the domain implied by the constraint `3`."
General::vedom = "The constraints include restrictions of some variables to the domain `1`.  Currently there is only support for the Reals."
General::cxdom = "The constraints include restrictions of some variables to the Complexes.  Currently only optimization over the Reals is supported so any result returned is optimal only over the Reals."
General::nvedom = "Invalid entry domain `2` elements `1` in constraint `3`.  Restricted entry domains may only be given for variables."
General::bdcnstr = "`1` is not a valid specification for a constraint."
General::nvcnstr = "The constraint `1` did not explicitly have any of the variables `2` and will be disregarded."
General::scineq = "Both sides of the inequality `1` should be scalar valued.  For vectors `2` may be used."
General::scobj = "The objective function `1` should be scalar valued."
General::exnorm = "The term `1` appears to have come from Norm evaluating symbolically on an explicit list resulting from addition with lists.  Try using Inactive[Norm] instead of Norm."
General::vicdim = "The left and right hand side arguments of `1` have dimensionality inconsistent with the dimensions `2` of the cone `3`."
General::vidim = "The left and right hand side arguments of `1` do not have consistent dimensionality."
General::eqdim = "The left and right hand sides of the equality constraint `1` do not have consistent dimensionality."
General::tobj = "The objective function `1` could not be transformed to a linear, fractional, or quadratic."
General::tobjl = "The objective function `1` could not be transformed to a linear expression."
General::tcnstr = "The constraint `1` could not be transformed to a convex conic constraint."
General::maxtstep = "The number of transformation steps exceeded the maximum of `1` allowed."
General::bdobjtv = "`1` is not a valid specification for an objective function."
General::lcoeff = "Was not able to extract the linear coefficients with respect to the variables `2` of `1`."
General::qcoeff = "Was not able to extract the quadratic coefficients with respect to the variables `2` of `1`."
General::nofirst = "`1` has zero length and no first element."
General::nolast = "`1` has zero length and no last element."
General::fitc = "Number of coordinates (`1`) is not equal to the number of variables (`2`)."
Fit::fitd = "First argument `1` in Fit is not a list or a rectangular array."
Fit::dmrv = "If the number of argument to Fit is fewer than 3, the first argument should be a list {designMatrix, response}."
DesignMatrix::fitd = "First argument `1` in DesignMatrix is not a list or a rectangular array."
FindFit::fitd = "First argument `1` in FindFit is not a list or a rectangular array."
NonlinearModelFit::fitd = "First argument `1` in NonlinearModelFit is not a list or a rectangular array."
Fit::fitm = FindFit::fitm = NonlinearModelFit::fitm = LinearModelFit::fitm = GeneralizedLinearModelFit::fitm = LogitModelFit::fitm = ProbitModelFit::fitm = DesignMatrix::fitm = "Unable to solve for the fit parameters; the design matrix is nonrectangular, non-numerical, or could not be inverted."
Fit::penpar = FindFit::penpar = "The `1` penalty function specification should given in the form {`1`, \[Alpha]} where \[Alpha] is a positive numerical parameter value."
Fit::regpar = FindFit::regpar = "The `1` regularization specification should given in the form {`1`, \[Lambda]} where \[Lambda] is a positive numerical parameter value."
Fit::regcur = FindFit::regcur = "\"Curvature\" regularization cannot be used for fewer than 3 fit parameters."
Fit::bdfitreg = FindFit::bdfitreg = "The fit regularization `1` should be a function or named regularization."
Fit::bdnormf = FindFit::bdnormf = "The norm function `1` should be a function or named penalty function."
Fit::nrrfun = FindFit::nrrfun = "The regularization function `1` evaluates to `2` that is not a real number for a residual vector."
Fit::fitnorm = "The norm function `1` for Fit should be a p-norm or named penalty function.  FindFit may be able to do a more general fit."
Fit::l1fail = "The algorithm for L1 regularization failed to converge.  Returning the best solution found."
FindFit::nrnfun = "The norm function `1` evaluates to `2` that is not a real number for a parameter vector."
Fit::cfitfail = FindFit::cfitfail = "`1` was not able to find fit parameters using available algorithms."
Flatten::flev = "The level argument `1` in position `2` of `3` should be a non-negative integer or Infinity giving the levels to flatten through or a list of lists of levels to flatten together."
Flatten::fldep = "Level `1` specified in `2` exceeds the levels, `3`, which can be flattened together in `4`."
Flatten::flrep = "Level `1` specified in `2` should not be repeated."
Flatten::flpi = "Levels to be flattened together in `1` should be lists of positive integers."
FlattenAt::flatp = "Expression `3` at position `1` of `2` has no parts and cannot be flattened."
FontForm::ffsp = "`1` is not a valid font specification of the form {\"font\", size}."
Format::forml = ToBoxForm::forml = "Recursion depth limit $RecursionLimit exceeded while formatting output."
Format::fttp = "Format type `1` is not a symbol."
Format::lcont = "Line continuation print object too wide."
Format::toobig = "Expression too big for output."
FormatType::ftype = "Value of option FormatType -> `1` is not valid."
Fourier::fpopt = InverseFourier::fpopt = AudioAnnotate::fpopt =  "The value of the option FourierParameters -> `1` should be a length 2 list."
Fourier::fpoptn = InverseFourier::fpoptn = "Both values of FourierParameters -> `1` need to be numeric."
InverseFourier::fpopt2 = "Warning: the discrete Fourier transform may not be invertible unless the second element of the option FourierParameters -> `1` is an integer having no factors in common with the length of the input."
Fourier::fftl = InverseFourier::fftl = FourierDCT::fftl = FourierDST::fftl = "Argument `1` is not a non-empty list or rectangular array of numeric quantities."
FourierDCT::fttype = "The discrete cosine transform type `1` should be 1, 2, 3, or 4."
FourierDST::fttype = "The discrete sine transform type `1` should be 1, 2, 3, or 4."
FrameLabel::fmlab = "Value of option FrameLabel -> `1` should be None, a label, or a list with 2 or 4 labels."
FrobeniusNumber::coef = FrobeniusSolve::coef = "The first argument `1` of `2` should be a nonempty list of positive integers."
FrobeniusSolve::brhs = "The second argument `1` of FrobeniusSolve should be an integer."
FrobeniusSolve::nsol = "The number `1` of requested solutions should be a positive integer."
FromCharacterCode::notunicode = "A character code, which should be a non-negative integer less than 1114112, is expected at position `2` in `1`."
FromContinuedFraction::root = "Unable to determine the appropriate root for the periodic continued fraction."
FromDate::fdls = "`1` is neither a list of 6 machine-sized integers nor a list of 5 machine-sized integers followed by a real number."
FromDigits::nlst = "The expression `1` is not a list of digits or a string of valid digits."
FromDigits::fdb = "The digit `1` is too large for base `2`."
FromDigits::nrom = "The expression `1` is not a proper string of roman digits."
RomanNumeral::int = "Numeric expression `1` is not an integer."
FromRomanNumeral::nrom = "String `1` does not represent a valid roman numeral."
FrontEndObject::invfe = "`1` is not a valid front end object."
FrontEndObject::notavail = "A front end is not available; certain operations require a front end."
Function::attf = "Attributes `1` in `2` cannot be used as function attributes."
Function::fdup = Compile::fdup = "Duplicate parameter `1` found in `2`."
Function::fdups = "Conflicting parameters `1` and `3` found in `2`."
Function::flpar = "Parameter specification `1` in `2` should be a symbol or a list of symbols."
Function::fpct = TransferFunctionModel::fpct = "Too many parameters in `1` to be filled from `2`."
Function::slot = "`1` (in `2`) should contain a non-negative integer or string."
Function::slota = "Named Slot `1` in `2` cannot be filled from `3`."
Function::slotn = "Slot number `1` in `2` cannot be filled from `3`."
Function::slotp = "`1` (in `2`) should contain a positive integer."
Function::slots = "SlotSequence[`1`] in `2` cannot be filled from `3`."
Function::slot1 = "`3` is expected to have an Association as the first argument."
FunctionInterpolation::accg = "Value of option AccuracyGoal -> `1` is not Automatic, Infinity, or a machine-sized integer."
FunctionInterpolation::argdim = "The dimension of the argument to an InterpolatingFunction function object in the input does not match the dimension of the InterpolatingFunction."
FunctionInterpolation::ncvb = "FunctionInterpolation failed to meet the prescribed accuracy and precision goals after `1` recursive bisections near `2` = `3`. Continuing to refine elsewhere."
FunctionInterpolation::npts = "Value of option InterpolationPoints -> `1` is not a machine-sized integer >= 2."
FunctionInterpolation::nreal = "Near `1` = `2`, the function did not evaluate to a real number."
FunctionInterpolation::precg = "Value of option PrecisionGoal -> `1` is not Automatic, Infinity, or a positive machine-sized real or integer."
FunctionInterpolation::range = "Argument `1` is not in the form of a range specification, {x, xmin, xmax}."
Gamma::gamc = "Gamma[`1`, `2`] is too ill-conditioned to compute."
General::altel = "Use `1` to specify assumptions for multiple variables."
General::altno = "Use multiple sets instead of Alternatives in `1`."
General::aofil = "`1` already open as `2`."
General::argb = "`1` called with `2` arguments; between `3` and `4` arguments are expected."
General::argbu = "`1` called with 1 argument; between `2` and `3` arguments are expected."
General::argct = "`1` called with `2` arguments."
General::argctu = "`1` called with 1 argument."
General::argf = "`1` called with `2` arguments; `3` or fewer arguments are expected."
General::argm = "`1` called with `2` arguments; `3` or more arguments are expected."
General::argmu = "`1` called with 1 argument; `2` or more arguments are expected."
General::argr = "`1` called with 1 argument; `2` arguments are expected."
General::argrx = "`1` called with `2` arguments; `3` arguments are expected."
General::argt = "`1` called with `2` arguments; `3` or `4` arguments are expected."
General::argtu = "`1` called with 1 argument; `2` or `3` arguments are expected."
General::argx = "`1` called with `2` arguments; 1 argument is expected."
General::badfile = "The specified argument `1` should be a valid string or File."
General::base = "Requested base `1` in `2` should be between 2 and `3`."
General::bass = "`1` is not a well-formed assumption."
General::bebal = "Unterminated uses of BeginPackage or Begin in `1`."
General::bigfile = "The file `1` is too large to be read into memory."
General::bigrecord = "A record in the file `1` is too large to be read into memory."
General::bigraster = "Not enough memory available to rasterize `1` expression."
General::bktfn = "\"`1`\" should probably be \"`2`\"`4`."
General::bktmch = "\"`1`\" must be followed by \"`2`\", not \"`3`\"`4`."
General::bktmcp = "Expression \"`1`\" has no closing \"`2`\"`4`."
General::bktmop = "Expression \"`1`\" has no opening \"`2`\"`4`."
General::bktwrn = "\"`1`\" represents multiplication; use \"`2`\" to represent a function`4`."
General::bktx = "\"`1`\" has extra \"`2`\" after it`4`."
General::bmod = "Modulus `1` must be an integer or an irreducible univariate polynomial."
General::bool = "True or False expected at position `2` in `1`."
General::boxfmt = "`1` in `2` is not a box formatting type. A box formatting type is any member of $BoxForms."
General::byteord = "Value of option ByteOrdering -> `1` should be 1 or -1."
General::cadpr = "The cylindrical algebraic decomposition algorithm used by `1` failed due to a too low WorkingPrecision. Increasing the value of WorkingPrecision may allow the algorithm to succeed."
General::cas = "Warning: contradictory assumption(s) `1` encountered."
General::cdir = "Cannot set current directory to `1`."
General::cfail = "Algorithm failed to converge."
General::cndvs = "The input to `1` should not contain conditionally valid subexpressions."
General::color = "`1` is not a valid color or gray-level specification."
General::copt = "The option Compiled -> `1` should be True, False, or a list starting with True or False, followed by options."
General::conopt = "`1` is not a string option or a list of string options."
General::continfo = "\!\(`1`f\[DifferentialD]x\) is interpreted as \!\(`2`[f, x]\)."
General::cxls = "Context or non-empty list of contexts expected at position `1` in `2`."
General::cxt = "Invalid context specified at position `2` in `1`. A context must consist of valid symbol names separated by and ending with `3`."
General::dblk = "Value for option DigitBlock should be a positive integer, Infinity, or a pair of positive integers."
General::digit = "Digit at position `1` in `2` is too large to be used in base `3`."
General::dim = "Dimension `1` is not a positive integer giving a dimension to select for data associated with `2` dimensions."
General::adims = "Array dimension specification `1` should be Automatic, a non-negative machine integer, or a list of non-negative machine integers."
General::adimsp = "Array dimension specification `1` should be Automatic, a positive machine integer, or a list of positive machine integers."
General::adimsr = "Array dimension specification `1` should be a non-negative machine integer or a list of non-negative machine integers."
General::adimsrp = "Array dimension specification `1` should be a positive machine integer or a list of positive machine integers."
General::dims = "Dimension specification `1` should be a positive machine integer or a pair of positive machine integers."
General::dimsl = "`1` given in `2` should be a list of dimensions for a particular argument."
General::dirdep = "Cannot get deeper in directory tree: `1`."
General::dirnex = "Directory `1` does not exist."
General::divz = "The argument `1` in `2` should be nonzero."
General::deprec = "`1` is deprecated and will not be supported in future versions of the Wolfram Language. Use `2` instead."
General::dstr = "Directory specification `1` is not a string."
General::dstrfe = "Directory specification `1` is not a string or a FrontEnd`.`FileName."
General::dupsym = "The symbol `1` with context `2` already exists."
General::eival = "Unable to find all roots of the characteristic polynomial."
General::eivec = "Unable to find eigenvector for eigenvalue `1`."
General::eivec0 = "Unable to find all eigenvectors."
General::eivn = "Incorrect number `1` of eigenvectors for eigenvalue `2` with multiplicity `3`."
General::enable = "`1` is not enabled in your version of the Wolfram Language."
General::epoch = "`1` seconds is too far in the future. Try a smaller amount of time."
General::errfile = "The file `1` could not be accessed."
General::estep = "Value of option `1` -> `2` is not a positive integer."
General::exact = "Argument `1` in `2` is not an exact number."
General::existinfo = "\!\(`1`\_x y\) is interpreted as `2`[x, y]."
General::fas = "Warning: one or more assumptions evaluated to False."
General::filro = "The file `1` is read-only."
General::fmtval = "`1` is not a valid format type."
General::fnsym = "First argument in `1` is not a symbol or a string naming a symbol."
General::fstr = "File specification `1` is not a string of one or more characters."
General::globf = "Cannot open object obtained by expansion of `1`."
General::globm = "Too many matches for `1`: `2`."
General::globn = "No matches for `1`."
General::gprim = "`2` was encountered where a `1` primitive or directive was expected."
General::heads = "Heads `1` and `2` at positions `3` and `4` are expected to be the same."
General::heap = "Heap expected at position `2` in `1`."
General::hmdir = "\"~\" should be followed by \"/\": only the current user's home directory is supported."
General::idid = "`1` is not an integration direction specified by Forward or Backward."
General::ifexp = "The exponent `1` is not an integer."
General::ifpa = "The precision or accuracy `1` is not representable as a machine number."
General::ilsm = "List of machine-sized integers expected at position `2` in `1`."
General::ilsmi = "Single or non-empty list of machine-sized integers expected at position `2` in `1`."
General::ilsmn = "Single or list of non-negative machine-sized integers expected at position `2` of `1`."
General::ilsmp = "Single or list of positive machine-sized integers expected at position `2` of `1`."
General::incomma = "`1` is a structural element that is interpreted as an ordinary comma."
General::indet = "Indeterminate expression `1` encountered."
General::indit = "Found dependent indices `1` in Table expression. Array depth may be underestimated.";
General::iti = "Invalid index `1` in iterator `2`.";
General::infy = "Infinite expression `1` encountered."
General::inf = "Input matrix contains an infinite entry."
General::initstate = "`1` cannot be used during initialization."
General::innf = "Non-negative integer or Infinity expected at position `2` in `1`."
General::innfup = "Non-negative integer, Infinity or valid UpTo specification expected instead of `1`."
General::interpfmt = "`1` is not a valid interpretation format. Valid interpretation formats include InputForm and any member of $BoxForms."
General::ipnf = "Positive integer or Infinity expected at position `2` in `1`."
General::ipnfm = "Positive machine-sized integer or Infinity expected at position `2` in `1`."
General::int = "Integer expected at position `2` in `1`."
General::intg = "Integer greater than `3` expected at position `2` in `1`."
General::intinfo = "\!\(\[Integral]f\[DifferentialD]x\) or \!\(\[Integral]f\[CapitalDifferentialD]x\) is interpreted as Integrate[f, x]. \!\(\[Integral]\^b\%a f\[DifferentialD]x\) or \!\(\[Integral]\^b\%a f\[CapitalDifferentialD]x\) is interpreted as Integrate[f, {x,a,b}]."
General::intm = "Machine-sized integer expected at position `2` in `1`."
General::intnm = "Non-negative machine-sized integer expected at position `2` in `1`."
General::intnz = "Nonzero integer expected at position `2` in `1`."
General::intp = "Positive integer expected at position `2` in `1`."
General::intpm = "Positive machine-sized integer expected at position `2` in `1`."
General::intpma = "Positive machine-sized integer or Automatic expected at position `2` in `1`."
General::ioarg = "I/O operation is not valid for `1`."
General::ioerr = "Input/Output operation failed during `1`."
General::eexist = "File `1` already exists."
General::iopf = "Value of option `1` -> `2` should be an integer or Infinity."
General::iopa = "Value of option `1` -> `2` should be an integer or Automatic."
General::iopnf = "Value of option `1` -> `2` should be a non-negative integer or Infinity."
General::iopnm = "Value of option `1` -> `2` should be a non-negative machine-sized integer."
General::ioppm = "Value of option `1` -> `2` should be a positive machine-sized integer."
General::ioppf = "Value of option `1` -> `2` should be a positive integer or Infinity."
General::ioppfa = "Value of option `1` -> `2` should be a positive integer, Infinity, or Automatic."
General::isdir = "Cannot open directory for reading."
General::iterb = "Iterator `1` does not have appropriate bounds."
General::itflrw = "Warning: in evaluating `1` to find the number of iterations to use for `2`, $MaxExtraPrecision = `3` was encountered. An upper estimate will be used for the number of iterations."
General::itform = "Argument `1` at position `2` does not have the correct form for an iterator."
General::nliter = "Non-list iterator `1` at position `2` does not evaluate to a real numeric value."
General::itraw = "Raw object `1` cannot be used as an iterator."
General::ittag = "Cannot use `1` as an iterator since it contains no assignment tag."
General::ivar = "`1` is not a valid variable."
General::lconv = "QR algorithm failed to converge."
General::level = "Level specification `1` is not of the form n, {n}, or {m, n}."
General::list = "List expected at position `2` in `1`."
General::lists = "List of lists expected at position `2` in `1`."
General::stringnz = "String of non-zero length expected at position `2` in `1`."
General::strlist = "List of strings expected at position `2` in `1`."
General::intpa = "Positive integer or Automatic expected at position `2` in `1`."
General::listrp = "List or SparseArray or StructuredArray expected at position `2` in `1`."
General::longp = "Pathname `1` is too long."
General::lrgexp = "Exponent is out of bounds for function `1`."
General::lspec = "`1` is not a valid color, thickness, or dashing specification."
General::luc = "Result for `1` of badly conditioned matrix `2` may contain significant numerical errors."
General::markset = "Cannot set `1` to `2`; value must be True, False, or Automatic."
General::matrix = "Argument `1` at position `2` is not a non-empty rectangular matrix."
General::scalar = "Argument `1` at position `2` is not a scalar."
General::matsq = "Argument `1` at position `2` is not a non-empty square matrix."
General::vector = "Argument `1` at position `2` is not a non-empty vector."
General::vecmat = "Argument `1` at position `2` is neither a non-empty vector nor a non-empty matrix."
General::vecmat1 = "Argument `1` is neither a non-empty vector nor a non-empty matrix."
General::ndims = "The arguments `1` and `2` have incorrect dimensions."
General::targ = "Argument `1` at position `2` is not List or SparseArray."
LeviCivitaTensor::targ = "Argument `1` at position `2` is not List, SparseArray, or SymmetrizedArray."
General::mbox = "MatchBox cannot occur in transformation rule source."
General::mbrpos = "Position `2` in `1` must be one of `3`."
General::meprec = "Internal precision limit $MaxExtraPrecision = `1` reached while evaluating `2`."
General::mext = "Conflicting option setting. If Modulus is not 0, then Extension should be None."
General::mindet = "Input matrix contains an indeterminate entry."
General::nogr = "Unable to render `1` graphics."
General::numnm = "Non-negative machine-sized number expected at position `2` in `1`."
General::modgp = "Value of option `1` -> `2` should be a Gaussian prime number."
General::modint = "Modulus `1` must be an integer."
General::modm = "Modulus `1` is too large for this implementation."
General::modn = "Value of option `1` -> `2` should be an integer."
General::modp = "Value of option `1` -> `2` should be a prime number or zero."
General::mult = "Value of option Multiplicity -> `1` is not a positive integer."
General::munfl = "`1` is too small to represent as a normalized machine number; precision may be lost."
General::nalg = "`1` is not an explicit algebraic number."
General::naobj = "`1` is not a valid AlgebraicNumber object."
General::ncomp = "Unable to decide whether `1` and `2` are equal. Assuming they are."
General::ncompl = "Symbolic or noncomplex numerical arguments are expected."
General::newl = "The newline character after \"`1`\" is understood as a multiplication operator`4`."
General::newsym = "Symbol `1` is new."
General::nfdir = "Directory not found during `1`."
General::dnfnd = "Directory `1` not found."
General::nffil = "File not found during `1`."
General::fnfnd = "File `1` not found."
General::fdnfnd = "Directory or file `1` not found."
General::fdir = "The specified path `1` refers to a directory; a file path was expected."
General::dirf = "The specified path `1` refers to a file; a directory was expected."
General::dirfr = "The directory `1` could not be created because a file of the same name already exists. Please rename the file and try again."
General::errfile = "The file `1` could not be accessed."
General::niupf = "`1` is not an irreducible univariate polynomial function with rational coefficients."
General::nlist3 = "`1` is not a list of three numbers."
General::nmod = "`1` is not valid modulo `2`."
General::nmint = "`1` is not a machine-sized integer."
General::nminti = "`1` is not a machine-sized integer or Infinity."
General::nmint2 = "`1` is not a machine-sized integer, a list of two machine integers, or All."
General::nofe = "A front end is not available. This action requires a front end."
General::nofestart = "Unable to launch a front end. Proceeding without a front end."
General::nomem = "The current computation was aborted because there was insufficient memory available to complete the computation."
General::nonopt = "Options expected (instead of `1`) beyond position `2` in `3`. An option must be a rule or a list of rules."
General::nonopt1 = "Options expected (instead of `1`) beyond position `2` in `3`."
General::noopen = "Cannot open `1`."
General::nord = "Invalid comparison with `1` attempted."
General::nord2 = "Comparison of `1` and `2` is invalid."
General::nordol = "`1` and `2` cannot be compared because they are overlapping."
General::nordq = "Invalid comparison of quantities `1` and `2` with incompatible units."
VectorGreater::vord = VectorGreaterEqual::vord = VectorLess::vord = VectorLessEqual::vord = "Vector comparison with `1` includes invalid inequality comparisons with complex values."
VectorGreater::vord2 = VectorGreaterEqual::vord2 = VectorLess::vord2 = VectorLessEqual::vord2 = "Vector comparison of `1` and `2` requires element comparisons that are not valid."
VectorGreater::vordol = VectorGreaterEqual::vordol = VectorLess::vordol = VectorLessEqual::vordol = "Vector comparison of `1` and `2` includes comparisons of elements that are overlapping."
VectorGreater::vordq = VectorGreaterEqual::vordq = VectorLess::vordq = VectorLessEqual::vordq = "Vector comparison of `1` and `2` includes comparisons of elements with incompatible units."
General::normal = "Nonatomic expression expected at position `1` in `2`."
General::normal1 = "Expression `1` at position `2` is expected to have nonatomic subexpression at level `3`."
General::nosym = "`1` does not contain a symbol to attach a rule to."
General::notfound = "Symbol `1` not found."
General::notnorm = "Argument `1` must be a nonatomic expression."
General::notstr = "The format type `1` is valid only for string input."
General::noval = "Symbol `1` in part assignment does not have an immediate value."
General::npad = "Value for option NumberPadding -> `1` should be a string or a pair of strings."
General::npdir = "`1` has no parent directory."
General::npoly = "`1` is not a polynomial with rational number coefficients."
General::npolys = "`1` is not a list of polynomials with rational number coefficients."
General::npt = "Value for option `1` -> `2` is expected to be a string."
General::nptg = "Value for option `1` -> `2` is expected to be a `3`."
General::nptn = "Value for option `1` -> `2` is expected to be a number."
General::nsdims = "Matrices `1` and `2` must have the same number of rows and columns."
General::nsgn = "Value for option NumberSigns -> `1` should be a pair of strings or two pairs of strings."
General::nspr = "Value for option NumberSeparator -> `1` should be a string or a pair of strings."
General::num = "Argument `1` should be a number."
General::numberm = "Machine-sized number expected at position `2` in `1`."
General::nupf = "`1` is not a univariate polynomial function with rational coefficients."
General::openr = "`1` is open for input."
General::openw = "`1` is open for output."
General::openx = "`1` is not open."
General::optlist = "Value of option `1` -> `2` should be a list."
General::obs = "`1` has been superseded by `2`, and is now obsolete. It will not be included in future versions of the Wolfram Language."
General::opset = "Option `1` is not set in `2`."
General::opstl = "Value of option `1` -> `2` should be a string or a list of strings."
General::optb = "Optional object `1` in `2` is not a single blank."
General::optrs = "Option specification `1` in `2` is not a rule for a symbol or string."
General::patc = "Mixed operation with SparseArrays of explicit values and pattern type will result in a SparseArray of pattern type without explicit values."
General::moptrs = "Method option specification `1` in `2` is not a rule for a symbol or string."
General::moptconfl = "Value of option `1` at top level of `2` conflicts with its value in Method options `3`."
General::opttf = "Value of option `1` -> `2` should be True or False."
General::optpn = "The value of `1` -> `2` should be a positive machine-sized real number."
General::optpr = "The value of `1` -> `2` should be a positive real number."
General::opttfa = "Value of option `1` -> `2` should be True, False, or Automatic."
General::opttfna = "Value of option `1` -> `2` should be True, False, None, or Automatic."
General::tflist = "Value of option `1` -> `2` should be True, False, or a list of two such values."
General::optstr = "Value of option `1` -> `2` should be a string."
General::optv = "Value of option `1` in `2` is not valid."
General::optvg = "Value of option `1` -> `2` should be `3`."
General::optvp = "Invalid option value at position `1` in `2`. Allowed values are `3`."
General::optx = "Unknown option `1` in `2`."
General::moptx = "Method option `1` in `2` is not one of `3`."
General::ovfl = "Overflow occurred in computation."
General::par = "Inappropriate parameter: `1` -> `2`."
General::partd = "Part specification `1` is longer than depth of object."
General::partd1 = "Depth of object `1` is not sufficient for the given part specification."
General::partialinfo = "\!\(`1`\_x y\) is interpreted as `2`[y, x]."
General::partw = "Part `1` of `2` does not exist."
General::keyw = "Key `1` does not exist in `2`."
General::patop = "Pattern `1` contains inappropriate optional object."
General::pcolor = "The shading function has produced colors of different types."
General::plln = "Limiting value `1` in `2` is not a machine-sized real number."
General::poly = "`1` is not a polynomial."
General::polyx = "`1` is not a polynomial with exact coefficients."
General::precbd = "Requested precision `1` is not a machine-sized real number between $MinPrecision and $MaxPrecision."
General::preclg = "Requested precision `1` is larger than $MaxPrecision. Using current $MaxPrecision of `2` instead. $MaxPrecision = Infinity specifies that any precision should be allowed."
General::precsm = "Requested precision `1` is smaller than $MinPrecision. Using $MinPrecision instead."
General::int32 = "Operation in `1` not supported for machine integer parameters greater than 2147483647."
General::len32 = "Operation in `1` not supported for total length exceeding 2147483647."
General::dim32 = "Operation in `1` not supported when any dimension exceeds 2147483647."
NDSolve::precw = NDSolveValue::precw = ParametricNDSolve::precw = ParametricNDSolveValue::precw = NDSolve`ProcessEquations::precw = "The precision of the differential equation (`1`) is less than WorkingPrecision (`2`)."
NDSolve`Reinitialize::precw = "The precision of the initial condition (`1`) is less than WorkingPrecision (`2`)."
FindFit::precw = NonlinearModelFit::precw = "The precision of the data and model function (`1`) is less than the specified WorkingPrecision (`2`)."
General::precw = "The precision of the argument function (`1`) is less than WorkingPrecision (`2`)."
General::primm = "Tried `1` primes; algorithm failed."
General::prims = "Prime `1` is too small; algorithm failed."
General::privv = "Privilege violation for file or directory `1`."
General::pspec = "Part specification `1` is neither a machine-sized integer nor a list of machine-sized integers."
General::pspec1 = "Part specification `1` is not applicable."
General::pkspec = "The expression `1` cannot be used as a part specification. Use Key[`1`] instead."
General::pkspec1 = "The expression `1` cannot be used as a part specification."
General::pmix = "Integer and Key specifications cannot be mixed in `1`."
General::psl = "Position specification `1` in `2` is not a machine-sized integer or a list of machine-sized integers."
General::psl1 = "Position specification `1` in `2` is not applicable."
General::pvec = "Unable to find principal vectors for eigenvalue `1`."
General::rawvar = "Parameter `1` in `2` is a raw expression and cannot be used as a variable."
General::rdeg = "`1` computation failed due to inability to use roots of the polynomial `2` of degree `3`, which exceeds $MaxRootDegree. Increasing the value of $MaxRootDegree may allow `1` to succeed."
General::readp = "Symbol `1` is read-protected."
General::real = "Argument `1` should be a real number."
General::mepreal = "In attempting to decide whether a solution `1` is real, $MaxExtraPrecision `2` was encountered. The solution was assumed real. Increasing the value of $MaxExtraPrecision may help resolve the uncertainty."
General::sandbox = "The operation `1` is not allowed while running in sandbox mode."
General::sandboxfl = "The operation `1` is not allowed to access the file `2` while running in sandbox mode."
General::sandboxfd = "`1` is not a valid file or directory path."
General::span = "`1` is not a valid Span specification. A Span specification should be 1, 2, or 3 machine-sized integers separated by ;;. (Any of the integers can be omitted or replaced with All.)"
General::strval = "The value can only be changed to a string."
Dot::rect = Tr::rect = "Nonrectangular tensor encountered."
General::rect = "Nonrectangular array encountered."
General::rectn = "Rectangular array of real numbers is expected at position `2` in `1`."
General::rectt = "Rectangular array expected at position `2` in `1`."
General::remote = "`1` cannot write an output file since the front end and kernel do not share a common file system."
General::rnum = "`1` is not a valid root number."
General::rvalue = "`1` is not a variable with a value, so its value cannot be changed."
General::rvalue1 = "The value of `1` cannot be changed."
General::kval = "The value for the key `1` does not exist."
General::seqso = "Sequence specification (+n, -n, {+n}, {-n}, or {m, n}) expected at position `2` in `1`."
General::seqs = "Sequence specification (+n, -n, {+n}, {-n}, {m, n}, or {m, n, s}) expected at position `2` in `1`."
General::setp = "Part assignment to `1` could not be made."
General::setps = "`1` in the part assignment is not a symbol."
General::shdw = "Symbol `1` appears in multiple contexts `2`; definitions in context `3` may shadow or be shadowed by other definitions."
General::shdwcor = "Symbol `1` defined in `2` already exists in `3`. Select the version you want to use: `4`."
General::shlen = "The argument `1` should have at least two elements."
General::sign = "Unable to determine the sign of `1`. The expression was assumed to be zero. Increasing the value of $MaxExtraPrecision may help resolve the uncertainty."
General::sing = "Matrix `1` is singular."
General::sntx = "Invalid syntax in or before \"`1`\"`4`."
General::sntxb = "Expression cannot begin with \"`1`\"`4`."
General::sntxc = "The comment starting at \"`1`\" has no closing \"*)\"`4`."
General::sntup = "Unexpected end of file (probably unclosed parenthesis) `4`."
General::sntue = "Unexpected end of file (probably unfinished expression) `4`."
General::sntxf = "\"`1`\" cannot be followed by \"`2`\"`4`."
General::sntxi = "Incomplete expression; more input is needed `4`."
General::sntxpi = "Incomplete expression in result of $PreRead `4`."
General::sntxpr = "Invalid syntax in result of $PreRead."
General::sntxq = "The string starting at \"`1`\" has no closing quote `4`."
General::spell = "New symbol name \"`1`\" is similar to existing symbols `2` and may be misspelled."
General::spell1 = "New symbol name \"`1`\" is similar to existing symbol \"`2`\" and may be misspelled."
General::ssle = "Symbol, string, or HoldPattern[symbol] expected at position `2` in `1`."
General::stmtype = "FormatType option of stream `1` cannot be set to `2`. Use a string-based format such as OutputForm."
General::stop = "Further output of `1` will be suppressed during this calculation."
General::strbox = "`1` is an operator for representing textual boxes in strings."
General::stream = "`1` is not a string, SocketObject, InputStream[ ], or OutputStream[ ]."
General::string = "String expected at position `1` in `2`."
General::strx = "String expected instead of `1`."
General::strfile = "String or valid File object is expected at position `1` in `2`. A valid File has the form File[string]."
General::stringopt = "`1` in `2` is not a string. All options to `3` must be strings."
General::strmi = "First argument in `1` is not a valid file or string identifier."
General::strml = "`1` is not a string, stream, or list of strings and streams."
General::strmn = "Requested stream `1` does not match existing stream `2` with the same stream number."
General::strmerr = "Error on stream `1`. Error message: `2`"
General::strpatt = "String or string pattern is expected at position `1` in `2`."
General::strpatts = "String, string pattern or list of such is expected at position `1` in `2`."
General::strs = "String or non-empty list of strings is expected at position `1` in `2`."
General::strse = "String or list of strings expected at position `1` in `2`."
General::strsn = "Non-empty string or non-empty list of strings expected at position `1` in `2`."
General::suminfo = "\!\(`1`\^i\%imax f\) is interpreted as `2`[f, {i,imax}]."
General::sym = "Argument `1` at position `2` is expected to be a symbol."
General::sysname = "`1` is not a known SystemOption."
General::sympatt = "Symbol or symbol pattern expected at position `1` in `2`.";
General::systrg = "`1` is not a string. SystemOptions must be strings."
General::tag = "Rule for `1` of `2` can only be attached to `3`."
General::tolset = "Cannot set `1` to `2`; value must be a real number or +/- Infinity."
General::toomany = "The length of the output of `1` should be a machine integer."
General::trace = "`1` --> `2`."
General::tsntxi = "\"`1`\" is incomplete; more input is needed.`4`"
General::uinfix = "An infix operator. \!\(x `1` y\) is by default interpreted as \!\(`2`[x, y]\)."
General::unavail = "`1` is not available in this version of the Wolfram Language."
General::unfl = "Underflow occurred in computation."
General::uniclose = "`1` is a closing matchfix operator."
General::uniopen = "`1` is an opening matchfix operator."
General::unique = "There is more than one occurrence of `1` in `2`. `1` is required to be unique."
General::unuser = "Unknown user: `1`."
General::uprefix = "A prefix operator. \!\(`1` x\) is by default interpreted as \!\(`2`[x]\)."
General::upreinfix = "An infix and prefix operator. \!\(x `1` y\) is by default interpreted as \!\(`2`[x, y]\) ; and \!\(`1` x\) is by default interpreted as \!\(`2`[x]\)."
General::write = "Tag `1` in `2` is Protected."
General::wrsym = "Symbol `1` is Protected."
General::rpsym = "Symbol `1` is ReadProtected."
General::ztest1 = "Unable to decide whether numeric quantity `1` is equal to zero. Assuming it is."
General::ztest = "Unable to decide whether numeric quantities `1` are equal to zero. Assuming they are."
General::zval = "Non-numerical value `1` found at position `2` in the first argument."
General::unpack = "Unpacking array in call to `1`."
General::punpack = "Unpacking array with dimensions `2` in call to `1`."
General::punpack1 = "Unpacking array with dimensions `1`."
General::punpackl = "Unpacking array with dimensions `3` to level `2` in call to `1`."
General::punpackl1 = "Unpacking array with dimensions `2` to level `1`."
General::colfun= "ColorFunction `1` does not produce a valid color or gray-level directive when applied to element `2`."
General::colfun1= "ColorFunction `1` produces a color incompatible with the previous color when applied to element `2`."
General::rep = "`1` is not a valid replacement rule."
General::addsyms = "Autoloading file `1` added symbols `2`."
General::autoload = "Symbol `1` has autoloading rules attached to load `2`; these rules are disabled by the setting of $AutoLoad to False. The package can be loaded with Get and the evaluation repeated."
General::badsys1 = "File `1` returned symbols `2` that did not match the declared symbol list `3`."
General::badsys2 = "Loading file `1` has removed these system definitions: `2`."
General::badsys3 = "Loading file `1` has added system definitions `2` that were not specified in the symbol list for that file."
General::badsys4 = "Loading file `1` returned `2`; it should return a list of the exported symbols."
General::sysfile = "Binary file loading of package `1` by symbol `2` failed."
General::dupv = "Duplicate variable `1` found in `2`."
General::blnotn = "The value of the argument `1` in position `2` is not a number."
General::blncorr = "The value of the argument `1` in position `2` is incorrect."
General::blwarg = "The output argument `1` in position `2` is inconsistent with the input argument(s)."
General::blndim1= "The argument `1` in position `2` has incorrect dimension(s)."
General::blrank = "The argument `1` evaluates to rank `2`. Rank `3` is expected."
General::blrank1 = "The argument `1` evaluates to rank `2`. Rank `3` or `4` is expected."
General::blnotsym = "The argument `1` at position `2` should not contain any symbol for which no numerical value is defined."
General::bltfv = "The argument `1` at position `2` should be a list of True or False."
LinearAlgebra`LAPACK`LANV2::blnsym1 = "The input arguments cannot be symbols for which no numerical values are defined."
LinearAlgebra`LAPACK`LANV2::blcmplx = "The input arguments cannot be complex numbers."
General::blnoval = "The symbol `1` at position `2` should have an immediate value defined."
General::blscas = "The argument `1` should be a symbol that has a scalar immediate value."
General::bldim = "The arguments `1` and `2` do not have compatible dimensions."
General::bldim1 = "The argument `1` should be a matrix of dimensions `2` by `3`."
General::blveclen = "The argument `1` should be a vector of length `2`."
General::blnotsq = "The argument `1` does not have the first dimension at least as large as the second dimension."
General::blnsetst = "The argument `1` at position `2` is not a string starting with one of the letters from the set `3`."
General::blnulst = "The argument `1` at position `2` must be a non-empty string."
General::blreal = "The argument `1` cannot be of complex type."
General::blnegn = "The argument `1` should be non-negative."
General::blnmpre = "Argument in `1` is not a positive real number or MachinePrecision symbol."
LinearAlgebra`BLAS`TestArgument::blapos = "The second argument `1` should be an integer that gives the argument position in `2` to test."
LinearAlgebra`BLAS`TestArgument::bltrank = "The required tensor rank `1` should be 0, 1, 2, or _."
General::blintli = "The argument `1` should have integer elements only."
General::blincor = "The arguments `1` and/or `2` are incorrect."
LinearAlgebra`LAPACK`PivotToPermutation::blnotpiv = LinearAlgebra`LAPACK`LASWP::blnotpiv = "The pivot vector `1` is incorrect."
LinearAlgebra`LAPACK`LARTG::blneqsym = "You cannot use the same symbol `1` in positions `2` and `3`."
LinearAlgebra`LAPACK`GESVX::blinstlu = "Warning: the LU factorization of the matrix `1` at position `2` can be unstable, and the solution of the system can be unreliable."
General::notperm = "The permutation vector `1` is incorrect."
General::accg = "Value of option AccuracyGoal -> `1` is not Automatic, Infinity, or a machine-sized real or integer."
General::precg = "Value of option PrecisionGoal -> `1` is not Automatic, Infinity, or a positive machine-sized integer or real."
General::specset = "Cannot change the value of special symbol `1`."
General::wprec = "Value of option WorkingPrecision -> `1` is not a positive machine-sized real or integer."
General::wprecai = "Value of option WorkingPrecision -> `1` is not Automatic, Infinity, or a positive machine-sized real or integer."
General::agpginf = "Both Accuracy and Precision goals are sufficiently large to allow effectively zero tolerance. The numerical algorithm cannot solve the problem exactly."
GeneratingFunction::div = ExponentialGeneratingFunction::div = "The generating function does not converge."
Get::enkey = "Cannot decode encoded file; incorrect key or machine."
Get::notencode = "Warning: the file `1` is not encoded."
Get::stringorstream = "The value of `1` is not a file name or a stream."
General::path = "`1` in $Path is not a string."
Goto::nolabel = "Label `1` not found."
Graphics::gpt = "Coordinate `1` is not of the form {x, y}."
Graphics::gptn = "Coordinate `1` in `2` is not a floating-point number."
Graphics::hue = "`1` is not of length 1 or 3."
Graphics::realp = "Argument in `1` is not a positive real number."
Graphics::realu = "Argument in `1` is not a real number between 0 and 1."
Graphics::terminal = "Load JavaGraphics.m or Terminal.m for rendering graphics with a stand-alone kernel."
Graphics3D::ambnt = "Value of option `1` -> `2` is not a valid GrayLevel or RGBColor specification."
Graphics3D::boxz = "Box for 3D graphics has zero size."
Graphics3D::gsing = Plot3D::gsing = "Singular homogeneous transformation generated."
Graphics3D::gsort = "More than 10^9 polygons to sort."
Graphics3D::lights = "Value of option `1` -> `2` is not of the form {{pos, col}, {pos, col}, ...}."
Graphics3D::ltcol = "Element `1` in LightSources option contains `2`, which is not a valid GrayLevel or RGBColor directive."
Graphics3D::psvf = "Function value at x = `1`, y = `2` was sent to infinity by perspective transformation."
Graphics3D::p3mat = "Value of Plot3Matrix -> `1` is not a 4 x 4 numerical matrix."
GraphicsArray::obs = "GraphicsArray is obsolete. Switching to GraphicsGrid."
GraphicsArray::arrsp = "Value of option GraphicsSpacing -> `1` should be a number greater than 0 or a list of two such numbers."
GraphicsArray::prim = "Argument to GraphicsArray, `1`, should be a vector or a matrix of graphics objects."
GridLines::grid = "`1` is not a valid grid specification."
GroebnerBasis::badcf = GroebnerBasis`GroebnerWalk`GroebnerWalk::badcf = GroebnerBasis`Interreduce::badcf = PolynomialReduce::badcf = GroebnerBasis`DistributedTermsList::badcf = "Encountered bad coefficient `1`."
GroebnerBasis::coef = GroebnerBasis`GroebnerWalk`GroebnerWalk::coef = GroebnerBasis`Interreduce::coef = PolynomialReduce::coef = GroebnerBasis`DistributedTermsList::coef = "Value of option CoefficientDomain -> `1` is not valid."
GroebnerBasis::elmvar = GroebnerBasis`GroebnerWalk`GroebnerWalk::elmvar = GroebnerBasis`Interreduce::elmvar = PolynomialReduce::elmvar = GroebnerBasis`DistributedTermsList::elmvar = "Term ordering `1` is not compatible with elimination variables."
GroebnerBasis::fltgb = GroebnerBasis`GroebnerWalk`GroebnerWalk::fltgb = PolynomialReduce::fltgb = GroebnerBasis`DistributedTermsList::fltgb = "Excessive loss of precision during computation."
GroebnerBasis::intgb = GroebnerBasis`GroebnerWalk`GroebnerWalk::intgb = GroebnerBasis`Interreduce::intgb = PolynomialReduce::intgb = GroebnerBasis`DistributedTermsList::intgb = "Nontrivial denominator in `1` is invalid input for `2` over the integers."
GroebnerBasis::mnmord1 = GroebnerBasis`GroebnerWalk`GroebnerWalk::mnmord1 = GroebnerBasis`Interreduce::mnmord1 = PolynomialReduce::mnmord1 = GroebnerBasis`DistributedTermsList::mnmord1 = "Value of option MonomialOrder -> `1` is not valid."
CoefficientRules::mnmord1 = MonomialList::mnmord1 = "`1` is not a valid monomial order."
GroebnerBasis::mnmord2 = GroebnerBasis`GroebnerWalk`GroebnerWalk::mnmord2 = GroebnerBasis`Interreduce::mnmord2 = PolynomialReduce::mnmord2 = GroebnerBasis`DistributedTermsList::mnmord2 = CoefficientRules::mnmord2 = MonomialList::mnmord2 = "`1` does not order all terms formed from variables `2`."
GroebnerBasis::modflt = GroebnerBasis`GroebnerWalk`GroebnerWalk::modflt = GroebnerBasis`Interreduce::modflt = PolynomialReduce::modflt = GroebnerBasis`DistributedTermsList::modflt = "Cannot specify nonzero modulus when working with inexact coefficients."
GroebnerBasis::pdvar2 = GroebnerBasis`GroebnerWalk`GroebnerWalk::pdvar2 = GroebnerBasis`Interreduce::pdvar2 = PolynomialReduce::pdvar2 = GroebnerBasis`DistributedTermsList::pdvar2 = "The polynomial domain variable `1` is improperly used in polynomial `2`."
GroebnerBasis::poly2 = GroebnerBasis`GroebnerWalk`GroebnerWalk::poly2 = GroebnerBasis`Interreduce::poly2 = PolynomialReduce::poly2 = GroebnerBasis`DistributedTermsList::poly2 = Resultant::poly2 = Discriminant::poly2 = "`1` is not a well-formed polynomial in `2`."
GroebnerBasis::wgtmat1 = GroebnerBasis`GroebnerWalk`GroebnerWalk::wgtmat1 = GroebnerBasis`Interreduce::wgtmat1 = PolynomialReduce::wgtmat1 = GroebnerBasis`DistributedTermsList::wgtmat1 = CoefficientRules::wgtmat1 = MonomialList::wgtmat1 = "`1` is not a valid weight matrix."
GroebnerBasis::wgtmat2 = GroebnerBasis`GroebnerWalk`GroebnerWalk::wgtmat2 = GroebnerBasis`Interreduce::wgtmat2 = PolynomialReduce::wgtmat2 = GroebnerBasis`DistributedTermsList::wgtmat2 = "Weight matrix based on variable list `1` is invalidated by the internal variable list `2`."
FromCoefficientRules::plen = "Lists `1` and `2` must have the same length."
FromCoefficientRules::cstruct = "The coefficient list `1` does not have the correct structure."
GroebnerBasis`GroebnerWalk`GroebnerWalk::gmeth1 = GroebnerBasis::gmeth1 = "Recursive use of `1` is invalid."
GroebnerBasis`GroebnerWalk`GroebnerWalk::gmeth2 = GroebnerBasis::gmeth2 = "Value of option Method -> `1` should be Automatic, \"Buchberger\", or \"GroebnerWalk\"."
GroebnerBasis`GroebnerWalk`GroebnerWalk::gstrat = GroebnerBasis::gstrat = "Value of option SelectionStrategy -> `1` should be \"SimulatedHomogenization\", \"NormalSelection\", or None."
GroebnerBasis`GroebnerWalk`GroebnerWalk::parmvar = "Use weight matrix instead of parameter(s) `1`."
HankelMatrix::crs = ToeplitzMatrix::crs = "Warning: the column element `1` and row element `2` at positions `3` and `4` are not the same. Using column element."
HermiteDecomposition::latm = LatticeReduce::latm = SmithDecomposition::latm = "Matrix contains an entry that is not rational."
HorizontalForm::precd = VerticalForm::precd = "Precedence list `1` is not of the form {head, prec, assoc, ...}."
Save::wtype = "`1` in `2` must be a symbol, a string, or a list of symbols and strings."
ImportExport`RegisterFormat::erropts = "The value of option `1` -> `2` is invalid."
ImportExport`RegisterFormat::noexe = "Could not install `1`."
ImportExport`RegisterImport::fmt = ImportExport`RegisterExport::fmt = "The format `1` is not registered. Use RegisterFormat[] first."
ImportExport`RegisterImport::fch = ImportExport`RegisterExport::fch = "The value of option `1` is invalid. Using default value of `2`."
Import::nffil = "File `1` not found during `2`."
Import::charcode = ImportString::charcode = Export::charcode = ExportString::charcode = "`1` is not a valid character encoding. Possible settings are the names given by $CharacterEncodings or None."
General::erropts = "The value `1` specified for the option `2` is invalid."
Export::erropts2 = "The value of option `1` -> `2` is invalid when exporting the set of elements `3`."
Export::erropts3 = "The value `1` specified for the option `2` is invalid and will be ignored."
Export::invopt = "The option `1` is invalid when exporting the element `2`."
Export::invopt2 = "The option `1` is invalid when exporting the set of elements `2`."
Import::invopt = "The option `1` is invalid when importing the element `2`."
Export::noopts = "The Export option `1` is invalid for the `2` format."
Export::errstruct = Import::errstruct = "Malformed data structure `1`"
Export::h5error = Import::h5error = "Could not execute HDF5 interface operation \"`1`\"; returned code `2`."
Export::obs = Import::obs = "`1` is obsolete."
Export::convoptobs = ExportString::convoptobs = Import::convoptobs = ImportString::convoptobs = ImportByteArray::convoptobs = ExportByteArray::convoptobs = "ConversionOptions is obsolete. See the `1` format page for available options."
Export::unsupfmt = Import::unsupfmt = "The `1` format is not available on this platform."
Import::coerr = Export::coerr = "Invalid setting `1` -> `2`."
Import::infer = Export::infer = "Cannot infer format of file `1`."
Import::elemstx = Export::elemstx = ImportString::elemstx = ExportString::elemstx = "`1` is not a valid format or element specification. Expecting a string, list, or integer."
Import::image = Export::image = ExportString::image = "Value of option `1` -> `2` is not a list of two numbers or Automatic."
Import::htmlimg = "Some images could not be imported."
Import::phpiniparsingerror = "Cannot import lines: `1`."
Import::iniparsingerror = "Cannot import lines: `1`. Try using the \"PHPIni\" format."
Import::iniparsinghint = "First line(s) in error: `1`"
Export::invinivalue = "Cannot export as `1`. Expecting an association or a list."
Export::imgseqtype = "`1` is neither a list of images or graphics nor an animation object."
Export::imgseqfmt = "`1` is not an export format supported by \"VideoFrames.\""
Export::badval = "The element `1` contains invalid values."
Export::bitcon = "BITPIX options, `1`, and BITPIX in header, `2`, have conflicting values. Using header value."
Export::bitrange = "BITPIX value `1` does not cover the data range. Try using `2`."
Export::bitval = "BITPIX value `1` is not a valid value."
Export::chtype = "First argument `1` is not a valid file specification."
Export::createdir = "Export assumed `1` to be a directory into which to write an index.html file, but was unable to create this directory. Either create this directory and rerun HTMLSave, or choose a different destination for the HTML file."
Export::dffsr = "Cannot export a sound with multiple sample rates."
Export::dupelem = "The elements contain duplicate data for the `1` format."
Export::errdtmodel = "`1` is not a valid discrete-time state-space model."
Export::errelem = "The Export element `1` contains a malformed data structure and could not be exported to `2` format."
Export::errframe = "`1` cannot be converted to a video frame."
Export::dffimgsize = "Cannot export images of different dimensions to video."
Export::range = "The element `1` contains data that is out of range."
Export::fmterr = "Invalid `1` format."
Export::format = "`1` is not a recognized Export format."
Export::dtaexist = "Could not append to the file because the dataset \"`1`\" already exists."
Export::h5noauto = "Could not coerce the expression into an array of integers or reals."
Export::noauto = "Could not coerce the expression into an array of integers or reals."
Export::noscaled = "Cannot export scaled coordinate specifications to `1` format."
Export::nobcurve = "Omitting BezierCurve and BSplineCurve objects when exporting Graphics3D to `1` format."
Export::incom = "Length `2` of list of expressions `1` does not match length `4` of list of elements `3`."
Export::ignore = "Ignoring `1` because it does not match the `2` format."
Export::inselem = "There are insufficient elements to export to `1` format."
Export::inselem2 = "There are insufficient elements in `1` to export to the specified format."
Export::int = "Warning: sparse array `1` to be exported in `2` format has integer entries. They will be converted to real entries."
Export::uneqlen = "Elements `1` and `2` must have the same length."
Export::memavail = "Could not allocate memory for export of `1` format."
Export::no2dgr = "Two-dimensional graphics objects cannot be exported to `1` format. `1` format may be used for three-dimensional graphics."
Export::nocomp = "The given data cannot be exported to `1` format in compressed form. The data will be exported without compression."
Export::nodta = "`1` contains no data that can be exported to the `2` format."
Export::nodir = AudioCapture::nodir = SpeechSynthesize::nodir = AudioRecord::nodir = AudioStream::nodir = "Directory `1` does not exist."
Export::nodirsup = "Cannot export `2` format to directory `1`."
Export::comperr = "Cannot compress `1` as `2` format."
Export::noncompelem = "`1` is not compatible with `2`."
Export::noelem = "`1` is not a valid set of export elements for the `2` format."
Export::nofile = "Filenames were not specified for Export to the `1` format."
Export::nofe = "A front end is not available; export of `1` requires a front end."
Export::nomatch = "Expression `1` does not match the format `2`."
Export::rasterr = "An unrecoverable error was encountered when rasterizing."
Export::exifset = "The Exif entries should be a list of rules."
Export::exiftag = "`1` is not a recognized Exif tag. This Exif entry will be ignored."
Export::exifval = "The value `2` specified for Exif tag \"`1`\" is invalid. This Exif entry will be ignored."
Export::invjavapropvalue = "Cannot export `1`. Expecting an association or a list."
Export::invbson = "The expression `1` could not be encoded as BSON."
Export::general = "`1`"
Import::general = "`1`"
General::obsalt = "`1` is obsolete. Instead, use `2`."
General::obsalt2 = "`1` will soon be obsolete. Instead, use `2`."
Export::optvmtx = "`1` is not a valid value for \"MatrixStructure\". Acceptable values are \"Unsymmetric\", \"Symmetric\", \"SkewSymmetric\", \"Hermitian\", and \"Rectangular\". \"MatrixStructure\" -> \"Unsymmetric\" is assumed."
Export::optsymmtx = "Option \"MatrixStructure\" -> \"Symmetric\" is specified, but the matrix `1` is not symmetric."
Export::optzmtx = "Option \"MatrixStructure\" -> \"SkewSymmetric\" is specified, but the matrix `1` is not skew symmetric."
Export::optcmtx = "Option \"MatrixStructure\" -> \"Hermitian\" is specified, but the matrix `1` is not Hermitian."
Export::optcc = "Option \"MatrixStructure\" -> \"Hermitian\" is specified, but the matrix `1` is not complex. Using \"MatrixStructure\" -> \"Symmetric\" instead."
Export::padbits = "Padding bits with zeros to create an integer number of bytes."
Export::rank = "The sparse array `1` to be exported in `2` format is not a matrix of rank 2."
Export::smtcsml = "Cannot infer semantics from MathML presentation elements in `1`."
Export::sndprm = "Cannot export sound to `1` using the specified settings."
Export::toomany1 = "Cannot export to `1`. The number of polygons exceeds the limit of this format."
Export::toomany2 = "Cannot export to `1`. The number of vertices exceeds the limit of this format."
Export::toomany3 = "Cannot export to `1`. The number of columns exceeds the limit of this format."
Export::toomany4 = "Cannot export to `1`. The number of color primitives exceeds the limit of this format."
Export::toomany5 = "Cannot export to `1`. The number of rows exceeds the limit of this format."
Export::toobig = "Cannot export to `1`. The size of the data exceeds the limit of this format."
Export::type = ExportString::type = ExportByteArray::type = "`1` cannot be exported to the `2` format."
Export::autofix = "Malformed symbolic XML expression encountered. This may result in unexpected XML data."
Export::badqte = "The quote character `1` is not a valid attribute quoting character. Attributes in the exported XML will be surrounded with single quotes."
Export::malsxml = "Malformed symbolic XML `1` expression may result in an invalid XML file."
Export::unrecov = "Could not export symbolic XML expression."
Export::xmlmal = "Malformed symbolic XML expression `1` encountered in export."
Export::xmlnopt = "An option was expected instead of `1` when exporting the symbolic XML expression `2`."
Export::xmloptv = "The value of option `1` in `2` is not valid in the exporting of the symbolic XML expression `3`."
Export::xmloptx = "Unknown option `1` encountered in the exporting of the symbolic XML expression `2`."
Export::im = "Expecting an image, a list, or an association instead of `1`."
Export::tbl = "Expecting an ASCII or a binary table instead of `1`."
Export::dims = "Expecting a full array of commensurate images instead of `1`."
Export::compr = "Expecting Automatic, None, \"GZIP\", \"GZIPShuffled\", \"HCompress\", \"PLIO\", or \"Rice\" instead of `1`."
Export::dthr = "Expecting Automatic, None, \"SubtractiveDithering\", or \"SubtractiveDitheringPreserved\" instead of `1`."
Export::offset = "Expecting Automatic or an integer between 1 and 10000 instead of `1`."
Export::posreal = "Expecting a positive number instead of `1`."
Export::qlevel = "Expecting Automatic or a positive number between 0 and 16 instead of `1`."
Export::fitsspcr = "Cannot export to a FITS file containing \"[\" or \"(\" characters in the file name.";
Export::fits = "Failed to create a new HDU to export `1`."
Export::fnhdu = "Failed to export meta information to HDU `1`."
Export::fcompr = "Failed to compress data to a FITS file." 
Export::fcomprp = "\"PLIO\" compression can only be used for a two dimensional image data containing positive integers with values up to 2^24."
Export::mtdmand = "FITS mandatory keywords cannot be modified. `1` will be ignored."
Export::metainf = "Expecting Automatic or an indexed association instead of `1`."
Export::fitsprim = "The primary HDU must store image data."
Export::badtbl = "`1` cannot be interpreted as table data."
Export::badim = "`1` cannot be interpreted as image data."
Export::strkey = "Expecting a string value as the \"MetaInformation\" key instead of `1`."
Export::invalidpythonexpr = "The expression `1` could not be encoded as a Python literal expression."
Export::httpreqdom = "Cannot export `1`. The domain is invalid."
Export::h5tns = "Datatype `1` cannot be exported to HDF5."
Export::h5ue = "Expression `1` cannot be exported to HDF5."
Export::h5ce = "`1` cannot be empty when exporting to HDF5."
Export::h5cmt = "Cannot deduce member type from `1`."
Export::h5cmns = "Expecting a String instead of `1`."
Export::h5cmnr = "Expecting a Rule instead of `1`."
Export::h5cct = "Could not deduce common compound type. Candidates: `1`."
Export::h5abt = "Could not deduce array base type for array `1`."
Export::h5aet = "Array element `1` has different type than previous elements (`2`)."
Export::h5ntp = "`1` is not a valid path to a named datatype."
Export::h5if = "Cannot infer data format for `1`. `2`"
Export::h5gzipip = "Expecting an integer between 0 and 9 instead of `1`."
Export::h5enys = "`1` is not supported when exporting to HDF5."
Export::h5ies = "Invalid encoding specification \"`1`\"."
Export::h5epf = "Cannot create data encoding property \"`1`\"."
Export::h5mdts = "Each element of \"MaxDimensions\" must be greater or equal to the corresponding element of \"Data\" dimensions."
Export::h5mdlts = "The list in \"MaxDimensions\" -> `1` must be of length `2`."
Export::h5mdbe = "Expecting a positive integer, Infinity or a list thereof for \"MaxDimensions\" instead of `1`."
Export::h5mbc = "DataLayout \"`1`\" is only valid when \"MaxDimensions\" are Automatic and \"DataEncoding\" is set to None."
Export::h5ncy = "Chunking is not supported."
Export::h5ils = "Expecting Automatic, \"Contiguous\", \"Compact\", \"Chunked\" or a list of positive integers instead of `1`."
Export::h5lpf = "Could not create data layout property \"`1`\"."
Export::h5isf = "\"SaveFormat\" expects None or a valid HDF5 path instead of `1`."
Export::h5ids = "At least one element in the specification of `1` is invalid. The dataset will not be exported."
Export::h5dsae = "Dataset `1` already exists in the file. Data can only be modified with \"AppendMode\" -> \"Overwrite\"."
Export::h5dof = "Cannot open dataset `1`."
Export::h5dcf = "Cannot create dataset `1`."
Export::h5dwf = "Cannot write `1` to `2`."
Export::h5fad = "\"InputDataFormat\" and \"Dimensions\" must be both Automatic or both user-provided."
Export::h5dodm = "Dataset with dimensions `1` cannot store data with dimensions `2`."
Export::h5dofm = "Dataset with data type `1` cannot store data of type `2`."
Export::h5cof = "Cannot create opaque type of length `1` bytes."
Export::h5abf = "Cannot create base type for array type `1`."
Export::h5ndo = "Named datatype `1` already exists in the file and it cannot be overwritten."
Export::h5dtae = "Cannot export named datatype `1`. Object with the same path already exists in the file."
Export::h5def = "Cannot export named datatype `1`."
Export::h5dse = "Cannot save datatype of dataset `1` into `2`."
Export::h5wdt = "Named datatype `1` has invalid type definition: `2`."
Export::h5aon = "Object name `1` must be a String in attribute specification: `2`."
Export::h5ar = "Attribute specification `1` must be a Rule or a list of Rules."
Export::h5ian = "Attribute name `1` must be a String and a valid HDF5 identifier."
Export::h5ias = "At least one element is invalid in the specification of `1` attribute of `2`. The attribute will not be exported."
Export::h5aof = "Cannot overwrite attribute `1` attached to `2`."
Export::h5aae = "Cannot export attribute `1`. Attribute with the same name is already attached to `2`."
Export::h5acf = "Cannot create attribute `1` attached to `2`."
Export::h5awf = "Cannot write data `1` to attribute `2` attached to `3`."
Export::h5coo = "Cannot export attributes of `1`. The object could not be opened."
Export::h5igs = "Group specification `1` must be a list of Rules."
Export::h5pns = "HDF5 path `1` must be a String."
Export::h5lcf = "Could not create `1`Link `2` -> `3` in group `4`."
Export::h5lbn = "`1`Link name `2` must be a valid HDF5 identifier and may not contain any additional path elements."
Export::h5sbt = "SoftLink target `1` must be a valid HDF5 path."
Export::h5hbt = "HardLink target `1` must be a path from group `2` to an existing HDF5 object."
Export::h5ilf = "Links specification for group `1` should be a List of Rules instead of `2`."
Export::h5le = "Link `1` already exists in group `2` and it can be redirected only with \"AppendMode\" -> \"Overwrite\"."
Export::h5gef = "Cannot export group `1`."
Export::h5op = "Object `1` already exists in the file and it will not be modified using \"AppendMode\" -> \"Preserve\"."
Export::h5cre = "Could not register complex type with keys `1`."
ExportString::format = "`1` is not a recognized ExportString format."
ExportString::fmtnosup = "`1` is not a supported ExportString format."
ExportByteArray::format = "`1` is not a recognized ExportByteArray format."
ExportByteArray::fmtnosup = "`1` is not a supported ExportByteArray format."
Import::convqt = "Converting `1` to the QuickTime format."
Import::charenc = "Unknown character encoding `1`."
Import::chtype = "First argument `1` is not a valid file, directory, or URL specification."
Import::expectdir = ImportString::expectdir = ImportByteArray::expectdir = "First argument `1` is not a directory specification."
Import::costr = "`1` in `2` is not a string. This option must be specified as a string."
Import::errelem = "The Import element `1` is not a valid element for the `2` format."
Import::fmterr = "Cannot import data as `1` format."
Import::elemerr = "Cannot import `1` element."
Import::partelemerr = "Cannot import element `1` for certain parts of the format."
Import::format = "Cannot import data as `1`."
Import::invlineforfmt = "Cannot import `1` as `2`."
Import::frmerr = "Cannot import frame `1` as `2` format."
Import::atterr = "Cannot import attachment as `1`."
Import::noattfmt = "Cannot import attachment with MIME type `1`. Unable to infer the Import format."
Import::nodirsup = "Cannot import directory `1` as `2`."
Import::expanderr = "Cannot expand `1` as `2` format."
Import::inferdir = "Cannot infer format from directory `1`."
Import::formvers = "Import of format version `1` may not work correctly."
Import::unsupobj = "`1` format contains unsupported objects and cannot be imported."
Import::unsupobj2 = "`1` format contains unsupported objects, which will be ignored."
Import::fmtnosup = "`1` is not a supported Import format."
Import::dataset = "File does not contain a dataset `1`."
Import::h5empty = "The HDF5 file \"`1`\" does not contain any datasets."
Import::h5type = "The datatype of the dataset \"`1`\" is not currently supported."
Import::imgsze = "When importing as `1`, the raster size must be specified by setting the ImageSize option."
Import::installreq = Export::installreq = "`1` format is supported only if `2` is installed."
Import::intp = "`1` is not a positive integer."
Import::uneqlen = "Elements `1` and `2` must have the same length."
Import::memavail = "Could not allocate memory for import of `1` format."
BarcodeRecognize::nojmem = BarcodeImage::nojmem = Export::nojmem = Import::nojmem = "There was insufficient Java heap space for the operation. Try increasing the Java Virtual Machine heap size."
Export::nojlink = Import::nojlink = "The LinkObject `1` closed during the operation. Try increasing the Java Virtual Machine heap size."
Import::nlist = "`1` is not a list of strings."
Import::nlist2 = "`1` is not a list of two elements."
Import::nodta = "Insufficient data found for `1` format."
Import::noelem = "The Import element \"`1`\" is not present when importing as `2`."
Import::someelem = "One or more elements in the part specification \"`1`\" are not present when importing as `2`."
Import::hdrs = "The value `1` for the option \"`2`\" is outside of the data range." 
Import::noopts = "The Import option `1` is not a valid option for the `2` format."
Import::noframe = "Could not read frame `1`, video consists of `2` frames."
Import::nofe = "A front end is not available; import of `1` requires a front end."
Import::nomsg = "Could not import the message specified `1`."
Import::ribent = "RIB file `1` does not contain Entity data that can be imported."
Import::sdtsnolayer = "The following layers are not present in the SDTS bundle: `1`."
Import::sdtslayerspec = "Cannot understand layer specification `1`. Please enter a list of names or numbers."
Import::sdtsmodnf = "Module type `1` is not present in the file."
Import::sdtsmodinv = "Module `1` does not have the proper form. If this is an old SDTS file, please update it."
Import::spatialrng = Export::spatialrng = "Spatial range not found for `1`."
Import::unsup = "Unsupported type of `1` file."
Import::frmunsup = "Cannot import frame `1`. Unsupported type of `2`."
Import::malxml = "Could not read malformed XML document."
Import::pdtder = "Could not parse XML document. This may be due to undeclared entities in the XML document, or a failure loading the DTD. Check that entities are correctly declared or use the \"AllowUnrecognizedEntities\" option."
Import::unrecxml = "The document was not a recognized type of XML. Try importing as a general \"XML\" document."
Import::texerr = "`1`"
Import::mpsiv = "Warning: integer variables found in MPS data input and treated as real."
Import::mpsmr = "Warning: multiple right-hand sides found in MPS data input. Only the first one will be used."
Import::mpsbv = "Warning: binary variables found in MPS data input and treated as real."
Import::sid = "`1` is not a satellite ID in the file. Use the element \"SatelliteID\" for a list of satellite IDs."
Import::unsupgr = "Mixed graphs are not supported by GraphPlot."
Import::nopythonevals = "No Python external evaluator found. Use RegisterExternalEvaluator to register an external evaluator."
Import::warcversion = "Cannot import data as WARC. Expecting WARC version string."
Import::warccontent = "Failed to interpret content for WARCRecordID `1`."
Import::httpreqhost = "Could not import data as HTTPRequest. The \"Host\" header is required."
Import::hdu = "The file doesn't contain the specified HDU `1`."
Import::fdata = "Expecting Automatic, All, \"Image\", \"ASCIITable\", \"BinaryTable\", or a list of these properties instead of `1`."
Import::fitsspcr = "Cannot import from a FITS file containing \"[\" or \"(\" characters in the file name.";
ImportString::format = "`1` is not a recognized ImportString format."
ImportString::fmtnosup = "`1` is not a supported ImportString format."
ImportString::infer = ImportByteArray::infer = "Cannot infer format from string `1`."
ImportString::string = "First argument `1` is not a string."
ImportString::bkslsh = ImportByteArray::bkslsh = ToExpression::bkslsh = "The string `1` contains single backslashes. Backslash characters inside strings are represented by \\\\."
ImportByteArray::format = "`1` is not a recognized ImportByteArray format."
ImportByteArray::fmtnosup = "`1` is not a supported ImportByteArray format."
FileConvert::chtype1  = "`1` is not a valid file or URL specification."
FileConvert::chtype2  = "`1` is not a valid file specification."
FileConvert::fmttype  = "`1` is not a valid format specification."
FileConvert::inffmt = "Cannot infer output format from `1`."
General::barray = "`1` is not a ByteArray object or {}."
General::narray = "`1` is not a NumericArray object or {}."
$GeoLocation::coordset = "Invalid coordinates. A list of latitude and longitude coordinates in degrees and optional elevation in meters is required."
General::geoloc = "Unable to determine $GeoLocation.";
General::nocam = "Unable to connect to a camera. Check that a camera is properly connected and that it is not currently in use by another application."
General::checkcam = "The camera `1` is not available. Check that the camera is properly connected and that it is not currently in use by another application."
General::unknowncam = "The camera `1` is not a known device."
General::notsupported = "Image acquisition is not supported on `1`."
General::nopncam = "Unable to open the camera `1`. Expecting a string as a camera name."
$ImagingDevice::noset = $DefaultImagingDevice::noset = "Cannot set the imaging device to `1`.  Expecting a string as a camera name."
$ImagingDevice::nosetcam = $DefaultImagingDevice::nosetcam = "Cannot set the imaging device to \"`1`\".  A camera with that name was not found."
$ImagingDevice::setshortname = $DefaultImagingDevice::setshortname = "Setting the device name to \"`1`\", which will be assumed to be \"`2`\"."
CurrentImage::numimg = "The number of images `1` requested is not a positive integer."
CurrentImage::grabfail = "CurrentImage was unable to acquire an image."
CurrentImage::bufflen = "The number of images `1` requested exceeds the number of images buffered."
ImageCapture::nonopt = "ImageCapture was called with unexpected arguments. Rules are required."
SendMail::sendpart = "Relaying for some recipient addresses was denied. Message was sent to the remaining valid addresses."
SendMail::cloudrelay = "SendMail has relayed your message through the Wolfram Cloud.  A local SMTP server has not been configured. These settings can be defined through Preferences > Internet & Mail > Mail Settings in the notebook front end."
SendMail::cloudc = "SendMail requires a cloud connection to access password storage."
SendMail::cbase = "SendMail requires $CloudBase be set to `1` to access password storage."
SendMail::storefail = "SendMail was unable to access credentials storage at this time. Please try again."
Inequality::ineq = "Inequality called with `1` arguments; the number of arguments is expected to be an odd number >= 3."
Reduce`InequalityInstance::lowpr = Reduce`ExistsRealQ::lowpr = Reduce`ForAllRealQ::lowpr = Reduce`ImpliesRealQ::lowpr = "The precision of coefficients of system `1` was too low to decide whether there are any solutions."
SemialgebraicComponentInstances::nrpi = Reduce`InequalityInstance::nrpi = Reduce`ExistsRealQ::nrpi = Reduce`ForAllRealQ::nrpi = Reduce`ImpliesRealQ::nrpi = "`1` is not a logical formula consisting of polynomial equations and inequalities in `2` with exact real number coefficients."
Reduce`ExistsRealQ::nrps = Reduce`ForAllRealQ::nrps = Reduce`ImpliesRealQ::nrps = "`1` is not a logical formula consisting of polynomial equations and inequalities with real number coefficients."
Reduce`InequalityInstance::weak = Reduce`ExistsRealQ::weak = Reduce`ForAllRealQ::weak = Reduce`ImpliesRealQ::weak = "No solution of the system of inequalities with inexact coefficients has been found. The solution `1` of the system with strong inequalities replaced by weak inequalities has been found. This means the original system may have solutions for some values of inexact coefficients within the error bounds."
Reduce`InequalityInstance::wkno = Reduce`ExistsRealQ::wkno = Reduce`ForAllRealQ::wkno = Reduce`ImpliesRealQ::wkno = "No solution of the system of inequalities with inexact coefficients has been found. However, the algorithm was not able to prove that the system has no solutions for any values of inexact coefficients within the error bounds."
Infix::group = Postfix::group = Prefix::group = "Grouping specification `1` is not NonAssociative, None, Left, or Right."
Information::basic = "?Name gives information on Name, ?Ab* on all symbols starting with Ab. ??Name gives more information."
Information::nochars = "No character matching `1` found."
Information::nomatch = "No symbol matching `1` found."
Information::opt = "`1` is an invalid option."
Information::ssym = "`1` is not a symbol or a valid string pattern."
Inner::incom = "Length `1` of dimension `2` in `3` is incommensurate with length `4` of dimension 1 in `5`."
Inner::inntf = "Transpose failed for `1`."
Inner::nolev = "Level `1` is not available in `2` (dimensions `3`)."
Insert::ins = "Cannot insert at position `1` in `2`"
IntegerDigits::ibase = IntegerExponent::ibase = IntegerLength::ibase = IntegerReverse::ibase = ChampernowneNumber::ibase = "Base `1` is not an integer greater than 1."
Integrate::gener = "Unable to check convergence."
Integrate::idiv = "Integral of `1` does not converge on `2`."
Integrate::pwrl = "Unable to prove that integration limits `1` are real. Adding assumptions may help."
Integrate::isub = "Warning: infinite subdivision of the integration domain has been used in computation of the definite integral `1`. If the integral is not absolutely convergent, the result may be incorrect."
Sum::isub = "Warning: infinite subdivision of the iteration domain has been used in computation of the sum `1`. If the sum is not absolutely convergent, the result may be incorrect."
Product::isub = "Warning: infinite subdivision of the iteration domain has been used in computation of the product `1`. If the product is not absolutely convergent, the result may be incorrect."
Integrate::mdiv = "The multivariate integral `1` does not converge."
Integrate::vvar = "The vector variable `1` cannot be used for indefinite integration."
Integrate::ilim = NIntegrate::ilim = "Invalid integration variable or limit(s) in `1`."
Integrate::quantd = "Missing or incompatible quantities encountered in integration limits `1`.";
Integrate::diffbody = "Unmatched differential operator `1` found in the integrand body of `2`. There may be too many differential operators or they may not appear at the end of the integral."
Integrate::diffend = "`1` cannot be interpreted since `2` is followed by `3`. It may be necessary to use parentheses to ensure that `2` appears at the end of the integral."
Integrate::intmul = "The integral operator `1` cannot be nested directly inside the integral operator `2`. Only identical integral operators can be nested inside each other without parentheses."
Integrate::intnest = "The integral `1` cannot be interpreted. The number of definite and indefinite integral operators must match the number of differential operators."
Integrate::malfop = "`1` is a malformed integral operator. Valid forms include \!\(\[Integral]\[InvisibleSpace]\), \!\(\*SubsuperscriptBox[\(\[Integral]\), \(a\), \(b\)]\), and \!\(\*UnderscriptBox[\(\[Integral]\), \(vars \[Element] region\)]\)."
Integrate::nodiffd = "`1` cannot be interpreted. Integrals are entered in the form \!\(\[Integral]f\[DifferentialD]x\), \!\(\*SubsuperscriptBox[\(\[Integral]\), \(a\),\(b\)]f\[DifferentialD]x\), or \!\(\*UnderscriptBox[\(\[Integral]\),\(vars \[Element] region\)]f\), where \!\(\[DifferentialD]\) is entered as \[EscapeKey]dd\[EscapeKey]."
ContinuedFractionK::malfop = "`1` is a malformed continued fraction operator. Continued fractions are entered as \!\(\*SubsuperscriptBox[\(\[ContinuedFractionK]\), \(a\), \(b\)]\*FractionBox[\(f\),\(g\)]\)."
Product::malfop = "`1` is a malformed product operator. Valid forms include \[Product], \!\(\*SubscriptBox[\(\[Product]\), \(a\)]\), \!\(\*SubsuperscriptBox[\(\[Product]\), \(a\), \(b\)]\)."
Sum::malfop = "`1` is a malformed sum operator. Valid forms include \[Sum], \!\(\*SubscriptBox[\(\[Sum]\), \(a\)]\), \!\(\*SubsuperscriptBox[\(\[Sum]\), \(a\), \(b\)]\)."
InterpolatingFunction::cmpile = "The InterpolatingFunction could not be compiled because it has symbolic data or abscissas that cannot be resolved with machine numbers."
InterpolatingFunction::dmval = "Input value `1` lies outside the range of data in the interpolating function. Extrapolation will be used."
InterpolatingFunction::femdmval = "Input value `1` lies outside the range of data in the interpolating function."
InterpolatingFunction::dmvali = "The integration endpoint `1` in dimension `2` lies outside the range of data in the interpolating function. Extrapolation will be used."
InterpolatingFunction::dprec = "The precision of input value `1` and/or the interpolation grid is insufficient to compute the value."
InterpolatingFunction::unsop = "The operation is not supported for `1` that was created with NDSolve using InterpolationOrder -> All."
InterpolatingFunction::unsops = "The operation is not supported for `1` that was created with Method -> \"Spline\"."
InterpolatingPolynomial::ipdup = "The abscissas are not distinct."
InterpolatingPolynomial::ipnd = "No function or derivative value was specified with `1` in `2`."
InterpolatingPolynomial::ipab = "Abscissa specification `1` in `2` is not a point in `3` dimensions."
InterpolatingPolynomial::moddata = "When interpolating data with a prime modulus p, values must be exact and valid modulo p."
InterpolatingFunction::poised = InterpolatingPolynomial::poised = "The interpolation points `1` are not poised, so an interpolating polynomial of total degree `2` could not be found."
InterpolatingFunction::noipf = InterpolatingPolynomial::noipf = "Unable to find an interpolating polynomial of total degree `1`."
Interpolation::inauto = ListInterpolation::inauto = "The function value at each grid point must be specified. It cannot be omitted or given as \"Automatic\"."
Interpolation::incon = ListInterpolation::incon = InterpolatingFunction::incon = "The `1` derivative was not specified consistently across other dimensions."
InterpolatingPolynomial::vdims = Interpolation::vdims = ListInterpolation::vdims = "Data value `1` has dimensions incompatible with other data that has been specified."
InterpolatingPolynomial::varry = Interpolation::varry = ListInterpolation::varry = "Data value `1` is not a rectangular array."
Interpolation::indat = ListInterpolation::indat = "Data point `1` contains abscissa `2`, which is not a real number."
Interpolation::indatg = ListInterpolation::indatg = "The abscissa `2` in dimension `1` is not a real number."
Interpolation::indp = ListInterpolation::indp = "There are duplicated abscissa points in `1`."
Interpolation::inddp = ListInterpolation::inddp = "The point `1` in dimension `2` is duplicated."
Interpolation::indep = ListInterpolation::indep = InterpolatingFunction::indep = "An order-`1` derivative was specified in `2` without all corresponding lower-order derivatives."
InterpolatingPolynomial::inder = Interpolation::inder = ListInterpolation::inder = "The order-`1` derivative of `2` is not a tensor of rank `1` with dimensions `3`."
Interpolation::indim = ListInterpolation::indim = "The coordinates do not lie on a structured tensor product grid."
Interpolation::indimt = ListInterpolation::indimt = "The coordinate `1` in dimension `2` is not consistent with other values for this coordinate in this row of the data."
Interpolation::inhr = ListInterpolation::inhr = InterpolatingFunction::inhr = "Requested order is too high; order has been reduced to `1`."
Interpolation::inlen = "Inconsistent element `1` encountered; all data elements must have the same length."
Interpolation::innd = ListInterpolation::innd = "First argument in `1` does not contain a list of data and coordinates."
Interpolation::inord = ListInterpolation::inord = FunctionInterpolation::inord = "Value of option `1` -> `2` should be a non-negative machine-sized integer or a list of integers with length equal to the number of dimensions, `3`."
Interpolation::inpts = "The total number `1` of data points is not a multiple of the number `2` of points in dimension `3`."
Interpolation::mixedp = ListInterpolation::mixedp = InterpolatingPolynomial::mixedp = "Equality of mixed partials in the `1` derivative of data `2` was not satisfied. Using `3`."
Interpolation::method = ListInterpolation::method = "The method `1` is not Piecewise or Spline."
Interpolation::mspl = ListInterpolation::mspl = "The Spline method could not be used because the data could not be coerced to machine real numbers."
Interpolation::per = ListInterpolation::per = "In dimension `1` the data at the endpoints of the fundamental period are not equal."
Interpolation::ipdup = "The specified abscissas `1` are not distinct."
Interpolation::tpgrid = "The specified abscissas do not lie on a tensor product grid. Piecewise interpolation is only supported on unstructured grids in two dimensions."
Interpolation::fdtp = "Specification of derivative values is only supported for abscissas on tensor product grids. The abscissas in `1` do not lie on a tensor product grid."
Interpolation::udeg = "Interpolation on unstructured grids is currently only supported for InterpolationOrder->1 or InterpolationOrder->All. Order will be reduced to 1."
Interpolation::umn = NDSolve`FEM`ElementMeshInterpolation::umn = "Interpolation on unstructured grids is currently only supported for machine numbers."
Interpolation::fememtlq = NDSolve`FEM`ElementMeshInterpolation::fememtlq = "The quality `1` of the underlying mesh is too low. The quality needs to be larger than `2`."
Interpolation::vvalues = NDSolve`FEM`ElementMeshInterpolation::vvalues = "The total number of data points is expected to be `1`."
Interpolation::umprec = "Interpolation on unstructured grids is currently only supported for machine numbers. The data will be coerced to machine precision."
Interpolation::umesh = "Unable to find a mesh from the points `1` for interpolation."
Interrupt::dgbgn = TraceDialog::dgbgn = "Entering Dialog; use Return[] to exit."
Interrupt::dgend = TraceDialog::dgend = "Exiting Dialog."
Interval::nvld = "The form `1` does not represent a valid interval."
IntervalSlider::invdom = "Invalid domain specified: `1` should be strictly less than `2`."
Inverse::invc = "Result for inverse of badly conditioned matrix `1` may contain significant numerical errors."
InverseFunction::ifun = "Inverse functions are being used. Values may be lost for multivalued inverses."
InverseFunction::noinv = "The function `1` is not invertible."
JacobiSymbol::jcpo = "Second argument `1` in `2` should be an odd, positive integer."
Join::headsd = "Expression `1` at position `2` is expected to have head `3` for all expressions at level `4`."
LegendreP::ltype = LegendreQ::ltype = "Legendre type `1` is expected to be 1, 2, or 3."
Limit::nolim = "The limit `1` does not exist."
Limit::ldir = MaxLimit::ldir = MinLimit::ldir = AsymptoticLess::ldir = AsymptoticGreater::ldir = AsymptoticLessEqual::ldir = AsymptoticGreaterEqual::ldir = AsymptoticEqual::ldir = AsymptoticEquivalent::ldir = AsymptoticSolve::ldir = "Value of Direction -> `1` should be a number, Reals, Complexes, \"FromAbove\", \"FromBelow\", \"TwoSided\", or a list of these."
Limit::gcond = MaxLimit::gcond = MinLimit::gcond = DiscreteLimit::gcond = DiscreteMaxLimit::gcond = DiscreteMinLimit::gcond = AsymptoticLess::gcond = AsymptoticGreater::gcond = AsymptoticLessEqual::gcond = AsymptoticGreaterEqual::gcond = AsymptoticEqual::gcond = AsymptoticEquivalent::gcond = AsymptoticSolve::gcond = "Value of GenerateConditions -> `1` should be True, False, Automatic, or None."
Limit::lim = MaxLimit::lim = MinLimit::lim = AsymptoticLess::lim = AsymptoticGreater::lim = AsymptoticLessEqual::lim = AsymptoticGreaterEqual::lim = AsymptoticEqual::lim = AsymptoticEquivalent::lim = "Limit specification `1` is not of the form x -> x0."
DiscreteLimit::lim = DiscreteMaxLimit::lim = DiscreteMinLimit::lim = "Limit specification is not valid."
Limit::limf = "Unable to determine limit direction from `1`."
Limit::lcond = MaxLimit::lcond = MinLimit::lcond = "The limit point `1` is not in the closure of the solution set of `2`."
Limit::zfun = MaxLimit::zfun = MinLimit::zfun = AsymptoticLess::zfun = AsymptoticGreater::zfun = AsymptoticLessEqual::zfun = AsymptoticGreaterEqual::zfun = AsymptoticEqual::zfun = AsymptoticEquivalent::zfun = AsymptoticSolve::zfun = "Unable to determine whether expressions `1` are equal to zero. Assuming they are."
Limit::repv = MaxLimit::repv = MinLimit::repv = DiscreteLimit::repv = DiscreteMaxLimit::repv = DiscreteMinLimit::repv = AsymptoticLess::repv = AsymptoticGreater::repv = AsymptoticLessEqual::repv = AsymptoticGreaterEqual::repv = AsymptoticEqual::repv = AsymptoticEquivalent::repv = "Variable list `1` contains repeated variables."
Limit::alimv = MaxLimit::alimv = MinLimit::alimv = AsymptoticLess::alimv = AsymptoticGreater::alimv = AsymptoticLessEqual::alimv = AsymptoticGreaterEqual::alimv = AsymptoticEqual::alimv = AsymptoticEquivalent::alimv = "Warning: Assumptions that involve the limit variable are ignored."
Limit::alimvs = MaxLimit::alimvs = MinLimit::alimvs = AsymptoticLess::alimvs = AsymptoticGreater::alimvs = AsymptoticLessEqual::alimvs = AsymptoticGreaterEqual::alimvs = AsymptoticEqual::alimvs = AsymptoticEquivalent::alimvs = "Warning: Assumptions that involve the limit variables are ignored."
MaxLimit::compl = MinLimit::compl = DiscreteMaxLimit::compl = DiscreteMinLimit::compl = "`1` is not real valued for `2` -> `3`."
MaxLimit::unpr = MinLimit::unpr = DiscreteMaxLimit::unpr = DiscreteMinLimit::unpr = "Warning: Unable to prove that `1` is real valued for `2` -> `3`."
DualLinearProgramming::lpbd = LinearProgramming::lpbd = "The input that specifies lower/upper bounds contains elements that are not real numbers, Infinity, or -Infinity."
FindMinimum::maxit = FindMaximum::maxit = FindArgMin::maxit = FindArgMax::maxit = FindMinValue::maxit = FindMaxValue::maxit = LinearOptimization::maxit = LinearFractionalOptimization::maxit = QuadraticOptimization::maxit = DualLinearProgramming::maxit = LinearProgramming::maxit = "Maximum number of iterations `1` reached without convergence."
DualLinearProgramming::lpdim = LinearProgramming::lpdim = "Invalid input: the dimensions of the input vectors or matrices must match."
DualLinearProgramming::lpnn = LinearProgramming::lpnn = ConstrainedMax::lpnn = ConstrainedMin::lpnn = "Input data to linear programming algorithm `1` contains elements that are empty matrices, invalid vectors or matrices, or not real numbers."
General::mreal = "Input data contains numbers that cannot be coerced into machine reals."
DualLinearProgramming::lprank2 = LinearProgramming::lprank2 = "`1` is not a matrix."
DualLinearProgramming::lprank1 = LinearProgramming::lprank1 = "`1` is not a vector."
DualLinearProgramming::lprank12 = LinearProgramming::lprank12 = "`1` must be a vector or a matrix with 2 columns."
DualLinearProgramming::lprank012 = LinearProgramming::lprank012 = "`1` must be a scalar, a vector, or a matrix with 2 columns."
DualLinearProgramming::lpsg = LinearProgramming::lpsg = "The second column of `1` must be a vector consisting of -1, 1, or 0, indicating respectively inequalities with <=, =>, or equality."
DualLinearProgramming::lpmethod = LinearProgramming::lpmethod = "`1` is not a valid method for linear programming."
ConstrainedMax::cmr = ConstrainedMin::cmr = DualLinearProgramming::cmr = LinearProgramming::cmr = "The constraint matrix `1` in `2` must be a matrix of real numbers."
ConstrainedMax::cmz = ConstrainedMin::cmz = DualLinearProgramming::cmz = LinearProgramming::cmz = "For the constraint matrix `1` in `2` to represent valid constraints, each row must have length greater than zero and contain at least one nonzero entry."
ConstrainedMax::cvr = ConstrainedMin::cvr = DualLinearProgramming::cvr = LinearProgramming::cvr = "The vector `1` in `2` must be a nonzero-length vector of real numbers."
ConstrainedMax::lptol = ConstrainedMin::lptol = SecondOrderConeOptimization::lptol = LinearOptimization::lptol = LinearFractionalOptimization::lptol = DualLinearProgramming::lptol = LinearProgramming::lptol = "Value of option Tolerance -> `1` is not a positive real number or Automatic."
Optimization`LinearProgramming`Simplex::lpsiter = SecondOrderConeOptimization::lpsiter = LinearOptimization::lpsiter = LinearFractionalOptimization::lpsiter = DualLinearProgramming::lpsiter = LinearProgramming::lpsiter = MeanShift::iters = ImageFeatureTrack::iters = GuidedFilter::iters = ImageDisplacements::iters = InverseShortTimeFourier::iters = InverseSpectrogram::iters =  "The value of option MaxIterations -> `1` should be a positive integer or Infinity."
Optimization`LinearProgramming`Simplex::lpsiter1 = SecondOrderConeOptimization::lpsiter1 = LinearOptimization::lpsiter1 = LinearFractionalOptimization::lpsiter1 = DualLinearProgramming::lpsiter1 = LinearProgramming::lpsiter1 = "The number of iterations taken has exceeded the preset limit of MaxIterations = `1`. Try setting the MaxIterations option to a higher number."
Optimization`LinearProgramming`Simplex::lpsbnn = SecondOrderConeOptimization::lpsbnn = LinearOptimization::lpsbnn = LinearFractionalOptimization::lpsbnn = DualLinearProgramming::lpsbnn = LinearProgramming::lpsbnn = "Found lower bound and upper bound both set at `1`."
Optimization`LinearProgramming`Simplex::lpsom = SecondOrderConeOptimization::lpsom = LinearOptimization::lpsom = LinearFractionalOptimization::lpsom = DualLinearProgramming::lpsom = LinearProgramming::lpsom = "Warning: the value of the option \"ScalingMethod\" -> \"Optimal\" is not allowed for non-machine-number problems. \"ScalingMethod\" -> \"NormalizeRow\" will be used instead."
FindMaximum::lpsnf = FindMinimum::lpsnf = FindArgMin::lpsnf = FindArgMax::lpsnf = FindMinValue::lpsnf = FindMaxValue::lpsnf = Optimization`LinearProgramming`Simplex::lpsnf = ConstrainedMax::lpsnf = ConstrainedMin::lpsnf = SecondOrderConeOptimization::lpsnf = LinearOptimization::lpsnf = QuadraticOptimization::lpsnf = LinearFractionalOptimization::lpsnf = DualLinearProgramming::lpsnf = LinearProgramming::lpsnf = ConicOptimization::lpsnf = "No solution can be found that satisfies the constraints."
Optimization`LinearProgramming`Simplex::lpspm = SecondOrderConeOptimization::lpspm = LinearOptimization::lpspm = QuadraticOptimization::lpspm = LinearFractionalOptimization::lpspm = DualLinearProgramming::lpspm = LinearProgramming::lpspm = "Pricing method specification `1` is invalid."
Optimization`LinearProgramming`Simplex::lpssm = SecondOrderConeOptimization::lpssm = LinearOptimization::lpssm = QuadraticOptimization::lpssm = LinearFractionalOptimization::lpssm = DualLinearProgramming::lpssm = LinearProgramming::lpssm = "Scaling method specification `1` is invalid."
General::lpsub = "This problem is unbounded."
ConicOptimization::lplop = SecondOrderConeOptimization::lplop = LinearOptimization::lplop = LinearFractionalOptimization::lplop = DualLinearProgramming::lplop = LinearProgramming::lplop = "For a problem of this size, `1` uses the interior point algorithm, which only returns a result of machine precision. If a result of non-machine precision is needed, set the option to Method -> `2`, though it may take longer computing time."
ConicOptimization::lpipp = SecondOrderConeOptimization::lpipp = LinearOptimization::lpipp = LinearFractionalOptimization::lpipp = DualLinearProgramming::lpipp = LinearProgramming::lpipp = "Warning: Method -> InteriorPoint specified for non-machine-precision problem. A machine-precision result will be given. If a non-machine-precision result is needed, set the option to Method -> `1`."
LinearOptimization::badwp = LinearFractionalOptimization::badwp = "The specified method, `1`, may only be used with machine-precision numbers. This is inconsistent with the specified WorkingPrecision->`2`. To compute using a specified precision use method Automatic, \"Simplex\", or \"RevisedSimplex\"."
FindMinimum::lpdinf = FindMaximum::lpdinf = FindArgMin::lpdinf = FindArgMax::lpdinf = FindMinValue::lpdinf = FindMaxValue::lpdinf = SecondOrderConeOptimization::lpdinf = LinearOptimization::lpdinf = LinearFractionalOptimization::lpdinf = DualLinearProgramming::lpdinf = LinearProgramming::lpdinf = "The dual of this problem is infeasible, which implies that this problem is either unbounded or infeasible. Setting the option Method -> `1` should give a more definite answer, though large problems may take longer computing time."
FindMinimum::lpdinf0 = FindMaximum::lpdinf0 = FindArgMin::lpdinf0 = FindArgMax::lpdinf0 = FindMinValue::lpdinf0 = FindMaxValue::lpdinf0 = ConicOptimization::lpdinf0 = SecondOrderConeOptimization::lpdinf0 = LinearOptimization::lpdinf0 = QuadraticOptimization::lpdinf0 = LinearFractionalOptimization::lpdinf0 = DualLinearProgramming::lpdinf0 = LinearProgramming::lpdinf0 = "The dual of this problem is infeasible, which implies that this problem is either unbounded or infeasible."
ConicOptimization::lpdinfp = SecondOrderConeOptimization::lpdinfp = LinearOptimization::lpdinfp = QuadraticOptimization::lpdinfp = LinearFractionalOptimization::lpdinfp = DualLinearProgramming::lpdinfp = LinearProgramming::lpdinfp = "The dual of this problem is possibly infeasible, which implies that this problem is either unbounded or infeasible. Setting the option Method -> `1` should give a more definite answer, though large problems may take longer computing time."
ConicOptimization::lpsnfp = SecondOrderConeOptimization::lpsnfp = LinearOptimization::lpsnfp = QuadraticOptimization::lpsnfp = LinearFractionalOptimization::lpsnfp = DualLinearProgramming::lpsnfp = LinearProgramming::lpsnfp = "This problem is probably infeasible. Setting the option Method -> `1` should give a more definite answer, though large problems may take longer computing time."
ConicOptimization::lpipcv = SecondOrderConeOptimization::lpipcv = LinearOptimization::lpipcv = QuadraticOptimization::lpipcv = LinearFractionalOptimization::lpipcv = DualLinearProgramming::lpipcv = LinearProgramming::lpipcv = FindMinimum::lpipcv = "Warning: the interior point algorithm cannot converge to the tolerance of `2`. The best residual achieved is `1`, and the solution at that residual has been returned. Setting the option Method -> `3` should give a more definite answer, though large problems may take longer computing time."
ConicOptimization::lptols = SecondOrderConeOptimization::lptols = LinearOptimization::lptols = QuadraticOptimization::lptols = LinearFractionalOptimization::lptols = DualLinearProgramming::lptols = LinearProgramming::lptols = "Warning: the supplied tolerance of `1` might be too small for the interior point algorithm. Typically a reasonable tolerance for the interior point algorithm is `2` (the square root of the machine epsilon)."
ConicOptimization::lpipncv = SecondOrderConeOptimization::lpipncv = LinearOptimization::lpipncv = QuadraticOptimization::lpipncv = LinearFractionalOptimization::lpipncv = DualLinearProgramming::lpipncv = LinearProgramming::lpipncv = "The interior point algorithm cannot converge to the tolerance of `1`. The best residual achieved is `2`. The failure to converge might be because the problem is mildly infeasible. Setting the option Method -> `3` should give a more definite answer, though large problems may take longer computing time."
SecondOrderConeOptimization::lpitd = LinearOptimization::lpitd = QuadraticOptimization::lpitd = LinearFractionalOptimization::lpitd = DualLinearProgramming::lpitd = LinearProgramming::lpitd = "Value of option TreatDenseColumns -> `1` is not True, False, or Automatic."
Optimization`LinearProgramming`Simplex::lpsdm2 = "The row dimensions of the second and third arguments do not match."
Optimization`LinearProgramming`Simplex::lpsdm3 = "The row dimensions of the fourth and fifth arguments do not match."
Optimization`LinearProgramming`Simplex::lpsdm4 = "The column dimension of the second argument does not match the length of the first argument."
Optimization`LinearProgramming`Simplex::lpsdm5 = "The length of the first argument does not match the length of the lower bound."
Optimization`LinearProgramming`Simplex::lpsdm6 = "The length of the first argument does not match the length of the upper bound."
Optimization`LinearProgramming`Simplex::lpsdm7 = "The column dimension of the fourth argument does not match the length of the first argument."
General::gfargs = "Generalized `1` arguments accept only matrices with machine real and complex elements."
FindMinimum::lpuncon = FindMaximum::lpuncon = FindArgMin::lpuncon = FindArgMax::lpuncon = FindMinValue::lpuncon = FindMaxValue::lpuncon = "Method -> LinearProgramming cannot be used on an unconstrained optimization problem."
FindMinimum::qpuncon = FindMaximum::qpuncon = FindArgMin::qpuncon = FindArgMax::qpuncon = FindMinValue::qpuncon = FindMaxValue::qpuncon = "Method -> QuadraticProgramming cannot be used on an unconstrained optimization problem."
LinearOptimization::intv = LinearFractionalOptimization::intv = LinearProgramming::intv = "The value of IntegerValues -> `1` must be None, All, or a list of positive integers no larger than the number of variables."
FindMinimum::nonquad = FindMaximum::nonquad = FindArgMin::nonquad = FindArgMax::nonquad = FindMinValue::nonquad = FindMaxValue::nonquad = "The value of Method -> QuadraticProgramming is inconsistent with the nonquadratic objective or nonlinear constraints in `1`."
FindMinimum::nonilin = FindMaximum::nonilin = FindArgMin::nonilin = FindArgMax::nonilin = FindMinValue::nonilin = FindMaxValue::nonilin = "The value of Method -> IntegerLinearProgramming is inconsistent with nonlinear constraints or object function in `1`."
FindMinimum::bdmtd = FindMaximum::bdmtd = FindArgMin::bdmtd = FindArgMax::bdmtd = FindMinValue::bdmtd = FindMaxValue::bdmtd = "Value of option Method -> `1` is not Automatic, \"Gradient\", \"ConjugateGradient\", \"InteriorPoint\", \"QuasiNewton\", \"Newton\", \"LinearProgramming\", \"QuadraticProgramming\", or \"LevenbergMarquardt\"."
LinearOptimization::bab = LinearFractionalOptimization::bab = LinearProgramming::bab = "Warning: problem specified contains integer variables; it cannot be solved using `1` method. Integer constraints ignored."
FindMinimum::lpmp2 = FindMaximum::lpmp2 = FindArgMin::lpmp2 = FindArgMax::lpmp2 = FindMinValue::lpmp2 = FindMaxValue::lpmp2 = Optimization`QuadraticProgramming::lpmp2 = LinearOptimization::lpmp2 = DualLinearProgramming::lpmp2 = LinearProgramming::lpmp2 = "Warning: Method -> `1` is specified for a non-machine-precision problem; the problem will be converted into machine precision. Used Method -> `2` for non-machine-number problem."
LinearOptimization::lpmp = LinearFractionalOptimization::lpmp = DualLinearProgramming::lpmp = LinearProgramming::lpmp = "Warning: Method -> `1` is specified for a non-machine-precision problem; the problem will be converted into machine precision."
FindMinimum::lpip = FindMaximum::lpip = FindArgMin::lpip = FindArgMax::lpip = FindMinValue::lpip = FindMaxValue::lpip = DualLinearProgramming::lpip = LinearProgramming::lpip = "Warning: integer linear programming will use a machine-precision approximation of the inputs."
FindMinimum::cnpreg = FindMaximum::cnpreg = FindArgMin::cnpreg = FindArgMax::cnpreg = FindMinValue::cnpreg = FindMaxValue::cnpreg = "Could not process the region `1`."
FindMinimum::cnpcons = FindMaximum::cnpcons = FindArgMin::cnpcons = FindArgMax::cnpcons = FindMinValue::cnpcons = FindMaxValue::cnpcons = "Could not process the constraints `1`."
Optimization`QuadraticProgramming::qp1 = LinearProgramming::qp1 = DualLinearProgramming::qp1 = "The first argument `1` must be a matrix."
LinearOptimization::ivs = LinearFractionalOptimization::ivs = DualLinearProgramming::ivs = LinearProgramming::ivs = "The value of IntegerValues -> `1` must be None, All, or a list of positive integers no larger than the number of variables."
Optimization`QuadraticProgramming::mcp = LinearProgramming::mcp = "Warning: only Method -> CLP is allowed for a quadratic programming problem. Using Method -> CLP instead."
General::lpintrs = "Method `2` is not valid for `1` when some variables are integer-valued."
General::cxobj = "The objective `1` contains complex values. Currently, the optimization methods can only perform computations over the Reals."
General::cxcnstr = "The constraints `1` contains complex values. Currently, the optimization methods can only perform computations over the Reals."
(* end Integer Programming/QP *)
General::nonnum = "`1` has received a matrix with non-numerical elements."
General::exnum = "`1` has received a matrix with non-numerical or exact elements."
General::oflow = "Machine overflow encountered during computations."
General::herm = "The matrix `1` is not Hermitian or real and symmetric."
General::aherm = "The matrix `1` is not antihermitian or real and antisymmetric."
Optimization`ModifiedCholeskyDecomposition::posdef = CholeskyDecomposition::posdef = "The matrix `1` is not sufficiently positive definite to complete the Cholesky decomposition to reasonable accuracy."
General::neqcols = "The matrices `1` and `2` must have the same number of columns."
LinearSolve::lsfail = "LinearSolve could not find solutions to the linear system."
General::lslc = "Coefficient matrix and target vector(s) or matrix do not have the same dimensions."
LeastSquares::nosol = LinearSolve::nosol = FindRoot::nosol = "Linear equation encountered that has no solution."
Internal`DiscreteRiccatiSolve::ncscl = Internal`RiccatiSolve::ncscl = DiscreteRiccatiSolve::ncscl = RiccatiSolve::ncscl = "Warning: cannot compute a solution to the scaled matrix equation."
Internal`RiccatiSolve::nosol = Internal`DiscreteRiccatiSolve::nosol = RiccatiSolve::nosol = DiscreteRiccatiSolve::nosol = "The matrix equation has no stabilizing solution."
Internal`SylvesterSolve::nosol = DiscreteLyapunovSolve::nosol = LyapunovSolve::nosol = "The matrix equation has no solution."
Internal`DiscreteRiccatiSolve::nuniq = Internal`RiccatiSolve::nuniq = Internal`SylvesterSolve::nuniq = DiscreteRiccatiSolve::nuniq = RiccatiSolve::nuniq = DiscreteLyapunovSolve::nuniq = LyapunovSolve::nuniq = "The matrix equation has no unique solution."
Internal`DiscreteRiccatiSolve::ncsol = Internal`RiccatiSolve::ncsol = DiscreteRiccatiSolve::ncsol = RiccatiSolve::ncsol = "Cannot compute a stabilizing solution to the matrix equation."
Internal`SylvesterSolve::ncsol = DiscreteLyapunovSolve::ncsol = LyapunovSolve::ncsol = "Cannot compute a solution to the matrix equation."
Internal`SylvesterSolve::meig = DiscreteLyapunovSolve::meig = LyapunovSolve::meig = "Matrix with multiple eigenvalues encountered. The solution may be inaccurate or may not exist."
Internal`SylvesterSolve::wbcond = DiscreteLyapunovSolve::wbcond = LyapunovSolve::wbcond = "Warning: the matrix solution may be inaccurate or may not exist because it is relatively too large compared to the input matrices."
Internal`DiscreteRiccatiSolve::pnosol = Internal`RiccatiSolve::pnosol = Internal`SylvesterSolve::pnosol = DiscreteRiccatiSolve::pnosol = RiccatiSolve::pnosol = DiscreteLyapunovSolve::pnosol = LyapunovSolve::pnosol = "Warning: the stabilizing solution may be inaccurate or may not exist."
Internal`SchurDecomposition::nargmp = Internal`DiscreteRiccatiSolve::nargmp = Internal`RiccatiSolve::nargmp = DiscreteRiccatiSolve::nargmp = RiccatiSolve::nargmp = Internal`SylvesterSolve::nargmp = DiscreteLyapunovSolve::nargmp = LyapunovSolve::nargmp = "The argument `1` should be a matrix pair in the form {m, a}."
Internal`DiscreteRiccatiSolve::nargmp1 = Internal`RiccatiSolve::nargmp1 = DiscreteRiccatiSolve::nargmp1 = RiccatiSolve::nargmp1 = "The argument `1` should be a matrix pair in the form {m, a} or a matrix triple in the form {m, a, b}."
DiscreteLyapunovSolve::nargmo = LyapunovSolve::nargmo = "The argument `1` should be a matrix."
LinearSolve::exopt1 = "The option setting `2` -> `1` cannot be used with arbitrary-precision or exact arguments."
Internal`DiscreteRiccatiSolve::exopt = Internal`RiccatiSolve::exopt = DiscreteRiccatiSolve::exopt = RiccatiSolve::exopt = "The option setting `2` -> `1` cannot be used with exact numeric matrices."
Internal`PoleAssignment::rsmit = Internal`DiscreteRiccatiSolve::rsmit = Internal`RiccatiSolve::rsmit = DiscreteRiccatiSolve::rsmit = RiccatiSolve::rsmit = "Warning: the maximum number of iterations, `1`, has been reached without convergence to a solution within the required tolerance `2`. The currently computed solution has been returned."
Internal`RiccatiSolve::rcdsc = DiscreteRiccatiSolve::rcdsc = RiccatiSolve::rcdsc = "The method `1` cannot be used with an explicit descriptor matrix."
Internal`RiccatiSolve::exdsc = DiscreteRiccatiSolve::exdsc = RiccatiSolve::exdsc = "The Riccati equation containing an explicit descriptor matrix cannot be solved for exact numeric matrices."
Internal`PoleAssignment::ncsol = "Cannot compute a solution to the pole assignment problem."
Developer`LaunchFrontEnd::nxsrv = "Failed to launch the front end. The front end requires an X server to run."
Developer`LinearExpressionToMatrix::nonlin = Developer`LinearExpressionToSparseMatrix::nonlin = "The expression `1` is not linear in the variables `2`."
Developer`LinearExpressionToMatrix::lexp = Developer`LinearExpressionToSparseMatrix::lexp = "The first argument `1` is not a list of expressions or a list of equations."
LinearRecurrence::invd = "The arguments `2` and `3` in `1` have incompatible dimensions."
LaunchManager::filecreate = "Launch Manager encountered an error while trying to write a file to its local filesystem."
LaunchManager::kernelerr = "Launch Manager unable to read or write data to the Kernel: `1`."
LaunchManager::launcherr = "Launch Manager unable to start Kernel: `1`."
LaunchManager::maxeng = "Launch Manager has reached maximum number of launched engines; no engines available."
LaunchManager::nosucheng = "Launch Manager cannot locate an engine with name `1`."
LaunchManager::running = "Launch Manager cannot launch a Kernel with service name `1`; already running a Kernel with that service name."
LaunchManager::wstperr = "Launch Manager cannot send message through a WSTP link: `1`."
LaunchManager::nogeoloc = "Launch Manager cannot find $GeoLocation."
LaunchManager::auth = "Launch Manager restart command does not have permission to restart the manager."
LaunchManager::auth = "Launch Manager stop command does not have permission to stop the manager."
LaunchManager::auth = "Launch Manager terminate engine command does not have permission to terminate an engine."
LinkConnect::linkc = "Unable to connect to `1`."
LinkObject::linkd = "Unable to communicate with closed link `1`."
LinkObject::linkn = "Argument `1` in `2` has an invalid LinkObject number; the link may be closed."
LinkObject::linkv = LinkWrite::linkv = LinkWriteHeld::linkv = "Argument `1` in `2` is not a valid LinkObject."
LinkObject::linkw = "Unable to write data to closed link `1`."
LinkObject::linkx = "Argument `1` in `2` is not an open LinkObject."
LinkOpen::linkh = "Value of LinkHost -> `1` should be a string."
LinkOpen::linki = "WSTP could not be initialized."
LinkOpen::linkm = "Value of LinkMode -> `1` should be Launch, ParentConnect, Listen, or Connect."
LinkOpen::linknm = "Either a link name or a value for LinkMode must be given."
LinkOpen::linkpl = "Value of option LinkProtocol -> `1` should be `2` or Automatic."
LinkOpen::links = "Too many open links."
LinkOpen::linke = "`1`."
LinkRead::linkep = "An unexpected end of packet was received."
LinkRead::linksz = "Expression with head `1` and length `2` is too big to read."
LinkSelect::linknl = "`1` unexpectedly is not a LinkObject."
LinkSelect::linksle = "Could not select a LinkObject in `1`."
LinkSelect::linkzl = "Argument `1` in `2` does not contain a LinkObject."
LinkService::badst = "DNS service discovery in a bad state."
LinkService::notav = "Link service named `1` not available."
LinkService::notb = "Not currently browsing for link services."
LinkService::notc = "DNS service discovery mechanism not connected."
LinkService::noserv = "WSTP service discovery and advertisement not available; DNS service discovery not installed on this machine."
LinkWriteHeld::linkhl = "Argument `1` in `2` is not a held expression."
ListConvolve::kldims = ListCorrelate::kldims = "The kernel `1` and list `2` are not both non-empty lists with the same tensor rank."
ListConvolve::nlen = ListCorrelate::nlen = "The end conditions cannot be satisfied. A zero-length list will be returned."
ListConvolve::depth = ListCorrelate::depth = "The dimension `1` of the overhang parameters exceeds the rectangular rank of the kernel, `2`."
ListDeconvolve::arginv = "Expecting a non-empty real numeric array instead of `1`.";
ListDeconvolve::dims = "The kernel `1` and list `2` are not both non-empty numerical arrays with the same tensor rank."
ListDeconvolve::kldims = "The dimensions of a kernel cannot be larger than the dimensions of a list.";
ListDeconvolve::mtd = "The value of option Method -> `1` should be one of \"DampedLS\", \"Tikhonov\", \"TSVD\", \"Wiener\", \"Hybrid\", \"RichardsonLucy\", \"SteepestDescent\", or \"TotalVariation\" with possible suboptions.";
ListDeconvolve::param = "The value of regularization parameter `1` should be a non-negative real number or Automatic."
ListDeconvolve::padding = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number.";
ListDeconvolve::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
ListDeconvolve::prec = "The value of option \"Preconditioned\" -> `1` should be either True or False.";
ListDeconvolve::tvnoise = "The value of option \"NoiseModel\" -> `1` should be one of \"Gaussian\", \"Laplacian\", or \"Poisson\".";
ListDeconvolve::tvparam = "The value of option \"Regularization\" -> `1` should be a non-negative real number or Automatic."
ListDeconvolve::lowpr = "ListDeconvolve cannot be evaluated because of insufficient precision of the input."
ListInterpolation::ingrdm = "The dimension of the data to be interpolated in the first argument is inconsistent with the dimension of the grid in the second argument."
ListInterpolation::ligrid = "The second argument `1` should be a list of coordinates or data ranges."
ListPlay::lsamps = "The first argument to ListPlay must be a list of samples or a list of lists of samples."
ListPlay::silent = "Sound in channel `1` is silent."
General::lpn = "`1` is not a list of numbers or pairs of numbers."
LogicalExpand::elist = MainSolve::elist = Roots::elist = ToRules::elist = Solve::elist = Reduce::elist = System`Private`OldReduce::elist = Eliminate::elist = SolveAlways::elist = AlgebraicRules::elist = GroebnerBasis::elist = PolynomialReduce::elist = "List encountered during logical expansion of `1`."
LogicalExpand::eqf = MainSolve::eqf = Roots::eqf = ToRules::eqf = Solve::eqf = Reduce::eqf = System`Private`OldReduce::eqf = Eliminate::eqf = SolveAlways::eqf = AlgebraicRules::eqf = GroebnerBasis::eqf = PolynomialReduce::eqf = GroebnerBasis`DistributedTermsList::eqf = "`1` is not a well-formed equation."
LUBackSubstitution::bpvt = "The pivot vector `1` is invalid."
LUBackSubstitution::singlu = "The LU decomposition matrix `1` is singular."
LUDecomposition::sq = "LUDecomposition accepts only square matrices."
MainSolve::ibool = Solve::ibool = Reduce::ibool = System`Private`OldReduce::ibool = AlgebraicRules::ibool = Eliminate::ibool = SolveAlways::ibool = "Value of option InverseFunctions -> `1` should be True, False, or Automatic."
MainSolve::method = System`Private`OldSolve::method = System`Private`OldReduce::method = AlgebraicRules::method = Eliminate::method = SolveAlways::method = "Value of option Method -> `1` should be 1, 2, or 3."
MainSolve::mode = Solve::mode = Reduce::mode = System`Private`OldReduce::mode = AlgebraicRules::mode = Eliminate::mode = SolveAlways::mode = "Value of option Mode -> `1` should be Generic, Modular, or Rational."
MainSolve::verif = Solve::verif = Reduce::verif = System`Private`OldReduce::verif = AlgebraicRules::verif = Eliminate::verif = "Potential solution `1` (possibly discarded by verifier) should be checked by hand. May require use of limits."
Manipulate::multlocs = "The initial values in `1` are not currently supported. When a Manipulate has more than one Locator variable, each initial value must be a single coordinate. These values will revert to single coordinates during user interaction."
Manipulate::nobks = "There must be at least `1` bookmarks set to perform that action."
Manipulate::novars = "This Manipulate has no local variables. That action requires a Manipulate with local variables."
Manipulate::vsform = "Manipulate argument `1` does not have the correct form for a variable specification."
Manipulate::vstype = "ControlType -> `2` is not supported for the variable specification `3`. ControlType -> `1` will be used instead."
Manipulate`AnimationData::nobks = "There are not enough bookmarks present to use the `1` method. The `2` method will be used instead."
Manipulate`AnimationData::noanim = "The expression `1` cannot be animated."
MapThread::mptc = "Incompatible dimensions of objects at positions {2, `1`} and {2, `2`} of `3`; dimensions are `4` and `5`."
MapThread::mpth = "Incompatible heads of objects at positions {2, `1`} and {2, `2`} of `3`; heads are `4` and `5`."
MapThread::mptk = "Incompatible keys of objects at positions {2, `1`} and {2, `2`} of `3`; keys are `4` and `5`."
MapThread::mptd = "Object `1` at position {2, `2`} in `3` has only `4` of required `5` dimensions."
MathieuCharacteristicA::nnord = MathieuCharacteristicB::nnord = "The order `1` is not non-negative."
MathieuCharacteristicB::zord = "There is no zero-order MathieuCharacteristicB."
MathMLForm::boxfmt = "The default typesetting format used by MathMLForm is set in Internal`1`$DefaultMathMLBoxFormat. The current value `2` is not valid; it must be a member of $BoxForms. MathMLForm will resort to TraditionalForm."
MatrixPower::zvec = MatrixExp::zvec = "Cannot compute `1` because the argument matrix `2` has a zero eigenvector."
MatrixExp::novec = "The method `1` requires the specification of a vector."
MatrixExp::invmtd = "Invalid method `1` for input with precision `2`."
MatrixExp::spar = "The option value Parameter -> `1` is not a scalar parameter."
MatrixExp::rpar = "The option value Parameter -> `1` is not a real parameter."
MatrixExp::ktol = "Unable to satisfy Tolerance -> `1` for parameter value `2`."
Algebra`MatrixPowerMod::arg1 = "The first argument `1` of MatrixPowerMod is not a square matrix with integer coefficients."
Algebra`MatrixPowerMod::arg2 = "The second argument `1` of MatrixPowerMod is not an integer."
Algebra`MatrixPowerMod::arg3 = "The third argument `1` of MatrixPowerMod is not a nonzero integer."
Maximize::consc = Minimize::consc = MinValue::consc = MaxValue::consc = ArgMin::consc = ArgMax::consc = "The constraint `1` contains a nonreal constant `2`."
Maximize::consf = Minimize::consf = MinValue::consf = MaxValue::consf = ArgMin::consf = ArgMax::consf = "Invalid constraint `1` encountered. Constraints should be equations, inequalities, or variable domain specifications."
Maximize::consv = Minimize::consv = MinValue::consv = MaxValue::consv = ArgMin::consv = ArgMax::consv = "The constraint `1` contains a nonconstant expression `2` independent of variables `3`."
Maximize::mixdom = Minimize::mixdom = MinValue::mixdom = MaxValue::mixdom = ArgMin::mixdom = ArgMax::mixdom = "Exact optimization with mixed real and integer variables is not yet implemented."
Maximize::noobj = Minimize::noobj = MinValue::noobj = MaxValue::noobj = ArgMin::noobj = ArgMax::noobj = NMaximize::noobj = NMinimize::noobj = NMinValue::noobj = NMaxValue::noobj = NArgMin::noobj = NArgMax::noobj = "No objective function specified."
Maximize::nopmet = Minimize::nopmet = MinValue::nopmet = MaxValue::nopmet = ArgMin::nopmet = ArgMax::nopmet = "This optimization problem cannot be solved with methods available to `1`."
Maximize::natt = ArgMax::natt = "The maximum is not attained at any point satisfying the given constraints. "
Maximize::infeas = Minimize::infeas = MinValue::infeas = MaxValue::infeas = ArgMin::infeas = ArgMax::infeas = "There are no values of `1` for which the constraints `2` are satisfied and the objective function `3` is real-valued. "
Maximize::objc = Minimize::objc = MinValue::objc = MaxValue::objc = ArgMin::objc = ArgMax::objc = "The objective function `1` contains a nonreal constant `2`."
Maximize::objv = Minimize::objv = MinValue::objv = MaxValue::objv = ArgMin::objv = ArgMax::objv = "The objective function `1` contains a nonconstant expression `2` independent of variables `3`."
Maximize::vdom = Minimize::vdom = MinValue::vdom = MaxValue::vdom = ArgMin::vdom = ArgMax::vdom = NMaximize::vdom = NMinimize::vdom = NMinValue::vdom = NMaxValue::vdom = NArgMin::vdom = NArgMax::vdom = "Variable domain `1` should be either Reals or Integers."
Maximize::vlist = Minimize::vlist = MinValue::vlist = MaxValue::vlist = ArgMin::vlist = ArgMax::vlist = FindInstance::vlist = SatisfiabilityCount::vlist = SatisfiabilityInstances::vlist = SatisfiableQ::vlist = TautologyQ::vlist = "The variable list `1` should be non-empty."
Maximize::wksol = ArgMax::wksol = "Warning: there is no maximum in the region in which the objective function is defined and the constraints are satisfied; a result on the boundary will be returned."
Maximize::nmpt = "Unable to find a point where the maximum is attained."
Minimize::nmpt = "Unable to find a point where the minimum is attained."
General::objfs = "The objective function `1` should be scalar\[Hyphen]valued."
General::wfeq = "`1` is not a well\[Hyphen]formed equation or inequality."
General::hdiv = "`1` does not exist. Arguments are not consistent."
MeijerG::rarg = "MeijerG is used with an abstract optional parameter. `1` is not defined for every complex value of its optional parameter."
MemoryInUse::memnf = "MemoryInUse of `1` is not supported."
MeshStyle::mesh = "`1` is not a valid MeshStyle specification. Using the default."
Message::msgl = "$MessageList `1` not a list; reset to {}."
Message::name = "Message name `1` is not of the form symbol::name or symbol::name::language."
Message::nostack = "There is no stack trace information available for this message."
MessageName::messg = "`1` cannot be set to `2`. It must be set to a string."
General::mgre = "Message group `1` was not resolved to a list of messages of the form symbol::name or symbol::name::language."
Minimize::wksol = ArgMin::wksol = "Warning: there is no minimum in the region in which the objective function is defined and the constraints are satisfied; returning a result on the boundary."
Minimize::natt = ArgMin::natt = "The minimum is not attained at any point satisfying the given constraints."
Monitor::bddly = "The value `1` given for the delay is not a positive number or time increment; proceeding with the default delay."
Monitor::nodly = "Monitor with a delay is not supported by this version of the front end. Proceeding without delay."
N::arg = "Argument `1` is not of the form {precision, accuracy}."
NDEigensystem::baddep = NDEigenvalues::baddep = "The dependent variables specification (`1`) does not match the differential operator dependent variables."
NDEigensystem::badnorm = NDEigenvalues::badnorm = "Normalization did not produce a numeric matrix of dimensions `1`."
NDEigensystem::inhbcs = NDEigenvalues::inhbcs = "Equations with inhomogeneous (nonzero) boundary conditions can currently not be solved and need to be replaced with homogeneous boundary conditions for the equations to be solvable."
NDEigensystem::maxeigen = NDEigenvalues::maxeigen = "A maximum number of `1` eigenvalues and functions can be computed for this discretized system."
NDEigensystem::negeigen = NDEigenvalues::negeigen = "Largest eigenvalues will depend on the granularity of the discretization."
NDEigensystem::nics = NDEigenvalues::nics = "Initial conditions (`1`) will be ignored."
NDEigensystem::nofemdis = NDEigenvalues::nofemdis = "Only \"FiniteElement\" is is supported as spatial discretization method."
NDEigensystem::nosdis = NDEigenvalues::nosdis = "`1` is not a valid spatial discretization method."
NDEigensystem::not = NDEigenvalues::not = "The temporal variable (`1`) can not be found in the PDE operator."
NDEigensystem::nodt = NDEigenvalues::nodt = "No temporal derivative can be found in the PDE operator."
NDEigensystem::numdep = NDEigenvalues::numdep = "The number of PDEs (`1`) does not match the number of dependent variables (`2`)."
NDEigensystem::stlin = NDEigenvalues::stlin = "Coefficients and boundary conditions need to be stationary and linear."
NDSolve::acoeffs = NDSolveValue::acoeffs = ParametricNDSolve::acoeffs = ParametricNDSolveValue::acoeffs = NDSolve`Iterate::acoeffs = "Unable to automatically determine the coefficients of the method `1`. Try specifying the coefficients as an option."
NDSolve::sprkdm = NDSolveValue::sprkdm = ParametricNDSolve::sprkdm = ParametricNDSolveValue::sprkdm = NDSolve`Iterate::sprkdm = "The dimension `1` of the differential system in the method `2` is not even."
NDSolve::sprkqv = NDSolveValue::sprkqv = ParametricNDSolve::sprkqv = ParametricNDSolveValue::sprkqv = NDSolve`Iterate::sprkqv = "The value of PositionsVariables -> `1` of the method `2` is not a valid list of position variables."
NDSolve::sprkpqv = NDSolveValue::sprkpqv = ParametricNDSolve::sprkpqv = ParametricNDSolveValue::sprkpqv = NDSolve`Iterate::sprkpqv = "The position variables `1` and momentum variables `2` of the method `3` are not consistent with the variables `4` of the differential system."
NDSolve::sprksep = NDSolveValue::sprksep = ParametricNDSolve::sprksep = ParametricNDSolveValue::sprksep = NDSolve`Iterate::sprksep = "The Hamiltonian of the differential system in the method `1` does not appear to be in separable form. Try using the method ImplicitRungeKutta with coefficients ImplicitRungeKuttaGaussCoefficients."
NDSolve::spltdep = NDSolveValue::spltdep = ParametricNDSolve::spltdep = ParametricNDSolveValue::spltdep = NDSolve`Iterate::spltdep = "The differential system `1` in the method `2` depends on `3`, which is ambiguous. The differential system should be in autonomous form."
NDSolve::spltdim = NDSolveValue::spltdim = ParametricNDSolve::spltdim = ParametricNDSolveValue::spltdim = NDSolve`Iterate::spltdim = "The dimensions `1` of the equations in the method `2` are not compatible with the dimensions `3` of the differential system."
NDSolve::mdatav = NDSolveValue::mdatav = ParametricNDSolve::mdatav = ParametricNDSolveValue::mdatav = NDSolve`Iterate::mdatav = "The `1` method data object encountered at the point `2` == `3` was generated by a previous version of NDSolve. The method will be reinitialized."
NDSolve::msols = NDSolveValue::msols = ParametricNDSolve::msols = ParametricNDSolveValue::msols = NDSolve`Iterate::msols = "Multiple solutions found using DSolve in the method `1`."
NDSolve::ndsol = NDSolveValue::ndsol = ParametricNDSolve::ndsol = ParametricNDSolveValue::ndsol = NDSolve`Iterate::ndsol = "No solution found using DSolve in the method `1`."
NDSolve::ndsnf = NDSolveValue::ndsnf = ParametricNDSolve::ndsnf = ParametricNDSolveValue::ndsnf = NDSolve`Iterate::ndsnf = "Unable to create a NumericalFunction for the expression `1` in the method `2`."
NDSolve::ndspe = NDSolveValue::ndspe = ParametricNDSolve::ndspe = ParametricNDSolveValue::ndspe = NDSolve`Iterate::ndspe = "Unable to process the equations `1` in the method `2`."
NDSolve::nlst = NDSolveValue::nlst = ParametricNDSolve::nlst = ParametricNDSolveValue::nlst = NDSolve`Iterate::nlst = "`1` in the method `2` is not a list of length `3`."
NDSolve::nfun = NDSolveValue::nfun = ParametricNDSolve::nfun = ParametricNDSolveValue::nfun = NDSolve`Iterate::nfun = "`1` of the method `2` is not a function."
NDSolve::sfun = NDSolveValue::sfun = ParametricNDSolve::sfun = ParametricNDSolveValue::sfun = NDSolve`Iterate::sfun = "Invalid simplification function `1` in the method `2`."
NDSolve::csymb = NDSolveValue::csymb = ParametricNDSolve::csymb = ParametricNDSolveValue::csymb = NDSolve`Iterate::csymb = "Value of `1` -> `2` of the method `3` is not a symbol."
NDSolve::bcart = NDSolveValue::bcart = ParametricNDSolve::bcart = ParametricNDSolveValue::bcart = NDSolve`ProcessEquations::bcart = "Warning: an insufficient number of boundary conditions have been specified for the direction of independent variable `1`. Artificial boundary effects may be present in the solution."
NDSolve::bcedge = NDSolveValue::bcedge = ParametricNDSolve::bcedge = ParametricNDSolveValue::bcedge = NDSolve`ProcessEquations::bcedge = NDEigenvalues::bcedge = NDEigensystem::bcedge = "Boundary condition `1` is not specified on a single edge of the boundary of the computational domain."
NDSolve::bcedgev = NDSolveValue::bcedgev = ParametricNDSolve::bcedgev = ParametricNDSolveValue::bcedgev = NDSolve`ProcessEquations::bcedgev = "Boundary conditions specified at the edge of the domain with variable `1` constant should be independent of `1`."
NDSolve::bcnan = NDSolveValue::bcnan = ParametricNDSolve::bcnan = ParametricNDSolveValue::bcnan = NDSolve`ProcessEquations::bcnan = "Boundary conditions not numerical."
NDSolve::bcnorm = NDSolveValue::bcnorm = ParametricNDSolve::bcnorm = ParametricNDSolveValue::bcnorm = NDSolve`ProcessEquations::bcnorm = "Boundary condition `1` includes non-normal derivatives."
NDSolve::bdord = NDSolveValue::bdord = ParametricNDSolve::bdord = ParametricNDSolveValue::bdord = NDSolve`ProcessEquations::bdord = "Boundary condition `1` should have derivatives of order lower than the differential order of the partial differential equation."
NDSolve::bcsol = NDSolveValue::bcsol = ParametricNDSolve::bcsol = ParametricNDSolveValue::bcsol = NDSolve`ProcessEquations::bcsol = "Could not solve for equations at boundary points from the boundary conditions."
NDSolve::bcuns = NDSolveValue::bcuns = ParametricNDSolve::bcuns = ParametricNDSolveValue::bcuns = NDSolve`ProcessEquations::bcuns = "Boundary condition `1` cannot be satisfied in general."
NDSolve::bcnop = NDSolveValue::bcnop = ParametricNDSolve::bcnop = ParametricNDSolveValue::bcnop = NDEigensystem::bcnop = NDEigenvalues::bcnop = NDSolve`ProcessEquations::bcnop = NDSolve`FEM`DiscretizeBoundaryConditions::bcnop = "No places were found on the boundary where `1` was True, so `2` will effectively be ignored."
NDSolve::bddo = NDSolveValue::bddo = ParametricNDSolve::bddo = ParametricNDSolveValue::bddo = NDSolve`ProcessEquations::bddo = "Value of option DifferenceOrder -> `1` should be a positive integer or \"Pseudospectral\"."
NDSolve::bdmtd = NDSolveValue::bdmtd = ParametricNDSolve::bdmtd = ParametricNDSolveValue::bdmtd = NDSolve`ProcessEquations::bdmtd = "The value of the option Method -> `1` is not a known built-in method, a symbol that could be a user-defined method, or a list with a name followed by method options."
NDSolve::bdiseed = NDSolveValue::bdiseed = ParametricNDSolve::bdiseed = ParametricNDSolveValue::bdiseed = NDSolve`ProcessEquations::bdiseed = "The equations given in the InitialSeeding option did all have the same value of the temporal variable as the initial conditions."
NDSolve::iseedt = NDSolveValue::iseedt = ParametricNDSolve::iseedt = ParametricNDSolveValue::iseedt = NDSolve`ProcessEquations::iseedt = "The equations given in the InitialSeeding option should be in the form u[...] == rhs where u is a dependent variable and rhs does not depend on any of the dependent variables."
NDSolve::nostep = NDSolveValue::nostep = ParametricNDSolve::nostep = ParametricNDSolveValue::nostep = NDSolve`ProcessEquations::nostep = "The method specified by Method -> `1` is not a known built-in method and has not been properly set up as a user-defined method with a Step function."
NDSolve::baddo = NDSolveValue::baddo = ParametricNDSolve::baddo = ParametricNDSolveValue::baddo = NDSolve`ProcessEquations::baddo = "The method `1` returned `2` for dense output data, which is not in the correct form."
NDSolve::bdstep = NDSolveValue::bdstep = ParametricNDSolve::bdstep = ParametricNDSolveValue::bdstep = NDSolve`ProcessEquations::bdstep = "The Step function for Method -> `1` returned `2`, which is not an acceptable form."
NDSolve::berr = NDSolveValue::berr = ParametricNDSolve::berr = ParametricNDSolveValue::berr = NDSolve`ProcessEquations::berr = "The scaled boundary value residual error of `1` indicates that the boundary values are not satisfied to specified tolerances. Returning the best solution found."
NDSolve::bvlin = NDSolveValue::bvlin = ParametricNDSolve::bvlin = ParametricNDSolveValue::bvlin = NDSolve`ProcessEquations::bvlin = "The differential equation(s) and/or boundary conditions are not linear in the dependent variables. Method -> Chasing requires linearity to compute the solution of a multipoint boundary value problem."
NDSolve::bvluc = NDSolveValue::bvluc = ParametricNDSolve::bvluc = ParametricNDSolveValue::bvluc = NDSolve`ProcessEquations::bvluc = "The equations derived from the boundary conditions are numerically ill-conditioned. The boundary conditions may not be sufficient to uniquely define a solution. If a solution is computed, it may match the boundary conditions poorly."
NDSolve::bvls = NDSolveValue::bvls = ParametricNDSolve::bvls = ParametricNDSolveValue::bvls = NDSolve`ProcessEquations::bvls = "Unable to resolve the conditions derived from the given boundary conditions. It is possible there is no solution for the given boundary value problem."
NDSolve::bvlind = NDSolveValue::bvlind = ParametricNDSolve::bvlind = ParametricNDSolveValue::bvlind = NDSolve`ProcessEquations::bvlind = "Boundary conditions are not linearly independent."
NDSolve::bvaux = NDSolveValue::bvaux = ParametricNDSolve::bvaux = ParametricNDSolveValue::bvaux = NDSolve`ProcessEquations::bvaux = "Unable to solve auxiliary system for boundary condition at `1` == `2`."
NDSolve::bvep = NDSolveValue::bvep = ParametricNDSolve::bvep = ParametricNDSolveValue::bvep = NDSolve`ProcessEquations::bvep = "Value of option `1` -> `2` should be a non-negative real number."
NDSolve::bvcrat = NDSolveValue::bvcrat = ParametricNDSolve::bvcrat = ParametricNDSolveValue::bvcrat = NDSolve`ProcessEquations::bvcrat = "Value of option `1` -> `2` should be a nonzero real number."
NDSolve::bvdae = NDSolveValue::bvdae = ParametricNDSolve::bvdae = ParametricNDSolveValue::bvdae = NDSolve`ProcessEquations::bvdae = NDSolve`Reinitialize::bvdae = "Differential-algebraic equations must be given as initial value problems."
NDSolve::fembct = NDSolveValue::fembct = ParametricNDSolve::fembct = ParametricNDSolveValue::fembct = NDSolve`ProcessEquations::fembct = "Some of the boundary conditions `1` depend on the time variable `2`. Time-dependent boundary conditions are not supported in this version of NDSolve."
NDSolve::cprec = NDSolveValue::cprec = ParametricNDSolve::cprec = ParametricNDSolveValue::cprec = NDSolve`Iterate::cprec = "The precision `1` of the coefficients of the method `2` is not consistent with the working precision `3`."
NDSolve::cconst = NDSolveValue::cconst = ParametricNDSolve::cconst = ParametricNDSolveValue::cconst = NDSolve`Iterate::cconst = "The coefficients `1` of `2` do not give a consistent method."
NDSolve::cdims = NDSolveValue::cdims = ParametricNDSolve::cdims = ParametricNDSolveValue::cdims = NDSolve`Iterate::cdims = "The dimensions of the options `1`, `2`, and `3` of the method `4` are not compatible."
NDSolve::cstruct = NDSolveValue::cstruct = ParametricNDSolve::cstruct = ParametricNDSolveValue::cstruct = NDSolve`Iterate::cstruct = "The coefficients `1` of `2` do not have the correct structure."
NDSolve::nosubmtd = NDSolveValue::nosubmtd = ParametricNDSolve::nosubmtd = ParametricNDSolveValue::nosubmtd = NDSolve`Iterate::nosubmtd = "The method `1` requires that a submethod be specified using the Method option."
NDSolve::nosubmtds = NDSolveValue::nosubmtds = ParametricNDSolve::nosubmtds = ParametricNDSolveValue::nosubmtds = NDSolve`Iterate::nosubmtds = "The method `1` requires that submethods be specified using the Method option."
NDSolve::submtd = NDSolveValue::submtd = ParametricNDSolve::submtd = ParametricNDSolveValue::submtd = NDSolve`Iterate::submtd = "`1` is not a valid submethod."
NDSolve::submtds = NDSolveValue::submtds = ParametricNDSolve::submtds = ParametricNDSolveValue::submtds = NDSolve`Iterate::submtds = "`1` is not a valid list of submethods of the method `2`."
DSolve::conarg = NDSolve::conarg = NDSolveValue::conarg = ParametricNDSolve::conarg = ParametricNDSolveValue::conarg = NDSolve`ProcessEquations::conarg = RSolve::conarg = NDEigensystem::conarg = NDEigenvalues::conarg = "The arguments should be ordered consistently."
DSolve::dvnoarg = NDSolve::dvnoarg = NDSolveValue::dvnoarg = ParametricNDSolve::dvnoarg = ParametricNDSolveValue::dvnoarg = NDSolve`ProcessEquations::dvnoarg = RSolve::dvnoarg = RecurrenceTable::dvnoarg = NDEigensystem::dvnoarg = NDEigenvalues::dvnoarg = "The function `1` appears with no arguments."
DSolve::ivhead = NDSolve::ivhead = NDSolveValue::ivhead = ParametricNDSolve::ivhead = ParametricNDSolveValue::ivhead = NDSolve`ProcessEquations::ivhead = RSolve::ivhead = "The independent variable `1` appears in the head of the expression `2`. The independent variables should always be arguments."
DSolve::dvleaf = NDSolve::dvleaf = NDSolveValue::dvleaf = ParametricNDSolve::dvleaf = ParametricNDSolveValue::dvleaf = NDSolve`ProcessEquations::dvleaf = RSolve::dvleaf = "The function `1` appears as the head of the expression `2`."
NDSolve::delpde = NDSolveValue::delpde = ParametricNDSolve::delpde = ParametricNDSolveValue::delpde = NDSolve`ProcessEquations::delpde = "Delay partial differential equations are not currently supported by NDSolve."
DSolve::der1 = NDSolve::der1 = NDSolveValue::der1 = ParametricNDSolve::der1 = ParametricNDSolveValue::der1 = NDSolve`ProcessEquations::der1 = "The derivative operator `1` in `2` should operate on only one function."
DSolve::derlen = NDSolve::derlen = NDSolveValue::derlen = ParametricNDSolve::derlen = ParametricNDSolveValue::derlen = NDSolve`ProcessEquations::derlen = "The length of the derivative operator `1` in `2` is not the same as the number of arguments."
DSolve::derarg = NDSolve::derarg = NDSolveValue::derarg = ParametricNDSolve::derarg = ParametricNDSolveValue::derarg = NDSolve`ProcessEquations::derarg = "The derivative operator `1` in `2` should act on the pure function."
DSolve::nestdv = NDSolve::nestdv = NDSolveValue::nestdv = ParametricNDSolve::nestdv = ParametricNDSolveValue::nestdv = NDSolve`ProcessEquations::nestdv = RSolve::nestdv = "The expression `1` has nested dependent variables."
DSolve::dvlen = NDSolve::dvlen = NDSolveValue::dvlen = ParametricNDSolve::dvlen = ParametricNDSolveValue::dvlen = NDSolve`ProcessEquations::dvlen = RSolve::dvlen = NDEigensystem::dvlen = NDEigenvalues::dvlen = RecurrenceTable::dvlen = "The function `1` does not have the same number of arguments as independent variables (`2`)."
RSolveValue::dvlen = "The dependent function has an incorrect number of arguments."
DSolve::dvlist = NDSolve::dvlist = NDSolveValue::dvlist = ParametricNDSolve::dvlist = ParametricNDSolveValue::dvlist = NDSolve`ProcessEquations::dvlist = RSolve::dvlist = "The function `1` should only have scalar arguments corresponding to the independent variables."
NDSolve::depvr = NDSolveValue::depvr = ParametricNDSolve::depvr = ParametricNDSolveValue::depvr = NDSolve`ProcessEquations::depvr = "The dependent variable cannot be found in the equation."
NDSolve::nodv = NDSolveValue::nodv = ParametricNDSolve::nodv = ParametricNDSolveValue::nodv = NDSolve`ProcessEquations::nodv = "No dependent variables were found in the equations. Make sure that the specified functions appear with the independent variables in the arguments, as in x[t]. You may want to specify them explicitly using the DependentVariables option."
NDSolve::noout = NDSolveValue::noout = ParametricNDSolve::noout = ParametricNDSolveValue::noout = NDSolve`ProcessEquations::noout = "No functions were specified for output from NDSolveValue."
NDSolve::dvout = NDSolveValue::dvout = ParametricNDSolve::dvout = ParametricNDSolveValue::dvout = NDSolve`ProcessEquations::dvout = RecurrenceTable::dvout = "The output function `1` is not one of the dependent variables `2`."
NDSolve::uniss = NDSolveValue::uniss = ParametricNDSolve::uniss = ParametricNDSolveValue::uniss = NDSolve`ProcessEquations::uniss = "The spacing specified by MinStepSize -> `1` and MaxStepSize -> `2` for independent variable `3` cannot be used to construct a uniform grid on an interval of length `4`. Using spacing `5` instead."
NDSolve::eerr = NDSolveValue::eerr = ParametricNDSolve::eerr = ParametricNDSolveValue::eerr = NDSolve`Iterate::eerr = "Warning: scaled local spatial error estimate of `1` at `2` = `3` in the direction of independent variable `4` is much greater than the prescribed error tolerance. Grid spacing with `5` points may be too large to achieve the desired accuracy or precision. A singularity may have formed or a smaller grid spacing can be specified using the MaxStepSize or MinPoints method options."
NDSolve::eerri = NDSolveValue::eerri = ParametricNDSolve::eerri = ParametricNDSolveValue::eerri = NDSolve`ProcessEquations::eerri = "Warning: estimated initial error on the specified spatial grid in the direction of independent variable `1` exceeds prescribed error tolerance."
NDSolve::ibcinc = NDSolveValue::ibcinc = ParametricNDSolve::ibcinc = ParametricNDSolveValue::ibcinc = NDSolve`ProcessEquations::ibcinc = "Warning: boundary and initial conditions are inconsistent."
NDSolve::bcincd = NDSolveValue::bcincd = ParametricNDSolve::bcincd = ParametricNDSolveValue::bcincd = NDSolve`ProcessEquations::bcincd = "Inconsistent multiple Dirichlet boundary conditions specified at points `1`."
NDSolve::bcovl = NDSolveValue::bcovl = ParametricNDSolve::bcovl = ParametricNDSolveValue::bcovl = NDSolve`ProcessEquations::bcovl = "Warning: there are boundary elements where multiple boundary conditions have been specified."
NDSolve`StateData::vdobj = NDSolve::vdobj = NDSolveValue::vdobj = ParametricNDSolve::vdobj = ParametricNDSolveValue::vdobj = NDSolve`ProcessEquations::vdobj = NDSolve`Iterate::vdobj = "Encountered `1`, which is not a valid `2` expression."
NDSolve::ininv = NDSolveValue::ininv = ParametricNDSolve::ininv = ParametricNDSolveValue::ininv = NDSolve`Iterate::ininv = "Unable to ascertain the initial data for the invariants in the method `1`."
NDSolve::intor = NDSolveValue::intor = ParametricNDSolve::intor = ParametricNDSolveValue::intor = NDSolve`ProcessEquations::intor = NDSolve`Reinitialize::intor = "Value of InterpolationOrder -> `1` should be Automatic, All, or a positive integer."
NDSolve::ivone = NDSolveValue::ivone = ParametricNDSolve::ivone = ParametricNDSolveValue::ivone = NDEigensystem::ivone = NDEigenvalues::ivone = NDSolve`ProcessEquations::ivone = "Boundary values may only be specified for one independent variable. Initial values may only be specified at one value of the other independent variable."
NDSolve::maxit = NDSolveValue::maxit = ParametricNDSolve::maxit = ParametricNDSolveValue::maxit = NDSolve`ProcessEquations::maxit = "Maximum number of iterations `1` reached at `2` = `3`."
NDSolve::mmpts = NDSolveValue::mmpts = ParametricNDSolve::mmpts = ParametricNDSolveValue::mmpts = NDSolve`ProcessEquations::mmpts = "Number of steps for independent variable `1` required by MaxStepSize -> `2` or MinPoints -> `3` is greater than the number of steps allowed by MinStepSize -> `4` and/or MaxPoints -> `5`."
NDSolve::dored = NDSolveValue::dored = ParametricNDSolve::dored = ParametricNDSolveValue::dored = NDSolve`ProcessEquations::dored = "The maximum number of spatial points (`1`) for independent variable `2` allowed by MaxPoints -> `3` or MinStepSize -> `4` is too few for DifferenceOrder -> `5`. Spatial difference order for `2` will be reduced to `6`."
NDSolve::nerres = NDSolveValue::nerres = ParametricNDSolve::nerres = ParametricNDSolveValue::nerres = NDSolve`ProcessEquations::nerres = "The maximum number of spatial points (`1`) for independent variable `2` allowed by MaxPoints -> `3` or MinStepSize -> `4` is too few to compute a spatial error estimate."
NDSolve::eveerr = NDSolveValue::eveerr = ParametricNDSolve::eveerr = ParametricNDSolveValue::eveerr = NDSolve`ProcessEquations::eveerr = "The specified spatial grid in the direction of independent variable `1` has an even number of points (`2`) and the pseudospectral grid cannot be subdivided in two, so no spatial error estimate will be done on the final result in this direction."
NDSolve::stpmin = NDSolveValue::stpmin = ParametricNDSolve::stpmin = ParametricNDSolveValue::stpmin = NDSolve`ProcessEquations::stpmin = "The starting number of points determined by StartingStepSize -> `3` and StartingPoints -> `4` is `1`, which is less than the minimum number of `2` grid points. `2` will be used instead."
NDSolve::stpmax = NDSolveValue::stpmax = ParametricNDSolve::stpmax = ParametricNDSolveValue::stpmax = NDSolve`ProcessEquations::stpmax = "The starting number of points determined by StartingStepSize -> `3` and StartingPoints -> `4` is `1`, which is greater than the maximum number of `2` grid points. `2` will be used instead."
NDSolve::stps = NDSolveValue::stps = ParametricNDSolve::stps = ParametricNDSolveValue::stps = NDSolve`ProcessEquations::stps = "Only one of StartingPoints and StartingStepSize should be specified at a time. StartingPoints -> `1` will be used and StartingStepSize -> `2` will be disregarded."
NDSolve::maxits = NDSolveValue::maxits = ParametricNDSolve::maxits = ParametricNDSolveValue::maxits = NDSolve`Iterate::maxits = "The number of iterations `1` in the method `2` is not Automatic, a positive machine integer, or Infinity."
NDSolve::bool = NDSolveValue::bool = ParametricNDSolve::bool = ParametricNDSolveValue::bool = NDSolve`ProcessEquations::bool = "The value of the option `1` -> `2` in the method `3` is not True or False."
NDSolve::pma = NDSolveValue::pma = ParametricNDSolve::pma = ParametricNDSolveValue::pma = NDSolve`ProcessEquations::pma = "The value of the option `1` -> `2` in the method `3` is not a positive machine integer or Automatic."
NDSolve::pmi = NDSolveValue::pmi = ParametricNDSolve::pmi = ParametricNDSolveValue::pmi = NDSolve`ProcessEquations::pmi = "The value of the option `1` -> `2` in the method `3` is not a positive machine integer or Infinity."
NDSolve::pmi2 = NDSolveValue::pmi2 = ParametricNDSolve::pmi2 = ParametricNDSolveValue::pmi2 = NDSolve`ProcessEquations::pmi2 = "The value of the option `1` -> `2` in the method `3` is not a list {i, j} of positive machine integers or Infinity."
General::moptxn = "The option `1` of the method `2` is not one of `3`."
NDSolve::mrsti = NDSolveValue::mrsti = ParametricNDSolve::mrsti = ParametricNDSolveValue::mrsti = NDSolve`ProcessEquations::mrsti = NDSolve`Reinitialize::mrsti = "Number of steps `1` required by `2` -> `3` should be a machine-sized integer."
NDSolve::msti = NDSolveValue::msti = ParametricNDSolve::msti = ParametricNDSolveValue::msti = NDSolve`ProcessEquations::msti = "Number of steps `1` required by MaxStepSize -> `2` for independent variable `3` should be a machine-sized integer."
NDSolve::mxsst = NDSolveValue::mxsst = ParametricNDSolve::mxsst = ParametricNDSolveValue::mxsst = NDSolve`ProcessEquations::mxsst = "Using maximum number of grid points `1` allowed by the MaxPoints or MinStepSize options for independent variable `2`."
NDSolve::mxst = NDSolveValue::mxst = ParametricNDSolve::mxst = ParametricNDSolveValue::mxst = NDSolve`Iterate::mxst = "Maximum number of `1` steps reached at the point `2` == `3`."
NDSolve::ncsm = NDSolveValue::ncsm = ParametricNDSolve::ncsm = ParametricNDSolveValue::ncsm = NDSolve`Iterate::ncsm = "The number of coefficients `1` is not the same as the number of submethods `2` in the method `3`."
NDSolve::ndcf = NDSolveValue::ndcf = ParametricNDSolve::ndcf = ParametricNDSolveValue::ndcf = NDSolve`Iterate::ndcf = "Repeated convergence test failure at `1` == `2`; unable to continue."
NDSolve::lsf = NDSolveValue::lsf = ParametricNDSolve::lsf = ParametricNDSolveValue::lsf = NDSolve`Iterate::lsf = "Unable to solve required system of linear equations to `1` == `2`."
NDSolve::nderr = NDSolveValue::nderr = ParametricNDSolve::nderr = ParametricNDSolveValue::nderr = NDSolve`Iterate::nderr = "Error test failure at `1` == `2`; unable to continue."
NDSolve::ndinnt = NDSolveValue::ndinnt = ParametricNDSolve::ndinnt = ParametricNDSolveValue::ndinnt = NDSolve`ProcessEquations::ndinnt = "Initial condition `1` is not a number or a rectangular array of numbers."
NDSolve::ndincd = NDSolveValue::ndincd = ParametricNDSolve::ndincd = ParametricNDSolveValue::ndincd = NDSolve`ProcessEquations::ndincd = NDSolve`Reinitialize::ndincd = "Initial conditions for derivatives of the function `1` do not have consistent dimensions."
NDSolve::ndincb = NDSolveValue::ndincb = ParametricNDSolve::ndincb = ParametricNDSolveValue::ndincb = NDSolve`ProcessEquations::ndincb = "Initial conditions are not of consistent dimensionality."
NDSolve::ndinpd = NDSolveValue::ndinpd = ParametricNDSolve::ndinpd = ParametricNDSolveValue::ndinpd = NDSolve`ProcessEquations::ndinpd = "The initial conditions did not evaluate to an array of numbers of depth `1` on the spatial grid. Initial conditions for partial differential equations should be specified as scalar functions of the spatial variables."
NDSolve::ndinid = NDSolveValue::ndinid = ParametricNDSolve::ndinid = ParametricNDSolveValue::ndinid = NDSolve`ProcessEquations::ndinid = "Initial condition `1` is not in the range specified by the discrete variable `2`."
NDSolve::ndstinv = NDSolveValue::ndstinv = ParametricNDSolve::ndstinv = ParametricNDSolveValue::ndstinv = NDSolve`ProcessEquations::ndstinv = "Invocation of the method `1` requires the `2` object."
NDSolve::opdims = NDSolveValue::opdims = ParametricNDSolve::opdims = ParametricNDSolveValue::opdims = NDSolve`Iterate::opdims = "The value of `1` -> `2` of the method `3` is not a pair of positive integers {n, m} with n >= m and n*m equal to `4`."
NDSolve::opmdims = NDSolveValue::opmdims = ParametricNDSolve::opmdims = ParametricNDSolveValue::opmdims = NDSolve`Iterate::opmdims = "The dimensions `1` of the matrix function in the method `2` are not compatible with the specified dimensions `4`."
NDSolve`Reinitialize::ndincb = "The new initial conditions need to have the same dimensions as the original ones."
NDSolve::ndlim = NDSolveValue::ndlim = ParametricNDSolve::ndlim = ParametricNDSolveValue::ndlim = NDSolve`ProcessEquations::ndlim = "Range specification `1` is not of the form {x, xend} or {x, xmin, xmax}."
NDSolve::ndlims = NDSolveValue::ndlims = ParametricNDSolve::ndlims = ParametricNDSolveValue::ndlims = NDSolve`ProcessEquations::ndlims = "Range specification for spatial variable `1` needs to have two endpoints."
NDSolve::ndmss = NDSolveValue::ndmss = ParametricNDSolve::ndmss = ParametricNDSolveValue::ndmss = NDSolve`ProcessEquations::ndmss = NDSolve`Reinitialize::ndmss = "Value of option `1` -> `2` is not a positive real number or Infinity."
NDSolve::ndnco = NDSolveValue::ndnco = ParametricNDSolve::ndnco = ParametricNDSolveValue::ndnco = NDSolve`ProcessEquations::ndnco = NDSolve`Reinitialize::ndnco = "The number of constraints (`1`) (initial conditions) is not equal to the total differential order of the system plus the number of discrete variables (`2`)."
NDSolve::ndncov = NDSolveValue::ndncov = ParametricNDSolve::ndncov = ParametricNDSolveValue::ndncov = NDSolve`ProcessEquations::ndncov = NDSolve`Reinitialize::ndncov = "The number of constraints (initial conditions) for function `1` is insufficient for its differential order (`2`)."
NDSolve`Reinitialize::ndncon = "For reinitialization, equations should all be initial conditions."
NDSolve`Reinitialize::ndcinit = NDSolve`Shooting::ndcinit = "Initial conditions should be specified at a single point."
NDSolve::ndnl = NDSolveValue::ndnl = ParametricNDSolve::ndnl = ParametricNDSolveValue::ndnl = NDSolve`ProcessEquations::ndnl = NDSolve`Iterate::ndnl = "Endpoint `1` in `2` is not a real number."
NDSolve::ndnum = NDSolveValue::ndnum = ParametricNDSolve::ndnum = ParametricNDSolveValue::ndnum = NDSolve`ProcessEquations::ndnum = "Encountered non-numerical value for a derivative at `1` == `2`."
NDSolve::ndfdmc = NDSolveValue::ndfdmc = ParametricNDSolve::ndfdmc = ParametricNDSolveValue::ndfdmc = NDSolve`ProcessEquations::ndfdmc = "Computed derivatives do not have dimensionality consistent with the initial conditions."
NDSolve::ndode = NDSolveValue::ndode = ParametricNDSolve::ndode = ParametricNDSolveValue::ndode = NDEigensystem::ndode = NDEigenvalues::ndode = NDSolve`ProcessEquations::ndode = "The equations `1` are not differential equations or initial conditions in the dependent variables `2`."
NDSolve::ndsnorm = NDSolveValue::ndsnorm = ParametricNDSolve::ndsnorm = ParametricNDSolveValue::ndsnorm = NDSolve`ProcessEquations::ndsnorm = NDSolve`Reinitialize::ndsnorm = "Value of option NormFunction -> `1` is not Automatic or a function that gives a legitimate norm."
NDSolve::ndsnr = NDSolveValue::ndsnr = ParametricNDSolve::ndsnr = ParametricNDSolveValue::ndsnr = NDSolve`Iterate::ndsnr = "Step size was not real at `1` == `2`."
NDSolve::ndssc = NDSolveValue::ndssc = ParametricNDSolve::ndssc = ParametricNDSolveValue::ndssc = NDSolve`Iterate::ndssc = "Step size changed sign at `1` == `2`."
NDSolve::ndsss = NDSolveValue::ndsss = ParametricNDSolve::ndsss = ParametricNDSolveValue::ndsss = NDSolve`ProcessEquations::ndsss = NDSolve`Reinitialize::ndsss = "Value of StartingStepSize -> `1` is not a positive real number or Automatic."
NDSolve::ndstab = NDSolveValue::ndstab = ParametricNDSolve::ndstab = ParametricNDSolveValue::ndstab = NDSolve`Iterate::ndstab = "Stability check failed at `1` == `2`."
NDSolve::sprcv = NDSolveValue::sprcv = ParametricNDSolve::sprcv = ParametricNDSolveValue::sprcv = NDSolve`ProcessEquations::sprcv = "Warning: the spectral radius estimate in `1` did not converge at `2` == `3`."
NDSolve::nstmtd = NDSolveValue::nstmtd = ParametricNDSolve::nstmtd = ParametricNDSolveValue::nstmtd = NDSolve`ProcessEquations::nstmtd = "The value of the option `1` -> `2` in `3` should be one of Automatic, Direct, False, KrylovIteration, None, NormBound, or SubspaceIteration."
NDSolve::ndstf = NDSolveValue::ndstf = ParametricNDSolve::ndstf = ParametricNDSolveValue::ndstf = NDSolve`Iterate::ndstf = "At `1` == `2`, system appears to be stiff. Methods Automatic, BDF, or StiffnessSwitching may be more appropriate."
NDSolve::ndsv = NDSolveValue::ndsv = ParametricNDSolve::ndsv = ParametricNDSolveValue::ndsv = NDSolve`ProcessEquations::ndsv = NDSolve`Reinitialize::ndsv = "Cannot find starting value for the variable `1`."
NDSolve::ndsz = NDSolveValue::ndsz = ParametricNDSolve::ndsz = ParametricNDSolveValue::ndsz = NDSolve`Iterate::ndsz = "At `1` == `2`, step size is effectively zero; singularity or stiff system suspected."
NDSolve::ndtolp = NDSolveValue::ndtolp = ParametricNDSolve::ndtolp = ParametricNDSolveValue::ndtolp = NDSolve`Iterate::ndtolp = "Tolerances requested by the AccuracyGoal and PrecisionGoal options are too stringent for the working precision `1`."
NDSolve::ndtol = NDSolveValue::ndtol = ParametricNDSolve::ndtol = ParametricNDSolveValue::ndtol = NDSolve`Iterate::ndtol = "Tolerances requested by the AccuracyGoal and PrecisionGoal options could not be achieved at `1` == `2`."
NDSolve::ndtola = NDSolveValue::ndtola = ParametricNDSolve::ndtola = ParametricNDSolveValue::ndtola = NDSolve`Iterate::ndtola = "A component of the solution at `1` == `2` is essentially zero and the tolerance specified by the AccuracyGoal option could not be achieved."
NDSolve`ProcessSolutions::nodata = "No solution data was computed between `1` == `2` and `1` == `3`."
NDSolve::ivcon = NDSolveValue::ivcon = ParametricNDSolve::ivcon = ParametricNDSolveValue::ivcon = NDSolve`ProcessEquations::ivcon = NDSolve`Reinitialize::ivcon = NDEigensystem::ivcon = NDEigenvalue::ivcon = "The given initial conditions were not consistent with the differential-algebraic equations. NDSolve will attempt to correct the values."
NDSolve::ivdae = NDSolveValue::ivdae = ParametricNDSolve::ivdae = ParametricNDSolveValue::ivdae = NDSolve`ProcessEquations::ivdae = NDSolve`Reinitialize::ivdae = "For differential-algebraic equations, initial conditions need to be given for either all the non-algebraic variables or their derivatives."
NDSolve::ivres = NDSolveValue::ivres = ParametricNDSolve::ivres = ParametricNDSolveValue::ivres = NDSolve`ProcessEquations::ivres = NDSolve`Reinitialize::ivres = "NDSolve has computed initial values that give a zero residual for the differential-algebraic system, but some components are different from those specified. If you need them to be satisfied, giving initial conditions for all dependent variables and their derivatives is recommended."
NDSolve::icres = NDSolveValue::icres = ParametricNDSolve::icres = ParametricNDSolveValue::icres = NDSolve`ProcessEquations::icres = NDSolve`Reinitialize::icres = "NDSolve has computed initial values that give a zero residual for the differential system, but some components are different from those specified. If you need them to be satisfied, giving explicit initial values to all dependent variables is recommended."
NDSolve::ntdv = NDSolveValue::ntdv = ParametricNDSolve::ntdv = ParametricNDSolveValue::ntdv = NDSolve`ProcessEquations::ntdv = "Cannot solve to find an explicit formula for the derivatives. Consider using the option Method->{\"EquationSimplification\"->\"Residual\"}."
NDSolve::ntdvdae = NDSolveValue::ntdvdae = ParametricNDSolve::ntdvdae = ParametricNDSolveValue::ntdvdae = NDSolve`ProcessEquations::ntdvdae = "Cannot solve to find an explicit formula for the derivatives. NDSolve will try solving the system as differential-algebraic equations."
NDSolve::ntdvmm = NDSolveValue::ntdvmm = ParametricNDSolve::ntdvmm = ParametricNDSolveValue::ntdvmm = NDSolve`ProcessEquations::ntdvmm = "Cannot solve to find an explicit formula for the derivatives. NDSolve will try solving the system using a mass matrix method."
NDSolve::ntcs = NDSolveValue::ntcs = ParametricNDSolve::ntcs = ParametricNDSolveValue::ntcs = NDSolve`ProcessEquations::ntcs = NDSolve`Reinitialize::ntcs = "Cannot solve constraint equations for initial conditions."
NDSolve::icord = NDSolveValue::icord = ParametricNDSolve::icord = ParametricNDSolveValue::icord = NDSolve`ProcessEquations::icord = NDSolve`Reinitialize::icord = "The differential order of the functions in the initial or boundary conditions should be strictly less than in the differential equations."
NDSolve::icorddae = NDSolveValue::icorddae = ParametricNDSolve::icorddae = ParametricNDSolveValue::icorddae = NDSolve`ProcessEquations::icorddae = NDSolve`Reinitialize::icorddae = "For a system treated as a differential-algebraic equation, the differential order of the functions in the initial conditions should be equal or less than in the equations."
NDSolve::icordinit = NDSolveValue::icordinit = ParametricNDSolve::icordinit = ParametricNDSolveValue::icordinit = NDSolve`ProcessEquations::icordinit = NDSolve`Reinitialize::icordinit = "The initial values for all the dependent variables are not explicitly specified. NDSolve will attempt to find consistent initial conditions for all the variables."
NDSolve::mdata = NDSolveValue::mdata = ParametricNDSolve::mdata = ParametricNDSolveValue::mdata = NDSolve`Iterate::mdata = "An invalid `1` method data object was encountered at the point `2` == `3`."
NDSolve::stins = NDSolveValue::stins = ParametricNDSolve::stins = ParametricNDSolveValue::stins = NDSolve`Iterate::stins = "Invalid step function input(s) `1`."
NDSolve::stouts = NDSolveValue::stouts = ParametricNDSolve::stouts = ParametricNDSolveValue::stouts = NDSolve`Iterate::stouts = "Invalid step function output(s) `1`."
NDSolve::stein = NDSolveValue::stein = ParametricNDSolve::stein = ParametricNDSolveValue::stein = NDSolve`Iterate::stein = "Invalid step function input list `1`."
NDSolve::steout = NDSolveValue::steout = ParametricNDSolve::steout = ParametricNDSolveValue::steout = NDSolve`Iterate::steout = "Invalid step function output list `1`."
NDSolve::stfargs = NDSolveValue::stfargs = ParametricNDSolve::stfargs = ParametricNDSolveValue::stfargs = NDSolve`Iterate::stfargs = "Invalid argument `1` in argument `2` of step function input."
NDSolve::stin = NDSolveValue::stin = ParametricNDSolve::stin = ParametricNDSolveValue::stin = NDSolve`Iterate::stin = "Invalid function `1` in step function input."
NDSolve::pdeopt = NDSolveValue::pdeopt = ParametricNDSolve::pdeopt = ParametricNDSolveValue::pdeopt = NDSolve`ProcessEquations::pdeopt = "If the option `1` to NDSolve is a list, it must have length 2."
NDSolve::pdnbc = NDSolveValue::pdnbc = ParametricNDSolve::pdnbc = ParametricNDSolveValue::pdnbc = NDSolve`ProcessEquations::pdnbc = "Mixed periodic and Dirichlet/Neumann boundary conditions are not allowed."
NDSolve::tponly = NDSolveValue::tponly = ParametricNDSolve::tponly = ParametricNDSolveValue::tponly = NDSolve`ProcessEquations::tponly = "Currently the only discretization methods implemented are SpatialDiscretization -> TensorProductGrid or SpatialDiscretization -> FiniteElement."
NDSolve::norm = NDSolveValue::norm = ParametricNDSolve::norm = ParametricNDSolveValue::norm = NDSolve`Iterate::norm = "Invalid norm `1` in the method `2`."
NDSolve::rclist = NDSolveValue::rclist = ParametricNDSolve::rclist = ParametricNDSolveValue::rclist = NDSolve`ProcessEquations::rclist = "The value of the option `1` -> `2` should be Automatic or a list of the coordinate lists for each spatial dimension."
NDSolve::coend = NDSolveValue::coend = ParametricNDSolve::coend = ParametricNDSolveValue::coend = NDSolve`ProcessEquations::coend = "The endpoints of the grid coordinates `1` do not match those specified in `2`."
NDSolve::coexp = NDSolveValue::coexp = ParametricNDSolve::coexp = ParametricNDSolveValue::coexp = NDSolve`ProcessEquations::coexp = "Because the coordinates were explicitly given for the direction of independent variable `1`, the values of options `2` will be disregarded for this direction."
NDSolve::ssrei = NDSolveValue::ssrei = ParametricNDSolve::ssrei = ParametricNDSolveValue::ssrei = NDSolve`ProcessEquations::ssrei = "The value of the option `1` -> `2` should be a positive real number, Infinity, or Automatic."
NDSolve::ssre = NDSolveValue::ssre = ParametricNDSolve::ssre = ParametricNDSolveValue::ssre = NDSolve`ProcessEquations::ssre = "The value of the option `1` -> `2` should be a positive real number or Automatic."
NDSolve::sfty = NDSolveValue::sfty = ParametricNDSolve::sfty = ParametricNDSolveValue::sfty = NDSolve`ProcessEquations::sfty = NDSolve`Iterate::sfty = "The value of the option `1` -> `2` of the method `3` is not a real number x such that 0 < x <= 1."
NDSolve::ndsstm = NDSolveValue::ndsstm = ParametricNDSolve::ndsstm = ParametricNDSolveValue::ndsstm = NDSolve`Iterate::ndsstm = "`1` is not a `2` method in the method `3`."
NDSolve::ndsml = NDSolveValue::ndsml = ParametricNDSolve::ndsml = ParametricNDSolveValue::ndsml = NDSolve`Iterate::ndsml = "The value of `1` -> `2` should be a list of `3` methods in the method `4`."
NDSolve::mtdp = NDSolveValue::mtdp = ParametricNDSolve::mtdp = ParametricNDSolveValue::mtdp = NDSolve`Iterate::mtdp = "`1` does not have a correctly defined property `2` in `3`."
Needs::nocont = "Context `1` was not created when Needs was evaluated."
NDSolve::aord = NDSolveValue::aord = ParametricNDSolve::aord = ParametricNDSolveValue::aord = NDSolve`ProcessEquations::aord = "The selection of the order for the method `1` failed."
NDSolve::sss = NDSolveValue::sss = ParametricNDSolve::sss = ParametricNDSolveValue::sss = NDSolve`Iterate::sss = "Unable to determine a starting step size for the method `1`."
NDSolve::mconly = NDSolveValue::mconly = ParametricNDSolve::mconly = ParametricNDSolveValue::mconly = NDSolve`Iterate::mconly = "For the method `1`, only machine real code is available. Unable to continue with complex values or beyond floating-point exceptions."
NDSolve::mprec = NDSolveValue::mprec = ParametricNDSolve::mprec = ParametricNDSolveValue::mprec = NDSolve`Iterate::mprec = "For the method `1`, only machine-precision code is available."
NDSolve::nolib = NDSolveValue::nolib = ParametricNDSolve::nolib = ParametricNDSolveValue::nolib = NDSolve`ProcessEquations::nolib = "The library for the method `1` is missing, so NDSolve is unable to compute the solution."
NDSolve::nodae = NDSolveValue::nodae = ParametricNDSolve::nodae = ParametricNDSolveValue::nodae = NDSolve`Iterate::nodae = "The method `1` is not currently implemented to solve differential-algebraic equations. Use Method -> Automatic instead."
NDSolve::nodde = NDSolveValue::nodde = ParametricNDSolve::nodde = ParametricNDSolveValue::nodde = NDSolve`Iterate::nodde = "The method `1` is not currently implemented to solve delay-differential equations. Use Method -> Automatic instead."
NDSolve::cdelay = NDSolveValue::cdelay = ParametricNDSolve::cdelay = ParametricNDSolveValue::cdelay = NDSolve`Iterate::cdelay = "The method currently implemented for delay differential equations does not support delays that depend directly on the time variable or dependent variables."
NDSolve::adelay = NDSolveValue::adelay = ParametricNDSolve::adelay = ParametricNDSolveValue::adelay = NDSolve`ProcessEquations::adelay = "Computed delayed time `1` = `2` is in advance of the current integration time `3` = `4`."
NDSolve::rdelay = NDSolveValue::rdelay = ParametricNDSolve::rdelay = ParametricNDSolveValue::rdelay = NDSolve`ProcessEquations::rdelay = "Delayed time `1` = `2` computed at `3` = `4` did not evaluate to a real number."
NDSolve::sdelay = NDSolveValue::sdelay = ParametricNDSolve::sdelay = ParametricNDSolveValue::sdelay = NDSolve`ProcessEquations::sdelay = "Computed delay `1` = `2` computed at `3` = `4` is effectively zero."
NDSolve::idelay = NDSolveValue::idelay = ParametricNDSolve::idelay = ParametricNDSolveValue::idelay = NDSolve`ProcessEquations::idelay = NDSolve`Reinitialize::idelay = "Initial history needs to be specified for all variables for delay-differential equations."
NDSolve::ihdir = NDSolveValue::ihdir = ParametricNDSolve::ihdir = ParametricNDSolveValue::ihdir = NDSolve`ProcessEquations::ihdir = "Direction `1` in the initial history function is opposite in `2` to other initial history functions given."
NDSolve::ihist = NDSolveValue::ihist = ParametricNDSolve::ihist = ParametricNDSolveValue::ihist = NDSolve`ProcessEquations::ihist = "Conditions given at `1` = `2` will be interpreted as initial history functions for `3`."
NDSolve::hist = NDSolveValue::hist = ParametricNDSolve::hist = ParametricNDSolveValue::hist = NDSolve`ProcessEquations::hist = "Initial history functions need to be given for all dependent variables with delays."
NDSolve::nomm = NDSolveValue::nomm = ParametricNDSolve::nomm = ParametricNDSolveValue::nomm = NDSolve`Iterate::nomm = "The method `1` is not currently implemented to solve systems with a non-identity mass matrix. Use Method -> Automatic instead."
NDSolve::nllhs = NDSolveValue::nllhs = ParametricNDSolve::nllhs = ParametricNDSolveValue::nllhs = NDSolve`ProcessEquations::nllhs = "The system cannot be expressed in the mass matrix form because the derivatives of the dependent variables form a nonlinear system. The option Method->{\"EquationSimplification\"->\"Residual\"} can be used to solve the equations as a system of differential-algebraic equations."
NDSolve::ndmmc = NDSolveValue::ndmmc = ParametricNDSolve::ndmmc = ParametricNDSolveValue::ndmmc = NDSolve`ProcessEquations::ndmmc = "The mass matrix `1` should be a constant numerical matrix. The option Method->{\"EquationSimplification\"->\"Residual\"} can be used to solve the equations as a system of differential-algebraic equations."
NDSolve::ndmmb = NDSolveValue::ndmmb = ParametricNDSolve::ndmmb = ParametricNDSolveValue::ndmmb = NDSolve`ProcessEquations::ndmmb = "The method of lines option \"DifferentiateBoundaryConditions\"->False is incompatible with \"EquationSimplification\"->\"MassMatrix\"."
NDSolve::ndsd = NDSolveValue::ndsd = ParametricNDSolve::ndsd = ParametricNDSolveValue::ndsd = NDSolve`ProcessEquations::ndsd = "The value of the option SolveDelayed -> `1` should be Automatic, True, False, or \"MassMatrix\"."
NDSolve::icfail = NDSolveValue::icfail = ParametricNDSolve::icfail = ParametricNDSolveValue::icfail = NDSolve`Iterate::icfail = "Unable to find initial conditions that satisfy the residual function within specified tolerances. Try giving initial conditions for both values and derivatives of the functions."
NDSolve::reinitfail = NDSolveValue::reinitfail = ParametricNDSolve::reinitfail = ParametricNDSolveValue::reinitfail = NDSolve`Iterate::reinitfail = "Unable to reinitialize the system at `1` = `2` within specified tolerances."
NDSolve::invartol = NDSolveValue::invartol = ParametricNDSolve::invartol = ParametricNDSolveValue::invartol = NDSolve`Iterate::invartol = NDSolve`ProcessEquations::invartol = "The specified initial conditions do not satisfy the invariants in the method `1`."
FindMinimum::initf = FindMaximum::initf = FindArgMin::initf = FindArgMax::initf = FindMinValue::initf = FindMaxValue::initf = FindFit::initf = NonlinearModelFit::initf = NDSolve::initf = NDSolveValue::initf = ParametricNDSolve::initf = ParametricNDSolveValue::initf = NDSolve`Iterate::initf = FindRoot::initf = "The initialization of the method `1` failed."
NDSolve::lsopt = NDSolveValue::lsopt = ParametricNDSolve::lsopt = ParametricNDSolveValue::lsopt = NDSolve`ProcessEquations::lsopt = "The option `1` -> `2` should either be a single value or a list of length equal to the number of spatial independent variables, `3`."
NDSolve::molpde = NDSolveValue::molpde = ParametricNDSolve::molpde = ParametricNDSolveValue::molpde = NDSolve`ProcessEquations::molpde = "The option Method -> MethodOfLines is only legitimate for partial differential equations with more than one independent variable."
NDSolve::chbvp = NDSolveValue::chbvp = ParametricNDSolve::chbvp = ParametricNDSolveValue::chbvp = NDSolve`ProcessEquations::chbvp = "The option Method -> Chasing is only legitimate for boundary value problems with values specified at two or more distinct points."
NDSolve::jpde = NDSolveValue::jpde = ParametricNDSolve::jpde = ParametricNDSolveValue::jpde = NDSolve`ProcessEquations::jpde = "For PDEs, the Jacobian will be computed using finite differences unless you have chosen the MethodOfLines option ExpandEquationsSymbolically -> True."
NDSolve::tvar = NDSolveValue::tvar = ParametricNDSolve::tvar = ParametricNDSolveValue::tvar = NDSolve`ProcessEquations::tvar = "Value of option `1` -> `2` is not one of the independent variables `3`."
NDSolve::tvic = NDSolveValue::tvic = ParametricNDSolve::tvic = ParametricNDSolveValue::tvic = NDEigensystem::tvic = NDEigenvalues::tvic = NDSolve`ProcessEquations::tvic = "`1` cannot be used as the temporal independent variable because the conditions `2` for that dimension do not constitute sufficient initial conditions given at only one value of `1`."
NDSolve::ntsol = NDSolveValue::ntsol = ParametricNDSolve::ntsol = ParametricNDSolveValue::ntsol = NDSolve`ProcessEquations::ntsol = "This PDE can not be solved as a time dependent problem."
NDSolve::ponly = NDSolveValue::ponly = ParametricNDSolve::ponly = ParametricNDSolveValue::ponly = NDSolve`ProcessEquations::ponly = "The method given in Method -> `1` is only for equation processing and is not a time-stepping method."
NDSolve::mdo = NDSolveValue::mdo = ParametricNDSolve::mdo = ParametricNDSolveValue::mdo = NDSolve`Iterate::mdo = "The value of \"MaxDifferenceOrder\" -> `1` should be an integer from `2` through `3` for the method `4`."
NDSolve::eord = NDSolveValue::eord = ParametricNDSolve::eord = ParametricNDSolveValue::eord = NDSolve`Iterate::eord = "The value of the option `1` -> `2` should give a positive machine integer greater than 1 for the method `3`."
NDSolve::mord = NDSolveValue::mord = ParametricNDSolve::mord = ParametricNDSolveValue::mord = NDSolve`Iterate::mord = "Unable to ascertain the order of the method `1`."
NDSolve::imps = NDSolveValue::imps = ParametricNDSolve::imps = ParametricNDSolveValue::imps = NDSolve`ProcessEquations::imps = "The value of the option ImplicitSolver -> `1` should be FixedPoint or Newton."
NDSolve::impsg = NDSolveValue::impsg = ParametricNDSolve::impsg = ParametricNDSolveValue::impsg = NDSolve`ProcessEquations::impsg = "The value of the option ImplicitSolver -> `1` should be FixedPoint, Newton, or GMRES."
NDSolve::impsgm = NDSolveValue::impsgm = ParametricNDSolve::impsgm = ParametricNDSolveValue::impsgm = NDSolve`Iterate::impsgm = "ImplicitSolver -> GMRES may only be used with the BDF methods with VariableStepCoefficients -> True."
NDSolve::impsitsf = NDSolveValue::impsitsf = ParametricNDSolve::impsitsf = ParametricNDSolveValue::impsitsf = NDSolve`ProcessEquations::impsitsf = "Unable to satisfy the ImplicitSolver tolerance for IterationSafetyFactor at `1` = `2`."
NDSolve::impsagpg = NDSolveValue::impsagpg = ParametricNDSolve::impsagpg = ParametricNDSolveValue::impsagpg = NDSolve`ProcessEquations::impsagpg = "Unable to satisfy the ImplicitSolver tolerances for AccuracyGoal and PrecisionGoal at `1` = `2`."
NDSolve::bw = NDSolveValue::bw = ParametricNDSolve::bw = ParametricNDSolveValue::bw = NDSolve`Iterate::bw = "The value of the option `1` -> `2` should be a positive integer or a list of two positive integers giving upper and lower bandwidths."
NDSolve::lsband = NDSolveValue::lsband = ParametricNDSolve::lsband = ParametricNDSolveValue::lsband = NDSolve`Iterate::lsband = "\"LinearSolveMethod\" -> \"Band\" for the Newton step can only be used with \"VariableStepCoefficients\" -> True."
NDSolve::otype = NDSolveValue::otype = ParametricNDSolve::otype = ParametricNDSolveValue::otype = NDSolve`Iterate::otype = "The value of the option `1` -> `2` should be ModifiedGramSchmidt or ClassicalGramSchmidt."
NDSolve::scpar = NDSolveValue::scpar = ParametricNDSolve::scpar = ParametricNDSolveValue::scpar = NDSolve`ProcessEquations::scpar = "The value of the option `1` -> `2` of the method `3` should be Automatic or a pair of real numbers 0 <= {a, b} <= 1."
NDSolve::subsp = NDSolveValue::subsp = ParametricNDSolve::subsp = ParametricNDSolveValue::subsp = NDSolve`Iterate::subsp = "The value of `1` -> `2` should be a positive integer or Automatic."
NDSolve::ssrb = NDSolveValue::ssrb = ParametricNDSolve::ssrb = ParametricNDSolveValue::ssrb = NDSolve`ProcessEquations::ssrb = "The value of the option `1` -> `2` of the method `3` should be a pair of real numbers {0, 1} <= {a, b} <= {1, Infinity}."
NDSolve::sprest = NDSolveValue::sprest = ParametricNDSolve::sprest = ParametricNDSolveValue::sprest = NDSolve`ProcessEquations::sprest = "The value of `1` -> `2` of the method `3` should be Automatic or a positive real number."
NDSolve::maxstg = NDSolveValue::maxstg = ParametricNDSolve::maxstg = ParametricNDSolveValue::maxstg = NDSolve`Iterate::maxstg = "The value of `1` -> `2` of the method `3` should be a positive machine integer s such that s >= `4`."
NDSolve::rbnd = NDSolveValue::rbnd = ParametricNDSolve::rbnd = ParametricNDSolveValue::rbnd = NDSolve`Iterate::rbnd = "The value of `1` -> `2` of the method `3` should be a real number x such that `4` <= x <= `5`."
NDSolve::irkcargs = NDSolveValue::irkcargs = ParametricNDSolve::irkcargs = ParametricNDSolveValue::irkcargs = NDSolve`Iterate::irkcargs = "The argument `1` in ImplicitRungeKuttaCoefficients is not `2`."
NDSolve::irkcopts = NDSolveValue::irkcopts = ParametricNDSolve::irkcopts = ParametricNDSolveValue::irkcopts = NDSolve`Iterate::irkcopts = "The option `1` in ImplicitRungeKuttaCoefficients is not `2`."
NDSolve::irkcploss = NDSolveValue::irkcploss = ParametricNDSolve::irkcploss = ParametricNDSolveValue::irkcploss = NDSolve`Iterate::irkcploss = "Only obtained precision `1` of requested precision `2`. Try increasing $MaxExtraPrecision."
NDSolve`Iterate::sivpd = "The first argument `1` to `2` should be a symbol assigned to a value that is a valid `3` object."
NDSolve::ddeio = NDSolveValue::ddeio = ParametricNDSolve::ddeio = ParametricNDSolveValue::ddeio = NDSolve`Iterate::ddeio = "For delay differential equations, the output will be formed with InterpolationOrder -> All."
NDSolve::evnone = NDSolveValue::evnone = ParametricNDSolve::evnone = ParametricNDSolveValue::evnone = NDSolve`Iterate::evnone = "No events were specified for the EventLocator method."
NDSolve::evnf = NDSolveValue::evnf = ParametricNDSolve::evnf = ParametricNDSolveValue::evnf = NDSolve`ProcessEquations::evnf = "The event number `1` was not found between `2` = `3` and `2` = `4`."
NDSolve::evdir = NDSolveValue::evdir = ParametricNDSolve::evdir = ParametricNDSolveValue::evdir = NDSolve`ProcessEquations::evdir = NDSolve`Iterate::evdir = "The value of the option Direction -> `1` for the EventLocator method should be All, 1, or -1, or a list consisting of these values with length equal to the number of events (`2`)."
NDSolve::evact = NDSolveValue::evact = ParametricNDSolve::evact = ParametricNDSolveValue::evact = NDSolve`Iterate::evact = "The value of the option `1` for the EventLocator method is a list with length different from the number of events (`2`), so it will be treated as a single action to take for all specified events."
NDSolve::evwe = NDSolveValue::evwe = ParametricNDSolve::evwe = ParametricNDSolveValue::evwe = NDSolve`Iterate::evwe = "WhenEvent expressions should be included with the equations and will be ignored in `1` since they do not evaluate to True, False, or real numbers."
NDSolve::evre = NDSolveValue::evre = ParametricNDSolve::evre = ParametricNDSolveValue::evre = NDSolve`ProcessEquations::evre = "The value of the event function at `1` = `2` was not a real number. The event will be ignored in steps where it does not evaluate to real numbers at both ends."
NDSolve::event = NDSolveValue::event = ParametricNDSolve::event = ParametricNDSolveValue::event = NDSolve`ProcessEquations::event = "Event `1` should be a WhenEvent expression."
NDSolve::evboo = NDSolveValue::evboo = ParametricNDSolve::evboo = ParametricNDSolveValue::evboo = NDSolve`ProcessEquations::evboo = "The value of the event function at `1` = `2` was not True or False. When not True, the value will be considered as False."
NDSolve::ecboo = NDSolveValue::ecboo = ParametricNDSolve::ecboo = ParametricNDSolveValue::ecboo = NDSolve`ProcessEquations::ecboo = "The value of event condition function at `1` = `2` was not True or False. The event will be considered inactive."
NDSolve::evfrf = NDSolveValue::evfrf = ParametricNDSolve::evfrf = ParametricNDSolveValue::evfrf = NDSolve`ProcessEquations::evfrf = "The event function did not evaluate to a real number somewhere between `1` = `2` and `1` = `3`, preventing FindRoot from finding the root accurately."
NDSolve::evcvmit = NDSolveValue::evcvmit = ParametricNDSolve::evcvmit = ParametricNDSolveValue::evcvmit = NDSolve`ProcessEquations::evcvmit = "Event location failed to converge to the requested accuracy or precision within `4` iterations between `1` = `2` and `1` = `3`."
NDSolve::evlm = NDSolveValue::evlm = ParametricNDSolve::evlm = ParametricNDSolveValue::evlm = NDSolve`ProcessEquations::evlm = NDSolve`Iterate::evlm = "The value of EventLocationMethod -> `1` is not Automatic, Brent, LinearInterpolation, StepBegin, or StepEnd."
NDSolve::evsa = NDSolveValue::evsa = ParametricNDSolve::evsa = ParametricNDSolveValue::evsa = NDSolve`Iterate::evsa = "The value of SolutionApproximation -> `1` is not Automatic, CubicHermiteInterpolation, DenseOutput, or InvokeMethod."
NDSolve::exseq = NDSolveValue::exseq = ParametricNDSolve::exseq = ParametricNDSolveValue::exseq = NDSolve`Iterate::exseq = "The value of `1` -> `2` for the method `3` should be either Automatic, a strictly increasing list of at least `4` positive machine integers, or a function that generates such a list."
NDSolve::exmaxo = NDSolveValue::exmaxo = ParametricNDSolve::exmaxo = ParametricNDSolveValue::exmaxo = NDSolve`Iterate::exmaxo = "The value of `1` -> `2` for the method `3` should be Automatic, Infinity, or an integer greater than or equal to `4`."
NDSolve::exmino = NDSolveValue::exmino = ParametricNDSolve::exmino = ParametricNDSolveValue::exmino = NDSolve`Iterate::exmino = "The value of `1` -> `2` for the method `3` should be Automatic or an integer greater than or equal to `4`."
NDSolve::exsord = NDSolveValue::exsord = ParametricNDSolve::exsord = ParametricNDSolveValue::exsord = NDSolve`Iterate::exsord = "The value of `1` -> `2` of the method `3` should be a positive integer strictly between `4` and `5`."
NDSolve::dgvars = NDSolveValue::dgvars = ParametricNDSolve::dgvars = ParametricNDSolveValue::dgvars = NDSolve`ProcessEquations::dgvars = "The differentiation variables `2` given in `1` should be a subset of the independent variables `3`."
NDSolve::dgsvars = NDSolveValue::dgsvars = ParametricNDSolve::dgsvars = ParametricNDSolveValue::dgsvars = NDSolve`ProcessEquations::dgsvars = "The differentiation variables `2` given for `1` should be the spatial independent variables `3`."
NDSolve::exordf = NDSolveValue::exordf = ParametricNDSolve::exordf = ParametricNDSolveValue::exordf = NDSolve`Iterate::exordf = NDSolve::sssf = NDSolveValue::sssf = ParametricNDSolve::sssf = ParametricNDSolveValue::sssf = NDSolve`ProcessEquations::sssf = "The value of `1` -> `2` for the method `3` should be a list of `4` real numbers between 0 and 1."
NDSolve::noelem = NDSolveValue::noelem = ParametricNDSolve::noelem = ParametricNDSolveValue::noelem = NDSolve`ProcessEquations::noelem = "No elements could be found in the region `2`. Make sure that `1` evaluates to True or False for numerical values of the variables."
NDSolve::singls = NDSolveValue::singls = ParametricNDSolve::singls = ParametricNDSolveValue::singls = NDSolve`Iterate::singls = "Encountered a singular linear system at `1` = `2`. Unable to continue."
NDSolve::repstep = NDSolveValue::repstep = ParametricNDSolve::repstep = ParametricNDSolveValue::repstep = NDSolve`Iterate::repstep = "Repeated step failure at `1` == `2` with no step size reduction."
NDSolve::bdstyp = NDSolveValue::bdstyp = ParametricNDSolve::bdstyp = ParametricNDSolveValue::bdstyp = NDSolve`ProcessEquations::bdstyp = "Solution stage `1` in `2` is not one of `3`."
NDSolve::bdsmtd = NDSolveValue::bdsmtd = ParametricNDSolve::bdsmtd = ParametricNDSolveValue::bdsmtd = NDSolve`ProcessEquations::bdsmtd = NDSolve`Reinitialize::bdsmtd = "Method `1` for solution stage `2` is not one of `3`."
NDSolve::tistr = NDSolveValue::tistr = ParametricNDSolve::tistr = ParametricNDSolveValue::tistr = NDSolve`ProcessEquations::tistr = "Time integration method specification `1` will have no effect since it is preceded by `2` in `3`."
NDSolve::mmstr = NDSolveValue::mmstr = ParametricNDSolve::mmstr = ParametricNDSolveValue::mmstr = NDSolve`ProcessEquations::mmstr = "For the NDSolve solution stage `3`, both methods `1` and `2` were specified. Only the first specification will be used."
NDSolve::smpf = NDSolveValue::smpf = ParametricNDSolve::smpf = ParametricNDSolveValue::smpf = NDSolve`Iterate::smpf = "Failure to project onto the discontinuity surface when computing Filippov continuation at time `1`."
NDSolve::smdelta = NDSolveValue::smdelta = ParametricNDSolve::smdelta = ParametricNDSolveValue::smdelta = NDSolve`ProcessEquations::smdelta = "The solution was in sliding mode along some discontinuities at `1` = `2` when a Dirac delta discontinuity was encountered. The solution beyond this point was computed from a continuation."
NDSolve::smdae = NDSolveValue::smdae = ParametricNDSolve::smdae = ParametricNDSolveValue::smdae = NDSolve`ProcessEquations::smdae = "Events for discontinuities with possible sliding mode were given but the equations are being solved as a DAE, so sliding mode will not be considered."
NDSolve::ndvran = NDSolveValue::ndvran = ParametricNDSolve::ndvran = ParametricNDSolveValue::ndvran = NDSolve`ProcessEquations::ndvran = "`1` is not a valid variable range."
NDSolve::ndvrng = NDSolveValue::ndvrng = ParametricNDSolve::ndvrng = ParametricNDSolveValue::ndvrng = NDSolve`ProcessEquations::ndvrng = "The range `1` in `2` is not valid."
NDSolve::ndsdtc = NDSolveValue::ndsdtc = ParametricNDSolve::ndsdtc = ParametricNDSolveValue::ndsdtc = NDSolve`ProcessEquations::ndsdtc = "The time constraint of `1` seconds was exceeded trying to solve for derivatives, so the system will be treated as a system of differential-algebraic equations. You can use Method->{\"EquationSimplification\"->\"Solve\"} to have the system solved as ordinary differential equations."
NDSolve::disder = NDSolveValue::disder = ParametricNDSolve::disder = ParametricNDSolveValue::disder = NDSolve`ProcessEquations::disder = "Cannot take the derivative of discrete variable `1`."
NDSolve::depdole = NDSolveValue::depdole = ParametricNDSolve::depdole = ParametricNDSolveValue::depdole = NDSolve`ProcessEquations::depdole = "The differential order of a dependent variable in `1` exceeds the highest order that appears in the differential equations."
NDSolve::depdol = NDSolveValue::depdol = ParametricNDSolve::depdol = ParametricNDSolveValue::depdol = NDSolve`ProcessEquations::depdol = "The differential order of the dependent variables in `1` should be strictly less than the highest order that appears in the differential equations.";
NDSolve::disdep = NDSolveValue::disdep = ParametricNDSolve::disdep = ParametricNDSolveValue::disdep = NDSolve`ProcessEquations::disdep = "The variable `1` cannot be both discrete and dependent."
NDSolve::dvoor = NDSolveValue::dvoor = ParametricNDSolve::dvoor = ParametricNDSolveValue::dvoor = NDSolve`ProcessEquations::dvoor = "Discrete variable(s) `1` went out of the range specified by `2` at `3` == `4`."
NDSolve::depvoor = NDSolveValue::depvoor = ParametricNDSolve::depvoor = ParametricNDSolveValue::depvoor = NDSolve`ProcessEquations::depvoor = "Dependent variable(s) `1` went out of the range specified by `2` at `3` = `4`."
NDSolve::multr = NDSolveValue::multr = ParametricNDSolve::multr = ParametricNDSolveValue::multr = NDSolve`ProcessEquations::multr = "The discrete variable `1` is defined in multiple ranges `2`, `3`."
NDSolve::cdss = NDSolveValue::cdss = ParametricNDSolve::cdss = ParametricNDSolveValue::cdss = NDSolve`ProcessEquations::cdss = "`1` is not a setting for a crossing variable."
NDSolve::sdsvar = NDSolveValue::sdsvar = ParametricNDSolve::sdsvar = ParametricNDSolveValue::sdsvar = NDSolve`ProcessEquations::sdsvar = "The discontinuity state variable `1` should be a discrete variable restricted to integer values {-1, 0, 1} or {-1, 1}."
NDSolve::dvssp = NDSolveValue::dvssp = ParametricNDSolve::dvssp = ParametricNDSolveValue::dvssp = NDSolve`ProcessEquations::dvssp = "Cannot have discrete variables for steady-state problems."
NDSolve::cvr = NDSolveValue::cvr = ParametricNDSolve::cvr = ParametricNDSolveValue::cvr = NDSolve`ProcessEquations::cvr = "Continuous variable `1` cannot be restricted to discrete set `2`."
NDSolve::dimmatch = NDSolveValue::dimmatch = ParametricNDSolve::dimmatch = ParametricNDSolveValue::dimmatch = NDSolve`ProcessEquations::dimmatch = "Dimensions of lower bound `1` do not match dimensions of upper bound `2` for variable `3`."
NDSolve::actid = NDSolveValue::actid = ParametricNDSolve::actid = ParametricNDSolveValue::actid = NDSolve`ProcessEquations::actid = "Event action `1` does not match the form RuleDelayed[ \"Action\" , _]."
NDSolve::disspec = NDSolveValue::disspec = ParametricNDSolve::disspec = ParametricNDSolveValue::disspec = NDSolve`ProcessEquations::disspec = "Invalid discrete variable specification `1`."
NDSolve::evnoact = NDSolveValue::evnoact = ParametricNDSolve::evnoact = ParametricNDSolveValue::evnoact = NDSolve`ProcessEquations::evnoact = "Event action `1` will have no effect. `1` should be given as an expression with arguments."
NDSolve::bdedm = NDSolveValue::bdedm = ParametricNDSolve::bdedm = ParametricNDSolveValue::bdedm = NDSolve`ProcessEquations::bdedm = "`1` is not a valid event detection method."
NDSolve::svnder = NDSolveValue::svnder = ParametricNDSolve::svnder = ParametricNDSolveValue::svnder = NDSolve`ProcessEquations::svnder = "The variables `1` in `2` cannot be set as state variables while solving as an ODE because some are the highest order derivatives. You may be able to use these if you solve as a system of DAEs by using Method->{\"EquationSimplification\"->\"Residual\"}."
NDSolve::wends = NDSolveValue::wends = ParametricNDSolve::wends = ParametricNDSolveValue::wends = NDSolve`ProcessEquations::wends = "Warning: the rule `1` will not set the discontinuity state because the left-hand side is not a discrete variable restricted to integer values {-1, 0, 1} or {-1, 1}."
NDSolve::wenset = NDSolveValue::wenset = ParametricNDSolve::wenset = ParametricNDSolveValue::wenset = NDSolve`ProcessEquations::wenset = "Warning: the rule `1` will not directly set the state because the left-hand side is not a list of state variables."
NDSolve::daeresidual = NDSolveValue::daeresidual = ParametricNDSolve::daeresidual = ParametricNDSolveValue::daeresidual = NDSolve`ProcessEquations::daeresidual = "No change in residual and/or line search did not yield any reduction. Terminating after `1` iterations with residue of `2`." ;
NDSolve::daenoconv = NDSolveValue::daenoconv = ParametricNDSolve::daenoconv = ParametricNDSolveValue::daenoconv = NDSolve`ProcessEquations::daenoconv = "Scaled residual norm did not go below `1` in `3` iterations. Scaled norm at the end of `3` iterations = `2`." ;
NDSolve::daenoconv1 = NDSolveValue::daenoconv1 = ParametricNDSolve::daenoconv1 = ParametricNDSolveValue::daenoconv1 = NDSolve`ProcessEquations::daenoconv1 = "Iterations did not converge. Please try perturbing the initial conditions." ;
NDSolve::daenoconv2 = NDSolveValue::daenoconv2 = ParametricNDSolve::daenoconv2 = ParametricNDSolveValue::daenoconv2 = NDSolve`ProcessEquations::daenoconv2 = "Iterations did not converge. Weighting the initial conditions and performing new iterations." ;
NDSolve::daebadic = NDSolveValue::daebadic = ParametricNDSolve::daebadic = ParametricNDSolveValue::daebadic = NDSolve`ProcessEquations::daebadic = "Combination of initial conditions associated with variables `1` may be inconsistent. Weighting the initial conditions and performing new iterations." ;
NDSolve::changedic = NDSolveValue::changedic = ParametricNDSolve::changedic = ParametricNDSolveValue::changedic = NDSolve`ProcessEquations::changedic = "Given initial conditions have been modified to be consistent with system of equations.";
NDSolve::daebadcollorder = NDSolveValue::daebadcollorder = ParametricNDSolve::daebadcollorder = ParametricNDSolveValue::daebadcollorder = NDSolve`ProcessEquations::daebadcollorder = "CollocationOrder should be an integer value. Proceeding with CollocationOrder -> 6." ;
NDSolve::daemincollorder = NDSolveValue::daemincollorder = ParametricNDSolve::daemincollorder = ParametricNDSolveValue::daemincollorder = NDSolve`ProcessEquations::daemincollorder = "CollocationOrder should be greater than 2. Proceeding with CollocationOrder -> 2." ;
NDSolve::daebadmaxiter = NDSolveValue::daebadmaxiter = ParametricNDSolve::daebadmaxiter = ParametricNDSolveValue::daebadmaxiter = NDSolve`ProcessEquations::daebadmaxiter = "Maximum iterations should be an integer value. Proceeding with MaxIterations -> 100." ;
NDSolve::daeminiter = NDSolveValue::daeminiter = ParametricNDSolve::daeminiter = ParametricNDSolveValue::daeminiter = NDSolve`ProcessEquations::daeminiter = "Minimum iterations should be at least 1. Proceeding with MaxIterations -> 1." ;
NDSolve::daebadcolldir = NDSolveValue::daebadcolldir = ParametricNDSolve::daebadcolldir = ParametricNDSolveValue::daebadcolldir = NDSolve`ProcessEquations::daebadcolldir = "`1` is not Forward, Backward, or Centered. Proceeding with CollocationDirection -> Centered." ;
NDSolve::daebadmethod = NDSolveValue::daebadmethod = ParametricNDSolve::daebadmethod = ParametricNDSolveValue::daebadmethod = NDSolve`ProcessEquations::daebadmethod = "`1` is not Chebyshev or Taylor. Proceeding with BasisType -> Chebyshev." ;
NDSolve::badextrapts = NDSolveValue::badextrapts = ParametricNDSolve::badextrapts = ParametricNDSolveValue::badextrapts = NDSolve`ProcessEquations::badextrapts = "ExtraCollocationPoints should be an integer. Proceeding with ExtraCollocationPoints -> 3." ;
NDSolve::daeminextrapts = NDSolveValue::daeminextrapts = ParametricNDSolve::daeminextrapts = ParametricNDSolveValue::daeminextrapts = NDSolve`ProcessEquations::daeminextrapts = "ExtraCollocationPoints should be at least 0. Proceeding with ExtraCollocationPoints -> 0." ;
NDSolve::badcollrange = NDSolveValue::badcollrange = ParametricNDSolve::badcollrange = ParametricNDSolveValue::badcollrange = NDSolve`ProcessEquations::badcollrange = "CollocationRange should be greater than 0. Proceeding with CollocationRange -> Automatic." ;
NDSolve::largecollrange = NDSolveValue::largecollrange = ParametricNDSolve::largecollrange = ParametricNDSolveValue::largecollrange = NDSolve`ProcessEquations::largecollrange = "CollocationRange is possibly large. Solution may not converge." ;
NDSolve::daebadsolmethod = NDSolveValue::daebadsolmethod = ParametricNDSolve::daebadsolmethod = ParametricNDSolveValue::daebadsolmethod = NDSolve`ProcessEquations::daebadsolmethod = "`1` is not LinearSolve or LeastSquares. Proceeding with SolvingMethod -> LinearSolve.";
NDSolve::badicweight = NDSolveValue::badicweight = ParametricNDSolve::badicweight = ParametricNDSolveValue::badicweight = NDSolve`ProcessEquations::badicweight = "The weights should be positive. Proceeding with InitialConditionWeight -> 1." ;
NDSolve::index = NDSolveValue::index = ParametricNDSolve::index = ParametricNDSolveValue::index = NDSolve`Iterate::index = "The DAE solver failed at `1` = `2`. The solver is intended for index 1 DAE systems and structural analysis indicates that the DAE index is `3`. The option Method->{\"IndexReduction\"->Automatic} may be used to reduce the index of the system.";
NDSolve::chknic = NDSolveValue::chknic = ParametricNDSolve::chknic = ParametricNDSolveValue::chknic = NDSolve`Iterate::chknic = NDSolve`ProcessEquations::chknic = "Structural analysis indicates that `1` initial conditions are needed to fix the state of the system. Currently only `2` initial conditions are specified. NDSolve may return one of a family of solutions.";
NDSolve::indexss = NDSolveValue::indexss = ParametricNDSolve::indexss = ParametricNDSolveValue::indexss = NDSolve`Iterate::indexss = "The DAE solver failed at `1` = `2`. The solver is intended for index 1 DAE systems and structural analysis indicates that the DAE is structurally singular.";
NDSolve::ssindex = NDSolveValue::ssindex = ParametricNDSolve::ssindex = ParametricNDSolveValue::ssindex = NDSolve`ProcessEquations::ssindex = "The DAE cannot be put in state space form because it has structural index greater than 1.";
NDSolve::bvdisc = NDSolveValue::bvdisc = ParametricNDSolve::bvdisc = ParametricNDSolveValue::bvdisc = NDSolve`ProcessEquations::bvdisc = "NDSolve is not currently able to solve boundary value problems with discrete variables.";
NDSolve::dsbool = NDSolveValue::dsbool = ParametricNDSolve::dsbool = ParametricNDSolveValue::dsbool = NDSolve`ProcessEquations::dsbool = "The \"DerivativeSign\" method can only be used with events that can be resolved as a zero crossing for some function of the solution variables.";
NDSolve::allort = NDSolveValue::allort = ParametricNDSolve::allort = ParametricNDSolveValue::allort = NDSolve`ProcessEquations::allort = "The dependent variable `1` should depend either on the temporal variable alone or on all independent variables."
NDSolve::ssres = NDSolveValue::ssres = ParametricNDSolve::ssres = ParametricNDSolveValue::ssres = NDSolve`ProcessEquations::ssres = NDSolve`Reinitialize::ssres = NDSolve`Iterate::ssres = "NDSolve has computed values that give a zero residual for the differential-algebraic system, but some components are different from those specified."
NDSolve::irfail = NDSolveValue::irfail = ParametricNDSolve::irfail = ParametricNDSolveValue::irfail = NDSolve`ProcessEquations::irfail = "Unable to reduce the index of the system to 0 or 1."
NDSolve::pstr = NDSolveValue::pstr = ParametricNDSolve::pstr = ParametricNDSolveValue::pstr = NDSolve`ProcessEquations::pstr = "`2` is not a valid setting for `1`."
NDSolve::duplct = NDSolveValue::duplct = ParametricNDSolve::duplct = ParametricNDSolveValue::duplct = NDSolve`ProcessEquations::duplct = "Duplicate variable specification for `1` given in `2`."
NDSolve::oneregion = NDSolveValue::oneregion = ParametricNDSolve::oneregion = ParametricNDSolveValue::oneregion = NDSolve`ProcessEquations::oneregion = "Spatial discretization can only be done over a single region."
NDSolve::bdsspc = NDSolveValue::bdsspc = ParametricNDSolve::bdsspc = ParametricNDSolveValue::bdsspc = NDSolve`ProcessEquations::bdsspc = "Defaults will be used instead of the incorrectly specified method options in `1`."
NDSolve::iopnma = NDSolveValue::iopnma = ParametricNDSolve::iopnma = ParametricNDSolveValue::iopnma = NDSolve`ProcessEquations::iopnma = "Value of `1` method option \"SensitivityOrder\" should be a non-negative machine-sized integer, None, or Automatic."
NDSolve::jevlm = NDSolveValue::jevlm = ParametricNDSolve::jevlm = ParametricNDSolveValue::jevlm = NDSolve`ProcessEquations::jevlm = "The location method \"BrentBracketRoot\" may only be used when the event can be handled as a real-valued function."
NDSolve::tddisc = NDSolveValue::tddisc = ParametricNDSolve::tddisc = ParametricNDSolveValue::tddisc = NDSolve`ProcessEquations::tddisc = "NDSolve cannot do a discontinuity replacement for event surfaces that depend only on time."
NDSolve::deltad = NDSolveValue::deltad = ParametricNDSolve::deltad = ParametricNDSolveValue::deltad = NDSolve`ProcessEquations::deltad = "NDSolve cannot handle discontinuities where the argument of DiracDelta depends on any variable besides the temporal independent variable."
NDSolve`DeltaDiscontinuity::ddss = "Incorrect DiracDelta discontinuity specification encountered in `1`."
NDSolveValue::ndsvb = "There are multiple solution branches for the equations, but NDSolveValue will return only one. Use NDSolve to get all of the solution branches.";
ParametricNDSolve::bdpvar = ParametricNDSolveValue::bdpvar = "A value for `1` has already been defined as part of the equations.";
ParametricNDSolve::iopna = ParametricNDSolveValue::iopna = "Value of option `1` -> `2` should be a non-negative integer or Automatic.";
ParametricNDSolve::fpct = ParametricNDSolveValue::fpct = "Too many parameters in `1` to be filled from `2`.";
ParametricNDSolve::scompute = ParametricNDSolveValue::scompute = "The sensitivity derivative `1` has total degree exceeding the specification in `2`.";
ParametricNDSolve::adjsens = ParametricNDSolveValue::adjsens = "The adjoint sensitivity method cannot be used for the output function `1`. It can only be used for output functions that are at a particular time or are a definite integral over time."
ParametricNDSolve::pdvar = ParametricNDSolveValue::pdvar = NDSolve`ProcessEquations::pdvar = "Dependent variables `1` cannot depend on parameters `2`."
ParametricNDSolve::pivar = ParametricNDSolveValue::pivar = NDSolve`ProcessEquations::pivar = "Parameter list `1` cannot include independent variables `2`."
ParametricFunction::psensp = "The sensitivity derivative with respect to the parameter `1` cannot be computed because it does not appear explicitly in the equations."
ParametricNDSolve::prange = ParametricNDSolveValue::prange = "Invalid non-numeric value `2` for parameter `1`."
NDSolve`CrossDiscontinuity::smbool = "Sliding mode continuation can only be considered for events that can be resolved as a zero crossing for some function of the solution variables."
NDSolve`DiscontinuityScan::domain = "Warning: the domain specification `1` is not one of Automatic, Reals, or Complexes, and will be ignored."
NDSolve`DiscontinuityScan::defn = "Encountered a bad discontinuity value definition `1`."
Graphics`Mesh`Region::vlim = "The variable specification `1` should be in the form {v, vmin, vmax}, where v is the variable."
Graphics`Mesh`Region::vbnd = "The variable bounds in `1` should be real numeric quantities that are distinct at machine precision."
NDSolve`FiniteDifferenceDerivative::deriv = "`1` should be a Derivative operator with non-negative integer order(s)."
NDSolve`FiniteDifferenceDerivative::ldim = "`1` should be a list with an element for each of the `2` dimensions."
NDSolve`FiniteDifferenceDerivative::grid = "The grid `1` given for dimension `2` is not an increasing list of distinct real coordinates."
NDSolve`FiniteDifferenceDerivative::aord = "The approximation order `1` given for dimension `2` should be a positive machine-sized integer or `3`."
NDSolve`FiniteDifferenceDerivative::per = "The specification of periodicity `1` given for dimension `2` should be either True or False."
NDSolve`FiniteDifferenceDerivative::spu = "The coordinates `1` for dimension `2` are not uniformly spaced. Periodic pseudospectral derivatives are computed on a uniform grid."
NDSolve`FiniteDifferenceDerivative::spc = "The coordinates `1` for dimension `2` do not have spacing proportional to the Chebyshev points -Cos[Range[0,`3`] Pi/`3`]. Nonperiodic pseudospectral derivatives are only computed for this spacing."
NDSolve`FiniteDifferenceDerivative::conw = "There are insufficient points in dimension `1` to generate consistent finite different weights."
NDSolve`FiniteDifferenceDerivative::ordred = "There are insufficient points in dimension `1` to achieve the requested approximation order. Order will be reduced to `2`."
NDSolve`FiniteDifferenceDerivativeFunction::ddim = "Data `1` is not a rectangular tensor with dimensions `2`."
NDSolve`FiniteDifferenceDerivativeFunction::spnum = "Data `1` is exact or symbolic. Spectral weight computation requires data with approximate numbers."
NDSolve`ImplicitRungeKutta::cmsing = "Singular coefficient matrix encountered for `1`, which is not suitable for stiff systems."
NDSolve`SolutionDataComponent::sdlist = "The solution data `1` should be a list of the form {time, dependent variables, temporal derivatives, discrete variables, indexed discrete variables, parameters, sensitivity parameters}."
NDSolve`SolutionDataComponent::sdpos = "The component `1` is not one of \"Time\", \"DependentVariables\", \"TemporalDerivatives\", \"DiscreteVariables\", \"IndexedDiscreteVariables\", \"Parameters\", or \"SensitivityParameters\"."
NDSolve`StateData::nsssp = "The NDSolve state object does not have a `1` property for steady state equations."
NDSolve::count = "Pantelides algorithm reached an upper limit of `1` iterations."
NDSolve::irmatrixcount="SymbolicNumeric method reached an upper limit of `1` iterations.";
NDSolve::badindexgoal = "An index reduction goal of `1` is not valid. The system can only be reduced to an index 0 or an index 1 system."
NDSolve::badmethod = "The option of ConstraintMethod -> `1` is not one of DummyDerivatives, Projection, or Automatic."
NDSolve::ssel = "The option of StateSelection -> `1` is not one of Structural, Dynamic, or Automatic."
NDSolve::structurallysingular = "The dummy derivative method found the differential algebraic equation to be structurally singular."
NDSolve::singularstructuralmatrix = "The structural matrix method found the differential algebraic equations to be structurally singular."
NDSolve::nopredecessor = "No predecessor equations were found for the variable `1`."
NDSolve::dontknowhowtohandlenoderivatives = "Unable to find appropriate dummy derivative for `1` because `1` does not contain a derivative."
(* FEM general *)
NDSolve::femtnq = NDSolveValue::femtnq = ParametricNDSolve::femtnq = ParametricNDSolveValue::femtnq = NDSolve`FEM`ToElementMesh::femtnq = "`1` needs to be a numeric quantity."
NDSolve::femnnbc = NDSolveValue::femnnbc = ParametricNDSolve::femnnbc = ParametricNDSolveValue::femnnbc = "`1` is not a supported Finite Element boundary condition; specify a NeumannValue instead."
(* FEM elements *)
NDSolve`FEM`PointElement::femdmi = NDSolve`FEM`LineElement::femdmi = NDSolve`FEM`TriangleElement::femdmi = NDSolve`FEM`QuadElement::femdmi = NDSolve`FEM`TetrahedronElement::femdmi = NDSolve`FEM`HexahedronElement::femdmi = "Mesh element type `1` does not match incidents `2`."
NDSolve`FEM`PointElement::femiml = NDSolve`FEM`LineElement::femiml = NDSolve`FEM`TriangleElement::femiml = NDSolve`FEM`QuadElement::femiml = NDSolve`FEM`TetrahedronElement::femiml = NDSolve`FEM`HexahedronElement::femiml = "Length of incidents `1` does not match length of markers `2`."
NDSolve`FEM`PointElement::femmnpr = NDSolve`FEM`LineElement::femmnpr = NDSolve`FEM`TriangleElement::femmnpr = NDSolve`FEM`QuadElement::femmnpr = NDSolve`FEM`TetrahedronElement::femmnpr = NDSolve`FEM`HexahedronElement::femmnpr = "Markers `1` are not an integer rank 1 packed-array tensor."
(* FEM element mesh *)
NDSolve::fembdct = NDSolveValue::fembdct = ParametricNDSolve::fembdct = ParametricNDSolveValue::fembdct = NDSolve`FEM`ElementMesh::fembdct = NDSolve`FEM`ToBoundaryMesh::fembdct = NDSolve`FEM`ToElementMesh::fembdct = "The coordinates `1` are not of type real."
NDSolve::fembdel = NDSolveValue::fembdel = ParametricNDSolve::fembdel = ParametricNDSolveValue::fembdel = NDSolve`FEM`ElementMesh::fembdel = NDSolve`FEM`ToBoundaryMesh::fembdel = NDSolve`FEM`ToElementMesh::fembdel = "`1` is not a valid mesh element. Possible causes are that the mesh element type is not valid, not enough coordinates have been specified, or that incidents have values less than or equal to zero."
NDSolve::femembo = NDSolveValue::femembo = ParametricNDSolve::femembo = ParametricNDSolveValue::femembo = NDSolve`FEM`ElementMesh::femembo = NDSolve`FEM`ToBoundaryMesh::femembo = NDSolve`FEM`ToElementMesh::femembo = "Cannot increase boundary order of `1`."
NDSolve::fememcr = NDSolveValue::fememcr = ParametricNDSolve::fememcr = ParametricNDSolveValue::fememcr = NDSolve`FEM`ElementMesh::fememcr = NDSolve`FEM`ToBoundaryMesh::fememcr = NDSolve`FEM`ToElementMesh::fememcr = "The coordinates need to be of rank 2."
NDSolve::fememdb = NDSolveValue::fememdb = ParametricNDSolve::fememdb = ParametricNDSolveValue::fememdb = NDSolve`FEM`ElementMesh::fememdb = NDSolve`FEM`ToBoundaryMesh::fememdb = NDSolve`FEM`ToElementMesh::fememdb = "Cannot deduce boundary from `1`."
NDSolve::fememdc = NDSolveValue::fememdc = ParametricNDSolve::fememdc = ParametricNDSolveValue::fememdc = NDSolve`FEM`ElementMesh::fememdc = NDSolve`FEM`ToBoundaryMesh::fememdc = NDSolve`FEM`ToElementMesh::fememdc = "Either the input has duplicate coordinates or duplicate coordinates were generated during the (boundary) mesh generation. An ElementMesh with duplicate coordinates is not valid. Removing the duplicate coordinates or using a different (boundary) mesh-generation method may help."
NDSolve::fememdp = NDSolveValue::fememdp = ParametricNDSolve::fememdp = ParametricNDSolveValue::fememdp = NDSolve`FEM`ElementMesh::fememdp = NDSolve`FEM`ToBoundaryMesh::fememdp = NDSolve`FEM`ToElementMesh::fememdp = "Cannot deduce point elements from `1`."
NDSolve::fememeob = NDSolveValue::fememeob = ParametricNDSolve::fememeob = ParametricNDSolveValue::fememeob = NDSolve`FEM`ElementMesh::fememeob = NDSolve`FEM`ToBoundaryMesh::fememeob = NDSolve`FEM`ToElementMesh::fememeob = "Either mesh elements or boundary elements need to be specified."
NDSolve::fememib = NDSolveValue::fememib = ParametricNDSolve::fememib = ParametricNDSolveValue::fememib = NDEigensystem::fememib = NDEigenvalues::fememib = NDSolve`FEM`ElementMesh::fememib = NDSolve`FEM`ToBoundaryMesh::fememib = NDSolve`FEM`ToElementMesh::fememib = "The input has or generated an intersecting boundary and cannot be processed."
NDSolve::fememied = NDSolveValue::fememied = ParametricNDSolve::fememied = ParametricNDSolveValue::fememied = NDSolve`FEM`ElementMesh::fememied = NDSolve`FEM`ToBoundaryMesh::fememied = NDSolve`FEM`ToElementMesh::fememied = "The element dimension of `1` is not consistent with other elements that are of dimension `2`."
NDSolve::fememieo = NDSolveValue::fememieo = ParametricNDSolve::fememieo = ParametricNDSolveValue::fememieo = NDSolve`FEM`ElementMesh::fememieo = NDSolve`FEM`ToBoundaryMesh::fememieo = NDSolve`FEM`ToElementMesh::fememieo = "The element order of `1` is not consistent with other elements that are of order `2`."
NDSolve::fememino = NDSolveValue::fememino = ParametricNDSolve::fememino = ParametricNDSolveValue::fememino = NDSolve`FEM`ElementMesh::fememino = NDSolve`FEM`ToBoundaryMesh::fememino = NDSolve`FEM`ToElementMesh::fememino = "The mesh elements are not valid. A set of valid mesh element incidents needs to be positive integers and be able to form a complete sequence starting from 1 to the largest incident present. There is no incident 1."
NDSolve::fememins = NDSolveValue::fememins = ParametricNDSolve::fememins = ParametricNDSolveValue::fememins = NDSolve`FEM`ElementMesh::fememins = NDSolve`FEM`ToBoundaryMesh::fememins = NDSolve`FEM`ToElementMesh::fememins = "The mesh elements are not valid. A set of valid mesh element incidents needs to be positive integers and be able to form a complete sequence starting from 1 to the largest incident present. There are missing incidents; a complete sequence cannot be formed."
NDSolve::fememnht = NDSolveValue::fememnht = ParametricNDSolve::fememnht = ParametricNDSolveValue::fememnht = NDSolve`FEM`ElementMesh::fememnht = NDSolve`FEM`ToBoundaryMesh::fememnht = NDSolve`FEM`ToElementMesh::fememnht = "It is not possible to have a mixed HexahedronElement and TetrahedronElement element mesh."
NDSolve::femimq = NDSolveValue::femimq = ParametricNDSolve::femimq = ParametricNDSolveValue::femimq = NDEigensystem::femimq = NDEigenvalues::femimq = NDSolve`FEM`ElementMesh::femimq = NDSolve`FEM`ToBoundaryMesh::femimq = NDSolve`FEM`ToElementMesh::femimq = Interpolation::femimq = NDSolve`FEM`ElementMeshInterpolation::femimq = NIntegrate::femimq = "The element mesh has insufficient quality of `1`. A quality estimate below 0. may be caused by a wrong ordering of element incidents or self-intersecting elements."
(* FEM to element / boundary mesh and related *)
NDSolve::femtbmbid = NDSolveValue::femtbmbid = ParametricNDSolve::femtbmbid = ParametricNDSolveValue::femtbmbid = NDSolve`FEM`ToBoundaryMesh::femtbmbid = NDSolve`FEM`ToElementMesh::femtbmbid = "The input data has deficiencies and cannot be repaired."
NDSolve::femtbmbnc = NDSolveValue::femtbmbnc = ParametricNDSolve::femtbmbnc = ParametricNDSolveValue::femtbmbnc = NDSolve`FEM`ToBoundaryMesh::femtbmbnc = NDSolve`FEM`ToElementMesh::femtbmbnc = "`1` cannot be converted to an ElementMesh. The Input is not valid."
NDSolve::femtbmit = NDSolveValue::femtbmit = ParametricNDSolve::femtbmit = ParametricNDSolveValue::femtbmit = NDSolve`FEM`ToBoundaryMesh::femtbmit = NDSolve`FEM`ToElementMesh::femtbmit = "Input generates intersecting boundaries."
NDSolve::femtbmnt = NDSolveValue::femtbmnt = ParametricNDSolve::femtbmnt = ParametricNDSolveValue::femtbmnt = NDSolve`FEM`ToBoundaryMesh::femtbmnt = NDSolve`FEM`ToElementMesh::femtbmnt = "Input polygons cannot be triangulated. Try giving Polygons with last Dimensions 3."
NDSolve::femtbmnbb = NDSolveValue::femtbmnbb = ParametricNDSolve::femtbmnbb = ParametricNDSolveValue::femtbmnbb = NDSolve`FEM`ToBoundaryMesh::femtbmnbb = NDSolve`FEM`ToElementMesh::femtbmnbb = "The bounds for `1` cannot be computed. Specifying explicit bounds may help."
NDSolve::femtbmrdp = NDSolveValue::femtbmrdp = ParametricNDSolve::femtbmrdp = ParametricNDSolveValue::femtbmrdp = NDSolve`FEM`ToBoundaryMesh::femtbmrdp = NDSolve`FEM`ToElementMesh::femtbmrdp = "Removing duplicate points from the input data leads to degenerate Polygons. Reducing \"CoordinateTolerance\" may help."
NDSolve::femtbmne = NDSolveValue::femtbmne = ParametricNDSolve::femtbmne = ParametricNDSolveValue::femtbmne = NDSolve`ProcessEquations::femtbmne = NDSolve`FEM`ToBoundaryMesh::femtbmne = NDSolve`FEM`ElementMesh::femtbmne = "The `1` could not be discretized; no mesh elements in that region could be found. Possibly the region is empty. If the region is not empty, then it needs to evaluate to True or False for numerical values of the variables."
NDSolve::femtbmmnv = NDSolveValue::femtbmmnv = ParametricNDSolve::femtbmmnv = ParametricNDSolveValue::femtbmmnv = NDSolve`FEM`ToBoundaryMesh::femtbmmnv = NDSolve`FEM`ToElementMesh::femtbmmnv = "Markers are not a vector of integer values."
NDSolve::femtbmmlc = NDSolveValue::femtbmmlc = ParametricNDSolve::femtbmmlc = ParametricNDSolveValue::femtbmmlc = NDSolve`FEM`ToBoundaryMesh::femtbmmlc = NDSolve`FEM`ToElementMesh::femtbmmlc = "The number of `1` markers `2` is not the same as the number of `3` `4`."
NDSolve::femtbmscf = NDSolveValue::femtbmscf = ParametricNDSolve::femtbmscf = ParametricNDSolveValue::femtbmscf = NDSolve`FEM`ToBoundaryMesh::femtbmscf = NDSolve`FEM`ToElementMesh::femtbmscf = "The symbolic region `1` could not be converted to an input suitable for mesh generation."
NDSolve::femmonv = NDSolveValue::femmonv = ParametricNDSolve::femmonv = ParametricNDSolveValue::femmonv = NDSolve`FEM`ToBoundaryMesh::femmonv = NDSolve`FEM`ToElementMesh::femmonv = NDSolve`FEM`MeshOrderAlteration::femmonv = "`1` is not a valid mesh order. Valid mesh orders are 1 or 2. Using `2` as default order."
NDSolve::femtembet = NDSolveValue::femtembet = ParametricNDSolve::femtembet = ParametricNDSolveValue::femtembet = NDSolve`FEM`ToElementMesh::femtembet = "`1` is not a valid mesh element type."
NDSolve::femtembmqg = NDSolveValue::femtembmqg = ParametricNDSolve::femtembmqg = ParametricNDSolveValue::femtembmqg = NDEigensystem::femtembmqg = NDEigenvalues::femtembmqg = NDSolve`FEM`ToElementMesh::femtembmqg = "The value, `1`, for the option \"MeshQualityGoal\" should be a number between 0 and 1."
NDSolve::femtemcns = NDSolveValue::femtemcns = ParametricNDSolve::femtemcns = ParametricNDSolveValue::femtemcns = NDSolve`FEM`ToElementMesh::femtemcns = "Cannot set `1`."
NDSolve::femtemdmi = NDSolveValue::femtemdmi = ParametricNDSolve::femtemdmi = ParametricNDSolveValue::femtemdmi = NDSolve`FEM`ToElementMesh::femtemdmi = "Warning: cannot delete mesh generator instance."
NDSolve::femtemedm = NDSolveValue::femtemedm = ParametricNDSolve::femtemedm = ParametricNDSolveValue::femtemedm = NDSolve`FEM`ToElementMesh::femtemedm = "`1` is not a mesh element for a dimension `2` element mesh."
NDSolve::femtemic = NDSolveValue::femtemic = ParametricNDSolve::femtemic = ParametricNDSolveValue::femtemic = NDSolve`FEM`ToElementMesh::femtemic = "Not all coordinates from the input mesh are in the output mesh. This may be due to an a faulty input mesh."
NDSolve::femtemip = NDSolveValue::femtemip = ParametricNDSolve::femtemip = ParametricNDSolveValue::femtemip = NDSolve`FEM`ToElementMesh::femtemip = "Element meshes based on rectangular regions with `1` cannot have \"IncludePoints\" or \"BoundaryIncludePoints\". Specify a \"MeshElementType\" like TriangleElement or TetrahedronElement instead."
NDSolve::femtemmc = NDSolveValue::femtemmc = ParametricNDSolve::femtemmc = ParametricNDSolveValue::femtemmc = NDSolve`FEM`ToElementMesh::femtemmc = "The `1` constraint cannot be fulfilled. The default `2` is used."
NDSolve::femtemna = NDSolveValue::femtemna = ParametricNDSolve::femtemna = ParametricNDSolveValue::femtemna = NDSolve`FEM`ToElementMesh::femtemna = "Mesh generation for `1` with the `2` elements is currently not available."
NDSolve::femtemnb = NDSolveValue::femtemnb = ParametricNDSolve::femtemnb = ParametricNDSolveValue::femtemnb = NDSolve`FEM`ToElementMesh::femtemnb = "BoundaryElements `1` from `2` are not valid."
NDSolve::femtemnbb = NDSolveValue::femtemnbb = ParametricNDSolve::femtemnbb = ParametricNDSolveValue::femtemnbb = NIntegrate::femtemnbb = NDEigensystem::femtemnbb = NDEigenvalues::femtemnbb = NDSolve`FEM`ToElementMesh::femtemnbb = NDSolve`FEM`ToBoundaryMesh::femtemnbb = NDSolve`FEM`NumericalRegion::femtemnbb = NDSolve`FEM`ToNumericalRegion::femtemnbb = "The bounds for `1` are `2`. Unless finite numeric bounds are specified, the mesh generation will constrain the region to have finite bounds."
NDSolve::femtemnc = NDSolveValue::femtemnc = ParametricNDSolve::femtemnc = ParametricNDSolveValue::femtemnc = NDSolve`FEM`ToElementMesh::femtemnc = "The coordinates `1` from `2` are not Real, not with last dimensions `3`, or not longer than `3` entries."
NDSolve::femtemne = NDSolveValue::femtemne = ParametricNDSolve::femtemne = ParametricNDSolveValue::femtemne = NDSolve`FEM`ToElementMesh::femtemne = "Mesh contains no elements."
NDSolve::femtemnm = NDSolveValue::femtemnm = ParametricNDSolve::femtemnm = ParametricNDSolveValue::femtemnm = NDEigensystem::femtemnm = NDEigenvalues::femtemnm = NDSolve`FEM`ToElementMesh::femtemnm = NDSolve`FEM`ToBoundaryMesh::femtemnm = NDSolve`ProcessEquations::femtemnm = "A mesh could not be generated."
NDSolve::femtemnp = NDSolveValue::femtemnp = ParametricNDSolve::femtemnp = ParametricNDSolveValue::femtemnp = NDSolve`FEM`ToElementMesh::femtemnp = "PointElements `1` from `2` are not valid."
Interpolation::femtemnv = NDSolve`FEM`ToElementMesh::femtemnv = "Input `1` must have at least `2` input vertices."
NDSolve::femtemrh = NDSolveValue::femtemrh = ParametricNDSolve::femtemrh = ParametricNDSolveValue::femtemrh = NDSolve`FEM`ToElementMesh::femtemrh = "`1` is not a valid \"RegionHoles\" specification. Use `2`. Proceeding without \"RegionHoles\" specification."
NDSolve::femtemrm = NDSolveValue::femtemrm = ParametricNDSolve::femtemrm = ParametricNDSolveValue::femtemrm = NDSolve`FEM`ToElementMesh::femtemrm = "`1` is not a valid \"RegionMarker\" specification. Proceeding without \"RegionMarker\" specification."
NDSolve::femtemsc = NDSolveValue::femtemsc = ParametricNDSolve::femtemsc = ParametricNDSolveValue::femtemsc = NDSolve`FEM`ToElementMesh::femtemsc = "`1` contains expressions that do not evaluate to numeric values and cannot be converted."
NDSolve::nmesh = NDSolveValue::nmesh = ParametricNDSolve::nmesh = ParametricNDSolveValue::nmesh = NDEigensystem::nmesh = NDEigenvalues::nmesh = NDSolve`ProcessEquations::nmesh = "A mesh could not be generated from `1`."
NDSolve::femdm = NDSolveValue::femdm = ParametricNDSolve::femdm = ParametricNDSolveValue::femdm = NDSolve`ProcessEquations::femdm = "The number of dimensions of the region `1` does not match the number of independent variables given `2`."
NDSolve`FEM`ElementMeshToMeshInstance::fememmif = "Could not convert element mesh `1` to mesh generator instance."
(* NumericalRegion *)
NDSolve`FEM`ToNumericalRegion::vbnd = NDSolve`FEM`NumericalRegion::vbnd = "The extent of the bounds `1` is not valid."
NDSolve::femnr = NDSolveValue::femnr = ParametricNDSolve::femnr = ParametricNDSolveValue::femnr = NDSolve`ProcessEquations::femnr = "`1` is not a valid region specification."
NDSolve::femnrbir = NDSolveValue::femnrbir = ParametricNDSolve::femnrbir = ParametricNDSolveValue::femnrbir = NDSolve`FEM`ToElementMesh::femnrbir = NDSolve`FEM`ToBoundaryMesh::femnrbir = NDSolve`FEM`NumericalRegion::femnrbir = NDSolve`FEM`ToNumericalRegion::femnrbir = "The region `1` could not be converted to an ImplicitRegion."
NDSolve::femnrbl = NDSolveValue::femnrbl = ParametricNDSolve::femnrbl = ParametricNDSolveValue::femnrbl = NDSolve`FEM`ToElementMesh::femnrbl = NDSolve`FEM`ToBoundaryMesh::femnrbl = NDSolve`FEM`ToNumericalRegion::femnrbl = NDSolve`FEM`NumericalRegion::femnrbl = NDEigensystem::femnrbl = NDEigenvalues::femnrbl = "The bounds given (`1`) are not a list of {min, max} pairs of length `2`."
(* NDSolve PDE coefficient parsing for FEM *)
NDSolve::femper = NDSolveValue::femper = ParametricNDSolve::femper = ParametricNDSolveValue::femper = NDEigensystem::femper = NDEigenvalues::femper = NDSolve`ProcessEquations::femper = "PDE parsing error of `1`. Inconsistent equation dimensions."
(* FEM method initialization *)
NDSolve::femwneo = NDSolveValue::femwneo = ParametricNDSolve::femwneo = ParametricNDSolveValue::femwneo = NDEigensystem::femwneo = NDEigenvalues::femwneo = NDSolve`ProcessEquations::femwneo = NDSolve`FEM`InitializePDEMethodData::femwneo = NDSolve`FEM`InitializeFEMMethodData::femwneo = "`1` is not a valid \"InterpolationOrder\" input. Using default instead."
NDSolve::femweo = NDSolveValue::femweo = ParametricNDSolve::femweo = ParametricNDSolveValue::femweo = NDEigensystem::femweo = NDEigenvalues::femweo = NDSolve`ProcessEquations::femweo = NDSolve`FEM`InitializePDEMethodData::femweo = NDSolve`FEM`InitializeFEMMethodData::femweo = "The requested interpolation order `1` must not be larger than the mesh order and has to be reduced to `2`."
NDSolve::fembiodv = NDSolveValue::fembiodv = ParametricNDSolve::fembiodv = ParametricNDSolveValue::fembiodv = NDEigensystem::fembiodv = NDEigenvalues::fembiodv = NDSolve`ProcessEquations::fembiodv = "The dependent variables (`1`) do not match the dependent variables specified through \"InterpolationOrder\" (`2`)."
NDSolve::femnro = NDSolveValue::femnro = ParametricNDSolve::femnro = ParametricNDSolveValue::femnro = NDSolve`ProcessEquations::femnro = NDEigensystem::femnro = NDEigenvalues::femnro = NDSolve`FEM`InitializePDEMethodData::femnro = NDSolve`FEM`InitializeFEMMethodData::femnro = "Node reordering cannot be used with mixed interpolation order. Set \"NodeReordering\" -> False."
NDSolve::fembio = NDSolveValue::fembio = ParametricNDSolve::fembio = ParametricNDSolveValue::fembio = NDEigensystem::fembio = NDEigenvalues::fembio = NDSolve`ProcessEquations::fembio = NDSolve`FEM`InitializePDEMethodData::fembio = NDSolve`FEM`InitializeFEMMethodData::fembio = NDEigensystem::fembio = NDEigenvalues::fembio = "The integration order `1` must be at least 1 and not more than 5."
NDSolve::fembeo = NDSolveValue::fembeo = ParametricNDSolve::fembeo = ParametricNDSolveValue::fembeo = NDEigensystem::fembeo = NDEigenvalues::fembeo = NDSolve`ProcessEquations::fembeo = NDSolve`FEM`InitializePDEMethodData::fembeo = NDSolve`FEM`InitializeFEMMethodData::fembeo = "At least one of the requested element order `1` must be as large as the mesh order `2`."
NDSolve::femimvr = NDSolveValue::femimvr = ParametricNDSolve::femimvr = ParametricNDSolveValue::femimvr = NDSolve`ProcessEquations::femimvr = NDSolve`FEM`InitializePDEMethodData::femimvr = NDSolve`FEM`InitializeFEMMethodData::femimvr = NDSolve`FEM`InitializePDECoefficients::femimvr = NDSolve`FEM`InitializeBoundaryConditions::femimvr = "The number of independent variables `1` (`2`) does not match the embedding dimension `3`" (*EmbeddingDimension*)
NDSolve::femnem = NDSolveValue::femnem = ParametricNDSolve::femnem = ParametricNDSolveValue::femnem = NDSolve`ProcessEquations::femnem = NDSolve`FEM`InitializePDEMethodData::femnem = NDSolve`FEM`InitializeFEMMethodData::femnem = NDSolve`FEM`InitializePDECoefficients::femnem = NDSolve`FEM`InitializeBoundaryConditions::femnem = NDEigensystem::femnem = NDEigenvalues::femnem = "The finite element method needs a full element mesh."
NDSolve::femngo = NDSolveValue::femngo = ParametricNDSolve::femngo = ParametricNDSolveValue::femngo = NDSolve`ProcessEquations::femngo = NDSolve`FEM`InitializePDEMethodData::femngo = NDSolve`FEM`InitializeFEMMethodData::femngo = NDSolve`FEM`InitializePDECoefficients::femngo = NDSolve`FEM`InitializeBoundaryConditions::femngo = "The geometry data cannot be initialized."
(* FEM PDE coefficient initialization *)
NDSolve::femcbtd = NDSolveValue::femcbtd = ParametricNDSolve::femcbtd = ParametricNDSolveValue::femcbtd = NDEigensystem::femcbtd = NDEigenvalues::femcbtd = NDSolve`ProcessEquations::femcbtd = NDSolve`FEM`InitializePDECoefficients::femcbtd = "To validate the PDE coefficients a coordinate that is part of the region `1` is needed but could not be found in a time of `2` (sec). One way to avoid this issue is to use ToElementMesh to generate an ElementMesh and use that as a region input. Alternatively, the \"SymbolicProcessing\" option of the SystemOptions[\"FiniteElementOptions\"] could be increased to allow for more searching time."
NDSolve::femcll = NDSolveValue::femcll = ParametricNDSolve::femcll = ParametricNDSolveValue::femcll = NDSolve`ProcessEquations::femcll = NDSolve`FEM`InitializePDECoefficients::femcll = "For the PDEs' load coefficients, 2 operators instead of `1` need to be specified."
NDSolve::femcsl = NDSolveValue::femcsl = ParametricNDSolve::femcsl = ParametricNDSolveValue::femcsl = NDSolve`ProcessEquations::femcsl = NDSolve`FEM`InitializePDECoefficients::femcsl = "For the PDEs' stiffness coefficients, 4 operators instead of `1` need to be specified."
NDSolve::femcdl = NDSolveValue::femcdl = ParametricNDSolve::femcdl = ParametricNDSolveValue::femcdl = NDSolve`ProcessEquations::femcdl = NDSolve`FEM`InitializePDECoefficients::femcdl = "For the PDEs' first transient coefficient, 1 operator instead of `1` needs to be specified."
NDSolve::femcml = NDSolveValue::femcml = ParametricNDSolve::femcml = ParametricNDSolveValue::femcml = NDSolve`ProcessEquations::femcml = NDSolve`FEM`InitializePDECoefficients::femcml = "For the PDEs' second transient coefficient, 1 operator instead of `1` needs to be specified."
NDSolve::femcdim = NDSolveValue::femcdim = ParametricNDSolve::femcdim = ParametricNDSolveValue::femcdim = NDSolve`ProcessEquations::femcdim = NDSolve`FEM`InitializePDECoefficients::femcdim = "PDE coefficient `1` needs to be of Dimensions `2`."
NDSolve::femcdt = NDSolveValue::femcdt = ParametricNDSolve::femcdt = ParametricNDSolveValue::femcdt = NDEigensystem::femcdt = NDEigenvalues::femcdt = NDSolve`FEM`ToElementMesh::femcdt = "The value, `1`, for the option \"DomainType\" should be either Real or Complex."
NDSolve::femcnmd = NDSolveValue::femcnmd = ParametricNDSolve::femcnmd = ParametricNDSolveValue::femcnmd = NDSolve`ProcessEquations::femcnmd = NDSolve`FEM`InitializePDECoefficients::femcnmd = NDEigensystem::femcnmd = NDEigenvalues::femcnmd = "The PDE coefficient `1` does not evaluate to a numeric matrix of dimensions `2` at the coordinate `3`; it evaluated to `4` instead."
NDSolve::femcmsd = NDSolveValue::femcmsd = ParametricNDSolve::femcmsd = ParametricNDSolveValue::femcmsd = NDSolve`ProcessEquations::femcmsd = NDSolve`FEM`InitializePDECoefficients::femcmsd = NDEigensystem::femcmsd = NDEigenvalues::femcmsd = "The spatial derivative order of the PDE may not exceed two."
NDSolve::femcnsd = NDSolveValue::femcnsd = ParametricNDSolve::femcnsd = ParametricNDSolveValue::femcnsd = NDSolve`ProcessEquations::femcnsd = NDSolve`FEM`InitializePDECoefficients::femcnsd = NDEigensystem::femcnsd = NDEigenvalues::femcnsd = "The PDE coefficient `1` does not evaluate to a numeric scalar at the coordinate `2`; it evaluated to `3` instead."
(* FEM PDE coefficient stability analysis *)
NDSolve::femcscd = NDSolveValue::femcscd = ParametricNDSolve::femcscd = ParametricNDSolveValue::femcscd = NDEigensystem::femcscd = NDEigenvalues::femcscd = NDSolve`ProcessEquations::femcscd = NDSolve`FEM`InitializePDECoefficients::femcscd = "The PDE is convection dominated and the result may not be stable. Adding artificial diffusion may help."
NDSolve::femcsp = NDSolveValue::femcsp = ParametricNDSolve::femcsp = ParametricNDSolveValue::femcsp = NDEigensystem::femcsp = NDEigenvalues::femcsp = NDSolve`ProcessEquations::femcsp = NDSolve`FEM`InitializePDECoefficients::femcsp = "The computed Peclet number is `1` and is larger than the mesh order (`2`), and the result may not be stable. Adding artificial diffusion may help."
NDSolve::femcsdp = NDSolveValue::femcsdp = ParametricNDSolve::femcsdp = ParametricNDSolveValue::femcsdp = NDEigensystem::femcsdp = NDEigenvalues::femcsdp = NDSolve`ProcessEquations::femcsdp = NDSolve`FEM`InitializePDECoefficients::femcsdp = "The product of 2 times the Damkoehler number (`1`) and the Peclet number (`2`) is `3` and is larger than the mesh order (`4`), and the computed result may not be stable. Adding artificial diffusion may help."
(* FEM boundary condition initialization *)
NDSolve::fembdcc = NDSolveValue::fembdcc = ParametricNDSolve::fembdcc = ParametricNDSolveValue::fembdcc = NDEigensystem::fembdcc = NDEigenvalues::fembdcc = NDSolve`ProcessEquations::fembdcc = NDSolve`FEM`InitializeBoundaryConditions::fembdcc = "Cross-coupling of dependent variables in `1` is not supported in this version."
NDSolve::fembdnl = NDSolveValue::fembdnl = ParametricNDSolve::fembdnl = ParametricNDSolveValue::fembdnl = NDEigensystem::fembdnl = NDEigenvalues::fembdnl = NDSolve`ProcessEquations::fembdnl = NDSolve`FEM`InitializeBoundaryConditions::fembdnl = "The dependent variable in `1` in the boundary condition `2` needs to be linear."
NDSolve::fembpf = NDSolveValue::fembpf = ParametricNDSolve::fembpf = ParametricNDSolveValue::fembpf = NDEigensystem::fembpf = NDEigenvalues::fembpf = NDSolve`ProcessEquations::fembpf = NDSolve`FEM`InitializeBoundaryConditions::fembpf = "The boundary condition `1` is not valid."
NDSolve::fembpw = NDSolveValue::fembpw = NDEigensystem::fembpw = NDEigenvalues::fembpw =  ParametricNDSolve::fembpw = ParametricNDSolveValue::fembpw = NDSolve`ProcessEquations::fembpw = NDSolve`FEM`InitializeBoundaryConditions::fembpw = "The boundary condition `1` cannot be parsed and will be ignored."
NDSolve::fembrne = NDSolveValue::fembrne = ParametricNDSolve::fembrne = ParametricNDSolveValue::fembrne = NDSolve`ProcessEquations::fembrne = NDSolve`FEM`InitializeBoundaryConditions::fembrne = "The Neumann type boundary condition `2` cannot contain the equation `1`; instead, a value should be specified."
NDSolve::fembrvf = NDSolveValue::fembrvf = ParametricNDSolve::fembrvf = ParametricNDSolveValue::fembrvf = NDSolve`ProcessEquations::fembrvf = NDSolve`FEM`InitializeBoundaryConditions::fembrvf = "The dependent variable in `1` in the Neumann boundary condition `2` needs to be linear."
NDSolve::femibcbdl = NDSolveValue::femibcbdl = ParametricNDSolve::femibcbdl = ParametricNDSolveValue::femibcbdl = NDSolve`FEM`InitializeBoundaryConditions::femibcbdl = "The number of boundary condition sets (`1`) does not match the number of dependent variables (`2`)."
NDSolve::femibcsfn = NDSolveValue::femibcsfn = ParametricNDSolve::femibcsfn = ParametricNDSolveValue::femibcsfn = NDSolve`FEM`InitializeBoundaryConditions::femibcsfn = "\"ScaleFactor\" needs to be None or a non-negative numeric quantity, not `1`."
NDSolve::femibcnc = NDSolveValue::femibcnc = ParametricNDSolve::femibcnc = ParametricNDSolveValue::femibcnc = NDSolve`ProcessEquations::femibcnc = NDSolve`FEM`InitializeBoundaryConditions::femibcnc = "Complex-valued NeumannValues (`1`) cannot be handled in this version."
NDSolve::femibcnd = NDSolveValue::femibcnd = ParametricNDSolve::femibcnd = ParametricNDSolveValue::femibcnd = NDSolve`ProcessEquations::femibcnd = NDSolve`FEM`InitializeBoundaryConditions::femibcnd = "No DirichletCondition or Robin-type NeumannValue was specified for `1`; the result may not be unique."
NDSolve`FEM`InitializeBoundaryConditions::femibcpa = "During partial boundary assembly the number of point element groups (`1`) and number of boundary element groups (`2`) must match."
(* FEM PDESolve *)
NDSolve::fempsdbcf = NDSolveValue::fempsdbcf = ParametricNDSolve::fempsdbcf = ParametricNDSolveValue::fempsdbcf = NDSolve`FEM`PDESolve::fempsdbcf = "The boundary condition discretization failed."
NDSolve::fempsdpf = NDSolveValue::fempsdpf = ParametricNDSolve::fempsdpf = ParametricNDSolveValue::fempsdpf = NDSolve`FEM`PDESolve::fempsdpf = "The partial differntial equation discretization failed."
NDSolve::fempsf = NDSolveValue::fempsf = ParametricNDSolve::fempsf = ParametricNDSolveValue::fempsf = NDSolve`FEM`PDESolve::fempsf = "PDESolve could not find a solution."
NDSolve::fempslf = NDSolveValue::fempslf = ParametricNDSolve::fempslf = ParametricNDSolveValue::fempslf = NDSolve`FEM`PDESolve::fempslf = "The linearization process in PDESolve failed."
(* FEM PDE discretization *)
NDSolve::femdpt = NDSolveValue::femdpt = ParametricNDSolve::femdpt = ParametricNDSolveValue::femdpt = NDSolve`FEM`DiscretizePDE::femdpt = "Time must be specified either as a numeric quantity or as None instead of `1`."
NDSolve::femdpu = NDSolveValue::femdpu = ParametricNDSolve::femdpu = ParametricNDSolveValue::femdpu = NDSolve`FEM`DiscretizePDE::femdpu = "The initial dependent variable must be specified as a vector, a matrix quantity, or as None instead of `1`."
NDSolve::femdpop = NDSolveValue::femdpop = ParametricNDSolve::femdpop = ParametricNDSolveValue::femdpop = NDSolve`FEM`DiscretizePDE::femdpop = NDEigensystem::femdpop = NDEigenvalues::femdpop = "The `1` operator failed."
(* FEM coefficient and boundary condition extraction *)
NDSolve::femep = NDSolveValue::femep = ParametricNDSolve::femep = ParametricNDSolveValue::femep = NDSolve`FEM`ExtractPDECoefficients::femep = NDSolve`FEM`ExtractBoundaryConditions::femep = "`1` is not a valid property."
(* FEM boundary condition deployment *)
NDSolve::femdbclsd = NDSolveValue::femdbclsd = ParametricNDSolve::femdbclsd = ParametricNDSolveValue::femdbclsd = NDEigensystem::femdbclsd = NDEigenvalues::femdbclsd = NDSolve`ProcessEquations::femdbclsd = NDSolve`FEM`DeployBoundaryConditions::femdbclsd = "The system load length `1` does not match the system stiffness matrix dimensions of `2`."
NDSolve::femdbcno = NDSolveValue::femdbcno = ParametricNDSolve::femdbcno = ParametricNDSolveValue::femdbcno = NDSolve`ProcessEquations::femdbcno = NDSolve`FEM`DeployBoundaryConditions::femdbcno = "`1` is not a valid constraint method. Possible options are \"Insert\" or \"Append\". Using default instead."
NDSolve::femdbcdnm = NDSolveValue::femdbcdnm = ParametricNDSolve::femdbcdnm = ParametricNDSolveValue::femdbcdnm = NDEigensystem::femdbcdnm = NDEigenvalues::femdbcdnm = NDSolve`ProcessEquations::femdbcdnm = NDSolve`FEM`DeployBoundaryConditions::femdbcdnm = "Boundary condition dimensions do not match system matrices dimensions."
NDSolve::femdbclblnm = NDSolveValue::femdbclblnm = ParametricNDSolve::femdbclblnm = ParametricNDSolveValue::femdbclblnm = NDEigensystem::femdbclblnm = NDEigenvalues::femdbclblnm = NDSolve`FEM`DeployBoundaryConditions::femdbclblnm = "The system load dimensions `1` are not the same as the boundary load dimensions `2`."
NDSolve::femdbcsbsnm = NDSolveValue::femdbcsbsnm = ParametricNDSolve::femdbcsbsnm = ParametricNDSolveValue::femdbcsbsnm = NDSolve`FEM`DeployBoundaryConditions::femdbcsbsnm = "The system stiffness dimensions `1` are not the same as the boundary stiffness dimensions `2`."
NDSolve::fembcdpv = NDSolveValue::fembcdpv = ParametricNDSolve::fembcdpv = ParametricNDSolveValue::fembcdpv = NDSolve`FEM`FEMDirichletPositionValues::fembcdpv = "Could not evaluate Dirichlet boundary condition `1` on element mesh."
NDSolve::femnodpbc = NDSolveValue::femnodpbc = ParametricNDSolve::femnodpbc = ParametricNDSolveValue::femnodpbc = NDEigensystem::femnodpbc = NDEigenvalues::femnodpbc = NDSolve`ProcessEquations::femnodpbc = NDSolve`FEM`DiscretizeBoundaryConditions::femnodpbc = "DirichletCondition can not be present on the target boundary of a PeriodicBoundaryConditon."
NDSolve::fempbcmf = NDSolveValue::fempbcmf = ParametricNDSolve::fempbcmf = ParametricNDSolveValue::fempbcmf = NDEigensystem::fempbcmf = NDEigenvalues::fempbcmf = NDSolve`ProcessEquations::fempbcmf = NDSolve`FEM`DiscretizeBoundaryConditions::fempbcmf = "Applying the mapping `1` of the periodic boundary condition `2` to the coordinates `3` did not result in a list of mapped coordinates."
NDSolve::fempbcnomr = NDSolveValue::fempbcnomr = ParametricNDSolve::fempbcnomr = ParametricNDSolveValue::fempbcnomr = NDEigensystem::fempbcnomr = NDEigenvalues::fempbcnomr = NDSolve`ProcessEquations::fempbcnomr = NDSolve`FEM`DiscretizeBoundaryConditions::fempbcnomr = "Could not convert the mesh for the periodic boundary condition."
NDSolve::fempbcpf = NDSolveValue::fempbcpf = ParametricNDSolve::fempbcpf = ParametricNDSolveValue::fempbcpf = NDEigensystem::fempbcpf = NDEigenvalues::fempbcpf = NDSolve`ProcessEquations::fempbcpf = NDSolve`FEM`DiscretizeBoundaryConditions::fempbcpf = "Using the periodic boundary condition `1` the projection of the target coordinates `2` with `3` onto the source region failed; Specifically the coordinates `4` did not map into the region."
NDSolve::fempbcf = NDSolveValue::fempbcf = ParametricNDSolve::fempbcf = ParametricNDSolveValue::fempbcf = NDEigensystem::fempbcf = NDEigenvalues::fempbcf = NDSolve`ProcessEquations::fempbcf = NDSolve`FEM`DiscretizeBoundaryConditions::fempbcf = "The periodic boundary condition `1` could not be computed."
NDSolve::fembcnim = NDSolveValue::fembcnim = ParametricNDSolve::fembcnim = ParametricNDSolveValue::fembcnim = NDEigensystem::fembcnim = NDEigenvalues::fembcnim = NDSolve`ProcessEquations::fembcnim = NDSolve`FEM`DiscretizeBoundaryConditions::fembcnim = "Not all element incidents of the boundary condition `1` are part of the mesh." 
NDSolve::fembcnil = NDSolveValue::fembcnil = ParametricNDSolve::fembcnil = ParametricNDSolveValue::fembcnil = NDEigensystem::fembcnil = NDEigenvalues::fembcnil = NDSolve`ProcessEquations::fembcnil = NDSolve`FEM`DiscretizeBoundaryConditions::fembcnil = "The element incidents of the boundary condition `1` need to be a list of integers that match dimensions `2`." 
NDSolve::fembciint = NDSolveValue::fembciint = ParametricNDSolve::fembciint = ParametricNDSolveValue::fembciint = NDEigensystem::fembciint = NDEigenvalues::fembciint = NDSolve`ProcessEquations::fembciint = NDSolve`FEM`DiscretizeBoundaryConditions::fembciint = "Element incident specifications for boundary conditions need to be lists of Integers." 
NDSolve::fembcirls = NDSolveValue::fembcirls = ParametricNDSolve::fembcirls = ParametricNDSolveValue::fembcirls = NDEigensystem::fembcirls = NDEigenvalues::fembcirls = NDSolve`ProcessEquations::fembcirls = NDSolve`FEM`DiscretizeBoundaryConditions::fembcirls = "Element incident specifications for boundary conditions need to be given as a Rule." 
(* FEM visualization *)
NDSolve`FEM`ElementMeshWireframe::femcnv = NDSolve`FEM`ElementMeshWireframe3D::femcnv = NDSolve`FEM`ElementMeshPlot3D::femcnv = NDSolve`FEM`ElementMeshSurfacePlot3D::femcnv = NDSolve`FEM`ElementMeshContourPlot::femcnv = NDSolve`FEM`ElementToGraphicsComplex::femcnv = "ElementMesh coordinates not valid."
NDSolve`FEM`ElementMeshWireframe::femhdv = NDSolve`FEM`ElementMeshWireframe3D::femhdv = "Cannot plot higher-dimensional meshes."
NDSolve`FEM`ElementMeshWireframe::femetgf = NDSolve`FEM`ElementMeshWireframe3D::femetgf = NDSolve`FEM`ElementMeshPlot3D::femetgf = NDSolve`FEM`ElementMeshSurfacePlot3D::femetgf = NDSolve`FEM`ElementMeshContourPlot::femetgf = NDSolve`FEM`ElementToGraphicsComplex::femetgf = "Cannot convert element mesh `1` to GraphicsComplex."
NDSolve`FEM`ElementMeshToGraphicsComplex::fememwnpe = NDSolve`FEM`ElementMeshWireframe::fememwnpe = NDSolve`FEM`ElementMeshWireframe3D::fememwnpe = "`1` is not a property of an element mesh. Use \"PointElements\", \"BoundaryElements\", or \"MeshElements\". Using default for now."
(* FEM support functions *)
NDSolve`FEM`AssembleMatrix::badmat = "`1` is not a valid element matrix to be assembled."
NDSolve`FEM`MapInverse::smatlst = "`1` needs to be a symbol that evaluates to a numeric matrix."
(* NDEigensystem/NDEigenvalues *)
NDEigensystem::noopt = NDEigenvalues::noopt = "The method specified by `1` is not a known built-in method."
NDEigensystem::nosopt = NDEigenvalues::nosopt = "The sub-option specified by `2` is not a known option for `1`."
NDEigensystem::icfail = NDEigenvalues::icfail = "Initial condition creation failed."
NDSolve`FEM`ToElementMesh::mrfcf = DiscretizeRegion::mrfcf = DiscretizeGraphics::mrfcf = TriangulateMesh::mrfcf = "The MeshRefinementFunction `1` could not be compiled and will be ignored. Provide a CompiledFunction cf that evaluates to True or False for the input Apply[cf, `2`]."
NDSolve`FEM`ToElementMesh::mrff = DiscretizeRegion::mrff = DiscretizeGraphics::mrff = TriangulateMesh::mrff = "The MeshRefinementFunction `1` is not valid and will be ignored. The function does not return either True or False."
(* NDSolve/FEM lacking functionality *)
NDSolve::femnlmts = NDSolveValue::femnlmts = ParametricNDSolve::femnlmts = ParametricNDSolveValue::femnlmts = NDSolve`ProcessEquations::femnlmts = "Appending constraints to transient systems is not available in this version of NDSolve. Constraints are inserted instead."
NDSolve::fembcdepderiv = NDSolveValue::fembcdepderiv = ParametricNDSolve::fembcdepderiv = ParametricNDSolveValue::fembcdepderiv = NDSolve`ProcessEquations::fembcdepderiv = NDEigensystem::fembcdepderiv = NDEigenvalues::fembcdepderiv = "Derivatives of dependent variables in boundary conditions are not supported with the Finite Element Method in this version of NDSolve."
NDSolve::femconsttderiv = NDSolveValue::femconsttderiv = ParametricNDSolve::femconsttderiv = ParametricNDSolveValue::femconsttderiv = NDSolve`ProcessEquations::femconsttderiv = "Temporal derivatives need to have coefficients that are constant in time in this version of NDSolve."
NDSolve::fembcderiv = NDSolveValue::fembcderiv = ParametricNDSolve::fembcderiv = ParametricNDSolveValue::fembcderiv = NDSolve`ProcessEquations::fembcderiv = "Dirichlet boundary conditions need to be differentiable by D[`1`, `2`] in this version of NDSolve."
NDSolve::fememd = NDSolveValue::fememd = ParametricNDSolve::fememd = ParametricNDSolveValue::fememd = NDSolve`ProcessEquations::fememd = NDEigensystem::fememd = NDEigenvalues::fememd = "The region dimension of a given region (`1`) needs to be the same as the region's embedding dimension in this version of `2`."
NDSolve::fememrc = NDSolveValue::fememrc = ParametricNDSolve::fememrc = ParametricNDSolveValue::fememrc = NDSolve`ProcessEquations::fememrc = "The ranges `1` cannot be combined to a region. Please specify a combined region."
NDSolve::femnfm = NDSolveValue::femnfm = ParametricNDSolve::femnfm = ParametricNDSolveValue::femnfm = NDEigensystem::femnfm = NDEigenvalues::femnfm = NDSolve`ProcessEquations::femnfm = "The current version of NDSolve cannot solve equations over boundaries or surfaces. Please specify a region where the embedding dimension is the same as the dimension."
(* Nonlinear FEM messages *)
NDSolve::femnlinig = NDSolveValue::femnlinig = ParametricNDSolve::femnlinig = ParametricNDSolveValue::femnlinig = NDEigensystem::femnlinig = NDEigenvalues::femnlinig = NDSolve`ProcessEquations::femnlinig = NDSolve`FEM`PDESolve::femnlinig = "`1` initial seeding function(s) need to be specified. Using `2` as a default."
NDSolve::femnlmdor = NDSolveValue::femnlmdor = ParametricNDSolve::femnlmdor = ParametricNDSolveValue::femnlmdor = NDEigensystem::femnlmdor = NDEigenvalues::femnlmdor = NDSolve`ProcessEquations::femnlmdor = NDSolve`FEM`InitializePDECoefficients::femnlmdor = "The maximum derivative order of the nonlinear PDE coefficients for the Finite Element Method is larger than 1. It may help to rewrite the PDE in inactive form."
NDSolve::femnlsg = NDSolveValue::femnlsg = ParametricNDSolve::femnlsg = ParametricNDSolveValue::femnlsg = NDSolve`ProcessEquations::femnlsg = "The equations given in the InitialSeed option for differential equations solved with the Finite Element Method do not work with derivatives of the dependent variable; specify an equation with the dependent variable instead."
(* End FEM related messages *)
NBodySimulation::brules = "The specification `1` for initial body states should be a nonempty list of associations or a list of rules of the form body->state."
NBodySimulation::bprop = "Required specification for `1` is missing from the initial state `2` given for body `3`."
NBodySimulation::nqmass = "The \"Mass\", `1`, given for body `3` in `2` is not a numerical quantity."
NBodySimulation::pmass = "The \"Mass\", `1`, given for body `3` in `2` should be strictly positive."
NBodySimulation::pvvec = "The `1`, `2`, given for body `4` in `3` should be a vector with numerical quantities and consistent length."
NBodySimulation::pvdim = "`1` `2` given for body `4` in `3` has dimension `5` that is inconsistent with the dimension `6` given for other bodies."
NBodySimulation::prfap = "Both \"PairwisePotential\"->`1` and \"PairwiseForce\"->`2` have been specified.  Only the potential willl be used."
NBodySimulation::extfap = "Both \"ExternalPotential\"->`1` and \"ExternalwiseForce\"->`2` have been specified.  Only the potential willl be used."
NBodySimulation::rules = "`1`->`2` is not in the form of a list of rules with {body1, body2}->function."
NBodySimulation::ppot = "The pairwise potential `1` is not recognized as a named potential."
NBodySimulation::pforce = "The pairwise force `1` is not recognized as a named force."
NBodySimulation::pmiss = "The potential and/or force laws given require body properties `1` that were missing for at least some of the bodies specified."
NBodySimulation::stime = "The simulation time `1` should be a non-negative real number."
NBodySimulation::datat = "When two arguments are used, the first argument should be a valid NBodySimulationData object."
Nearest::near1 = NearestTo::near1 = CentralFeature::near1 = BinLists::near1 = "`1` is neither a list of real points nor a valid list of rules."
Nearest::near3 = NearestTo::near3 = NearestFunction::near3 = "`1` is neither a non-negative integer nor a list of the form {n, r} with n a positive integer and r a non-negative real number."
Nearest::nearuf = NearestTo::nearuf = NearestFunction::nearuf = "The user-supplied distance function `1` does not give a real numeric distance when applied to the point pair `2` and `3`."
Nearest::neard = NearestTo::neard = NearestFunction::neard = "The default distance function does not give a real numeric distance when applied to the point pair `1` and `2`."
Nearest::dmtch = NearestTo::dmtch = NearestFunction::dmtch = "The dimension of `1` and `2` does not match."
Nearest::incompt = NearestTo::incompt = NearestFunction::incompt = "`1` is not compatible with the search points."
Nearest::mepcmp = NearestTo::mepcmp = NearestFunction::mepcmp = "Internal extra precision limit $MaxExtraPrecision reached for some distance comparisons.  These distances were taken as equal even though strict equality was not verified.  Increasing the value of $MaxExtraPrecision may resolve the uncertainty."
NestWhile::nwargs = NestWhileList::nwargs = "Argument `1` in `2` is not of the form n, {m, n}, {n, Infinity}, or All, where m and n are non-negative machine-sized integers."
NestWhile::nres = NestWhileList::nres = "Insufficient results generated to return the `1` term in `2`."
NIntegrate::bdith = "The values of the option BisectionDithering should be reals between -1/4 and 1/4."
NIntegrate::bdmcr = "The Method option of `1` can take only specifications of MonteCarloRule."
NIntegrate::bdmtd = "The Method option should be a built-in method name or a list with a name followed by method options."
NIntegrate::cartdim = "The number of specified one-dimensional rules is larger than the dimension of the integral."
NIntegrate::comp = "For Method -> Oscillatory, the integrand can only contain one term of the general form: f[x] w[x], where w is one of the following functions: Sin, Cos, BesselJ, or BesselY. Try using Expand on your function and apply NIntegrate[..., Method -> Oscillatory] to each part."
NIntegrate::crnzo = "DuffyCoordinates should have its corners specified by lists containing zeros and ones. Each corner specification should match the dimension of the integral."
NIntegrate::deodiv = "DoubleExponentialOscillatory returns a finite integral estimate, but the integral might be divergent."
NIntegrate::deoncon = "DoubleExponentialOscillatory has failed to converge for the integrand `1` over `2`. DoubleExponentialOscillatory obtained `3` and `4` for the integral and error estimates."
NIntegrate::deorel = "The relative error `1` is larger than expected for the integrand `2` over `3` with DoubleExponentialOscillatory method and tuning parameters, TuningParameters -> `4`."
NIntegrate::deorela = "The relative error `1` is larger than expected for the integrand `2` over `3` with DoubleExponentialOscillatory method and automatic tuning parameters, TuningParameters -> `4`. The integration will proceed with TuningParameters -> `5`."
NIntegrate::eincr = "The global error of the strategy GlobalAdaptive has increased more than `1` times. The global error is expected to decrease monotonically after a number of integrand evaluations. Suspect one of the following: the working precision is insufficient for the specified precision goal; the integrand is highly oscillatory or it is not a (piecewise) smooth function; or the true value of the integral is 0. Increasing the value of the GlobalAdaptive option MaxErrorIncreases might lead to a convergent numerical integration. NIntegrate obtained `2` and `3` for the integral and error estimates."
NIntegrate::eonst = "EvenOddSubdivision cannot be its own submethod."
NIntegrate::errprec = "Catastrophic loss of precision in the global error estimate due to insufficient WorkingPrecision or divergent integral."
NIntegrate::grpar = "The rule data, `1`, for GeneralRule should be a list of lists of equal length that represent the abscissas, weights, and error weights."
NIntegrate::ierr = "The argument in the oscillatory function must be of the form a + b x^n, where a and b are constants."
NIntegrate::inits = "The result `1` returned by the strategy initializing function `2` is not a strategy data object of the form StrategyIdentifier_[data___]."
NIntegrate::inovf = "Overflow resulted when attempting to evaluate the integrand at `1` = `2`."
NIntegrate::inum = "Integrand `1` is not numerical at `2` = `3`."
NIntegrate::inumexpr = "Expression `1` derived from integrand `2` is not numerical at `3` = `4`."
NIntegrate::inumr = "The integrand `1` has evaluated to non-numerical values for all sampling points in the region with boundaries `2`."
NIntegrate::inumrexpr = "Expression `1` derived from integrand `2` has evaluated to non-numerical values for all sampling points in the region with boundaries `3`."
NIntegrate::inumri = "The integrand `1` has evaluated to Overflow, Indeterminate, or Infinity for all sampling points in the region with boundaries `2`."
NIntegrate::invcr = "The Cartesian rule specification `1` is invalid."
NIntegrate::izero = "Integral and error estimates are 0 on all integration subregions. Try increasing the value of the MinRecursion option. If value of integral may be 0, specify a finite value for the AccuracyGoal option.";
NIntegrate::levaltrule = "Value of option `1` of method LevinRule should be one of GaussKronrodRule, MultiDimensionalRule, CartesianRule, ClenshawCurtisRule, LobattoKronrodRule, MultiPanelRule, NewtonCotesRule, TrapezoidalRule, LevinRule, RiemannSumRule."
NIntegrate::levamplen = "Value of option \"Amplitude\" -> `1` should be Automatic, or a list of the same length as a list specified by the \"Kernel\" option."
NIntegrate::levdiffdims = "Value of option \"DifferentialMatrix\" -> `1` should be Automatic, or a matrix with dimensions {m, m}, where m is the length of a list specified by the \"Kernel\" option."
NIntegrate::levdiffmultdim = "Value of option \"DifferentialMatrix\" -> `1` should be Automatic for multidimensional integrands."
NIntegrate::levlimterms = "Value of option \"EndpointLimitTerms\" -> `1` should be Automatic or an integer greater than 1."
NIntegrate::levmaxord = "`1` is a Levin function of differential order `2` which exceeds value of option \"MaxOrder\" -> `3`. Treating `1` as a non-Levin function."
NIntegrate::levosclim = "Value of option \"OscillationThreshold\" -> `1` should be a non-negative machine-sized real number or Infinity."
NIntegrate::levpnts = "Value of option \"Points\" -> `1` should be Automatic or an integer greater than 1."
NIntegrate::levswitchosc = "In Method -> LevinRule, value of option `4` appears to exceed number of oscillations of integrand `3` on region `2`. Switching to `1`."
NIntegrate::levtime = "Time spent solving linear system in LevinRule exceeded `1` seconds. Try increasing the value of the \"TimeConstraint\" option or decreasing the value of the \"Points\" option."
NIntegrate::lzero = "Method -> Oscillatory does not support negative, complex, or variable indices for BesselY and BesselJ."
NIntegrate::maxp = "The integral failed to converge after `1` integrand evaluations. NIntegrate obtained `2` and `3` for the integral and error estimates."
NIntegrate::maxsubreg = "NIntegrate did not divide InterpolatingFunction objects in integrand `1` into smooth subregions because the required number of regions `2` exceeds the value of option \"MaxSubregions\" -> `3` of method \"InterpolationPointsSubdivision\"."
NIntegrate::minmax = "MinRecursion (`1`) is greater than MaxRecursion (`2`)."
NIntegrate::mintmin = "Value of option `1` should be a machine size integer greater than or equal to `2`."
NIntegrate::minrp = "At least one of \"MinRecursion\" and \"Partitioning\" should be Automatic. Continuing with \"MinRecursion\" -> Automatic."
NIntegrate::mddim = "Multidimensional methods are for integrals with more than one variable."
NIntegrate::mpdim = "MultiPeriodic is for integrals with dimension less than or equal to twelve. The integration continues with MonteCarlo."
NIntegrate::mrpts = "The value of the option Points at position `2` in `1` should be a machine integer greater than `3`."
NIntegrate::mtdfb = "Numerical integration with `1` failed. The integration continues with Method -> `2`."
NIntegrate::nconv = "This oscillatory integral might not be convergent."
NIntegrate::ncvb = "NIntegrate failed to converge to prescribed accuracy after `1` recursive bisections in `2` near `3` = `4`. NIntegrate obtained `5` and `6` for the integral and error estimates."
NIntegrate::ncvbr = "NIntegrate failed to converge to prescribed accuracy after `1` refinements. NIntegrate obtained `2` and `3` for the integral and error estimates."
NIntegrate::nonlev = "Integrand `1` is not a Levin function."
NIntegrate::nonlevopts = "Integrand `1` is not a Levin function with `2`."
NIntegrate::pwncvb = "NIntegrate failed to converge to prescribed accuracy after `1` recursive bisections."
NIntegrate::ncvi = "NIntegrate failed to converge to prescribed accuracy after `1` iterated refinements in `2` in the region `3`. NIntegrate obtained `4` and `5` for the integral and error estimates."
NIntegrate::pwncvi = "NIntegrate failed to converge to prescribed accuracy after `1` iterated refinements."
NIntegrate::ncvs = "NIntegrate failed to converge near the apparently non-integrable singularity at `1` = `2`."
NIntegrate::nexcl = "Incorrect Exclusions specification `1`."
NIntegrate::nfunc = "Numerical function object is expected at position `2` in `1`."
NIntegrate::ninf = "Invalid use of Infinity in integration limits `1`."
NIntegrate::nintp = "Encountered the non-number `1` at `2` = `3`."
NIntegrate::nlim = "`1` = `2` is not a valid limit of integration."
NIntegrate::noeval = "For oscillating integrals, individual points where evaluation takes place is not supported; the range has to be in the form {x, xmin, xmax}."
NIntegrate::nomdr = "Method `1` cannot use multidimensional integration rules."
NIntegrate::noprec = "There are not enough numbers in the working precision to calculate the internal points in the region `1`."
NIntegrate::nosp = "The SymbolicPreprocessing specification `1` will be ignored since the Method option has symbolic preprocessing specifications."
NIntegrate::nsr = "`1` is not a valid specification of an integration strategy or rule."
NIntegrate::oidiv = "The odd integrand `1` is being considered as zero over the specified region, but may actually be divergent."
NIntegrate::oscfm = "With Method -> `1`, the integrand should be a product of an oscillatory function w[x] and another function f[x], like NIntegrate[ w[x] f[x],{x, a, Infinity}, Method -> Oscillatory]. The function w should be Sin, Cos, BesselJ, or BesselY, and f[x] should be of the form a + b x^n for constant a and b."
NIntegrate::oscint = "This integral does not contain any of the oscillating functions Cos, Sin, BesselJ, or BesselY. Use some other method of NIntegrate instead."
NIntegrate::osran = "Oscillatory methods work only for one-dimensional integrals. The integration continues with Method -> `1`."
NIntegrate::oscir = "Method `1` works only for one-dimensional integrals with infinite ranges."
NIntegrate::osrn = "For oscillating integrals, the range has to contain one Infinity (or -Infinity) and be of nonzero length. The integration continues with the Gauss-Kronrod method."
NIntegrate::ploss = "Numerical integration stopping due to loss of precision. It achieved neither the requested PrecisionGoal nor AccuracyGoal. One of the following is suspected: highly oscillatory integrand or the true value of the integral is 0. If your integrand is oscillatory on an infinite (or semi-infinite) interval, try using the option Method -> Oscillatory in NIntegrate."
NIntegrate::pntsord = "In `1`, options `2` and `3` should not both be specified. Integration continues with `2`."
NIntegrate::pvexeq = "PrincipalValue cannot work with the specified exclusions."
NIntegrate::pvrng = "Singular points must be specified in the integration range in order to use PrincipalValue."
NIntegrate::pvdim = "PrincipalValue can be used for one-dimensional integrals only."
NIntegrate::pvspr = "The PrincipalValue option `1` takes as a value a number or list of numbers with length equal to the number of the singular points."
NIntegrate::riemtype = "Value of option `1` should be \"Left\" or \"Right\"."
NIntegrate::rnderr = "Numerical approximation has caused `1` to take the value `2` where the integrand is singular."
NIntegrate::ruleord = "Value of option `1` should be a machine size integer of the form `2` for positive integer `3`."
NIntegrate::seprec = "The extra precision for the singularity handlers should be a real number greater than the negative of the working precision, `2`, or Automatic."
NIntegrate::singd = "Singularity handling has failed at point `1` = `2` for the specified precision goal. Try using larger values for some combination of ExtraPrecision, WorkingPrecision, SingularityDepth, or MaxRecursion."
NIntegrate::slwcon = "Numerical integration converging too slowly; suspect one of the following: singularity, value of the integration is 0, highly oscillatory integrand, or WorkingPrecision too small."
NIntegrate::sngrn = "DuffyCoordinates works only with integration ranges without singularity specifications."
NIntegrate::spnst = "SymbolicPiecewiseSubdivision can be used only once in the Method option."
NIntegrate::sproc = "The value of SymbolicProcessing should be a positive machine real number or zero."
NIntegrate::tmap = "NIntegrate is unable to achieve the tolerances specified by the PrecisionGoal and AccuracyGoal options because the working precision is insufficient. Try increasing the setting of the WorkingPrecision option."
NIntegrate::typeruleord = "With `4`, value of option `1` should be a machine size integer of the form `2` for positive integer `3`."
NIntegrate::vars = "Integration range specification `1` is not of the form {x, xmin, ..., xmax}."
NIntegrate::vconv = "The value for the option VerifyConvergence can only be Automatic, False, or True."
NIntegrate::vedim = "The number of variables `1` should match the region embedding dimension `2`."
NIntegrate::vtdrop = "The last variable transformation of region `1` was not dropped."
NIntegrate::zeroregion = "Integration region `1` cannot be further subdivided at the specified working precision. NIntegrate assumes zero integral there and on any further indivisible regions."
General::gkrpts = "The Gauss points argument at position `2` in `1` should be an integer greater than `3`."
General::lkrpts = "The Gauss points argument at position `2` in `1` should be an integer greater than `3`."
NIntegrate::mdgen = "The number of generators argument at position `2` in `1` should be one of 5, 6, 9, or Automatic."
NIntegrate`MultiDimensionalRuleData::mdgen = "The number of generators argument at position 1 in `1` should be one of 5, 6, or 9."
NIntegrate`MultiPeriodic::minp = "The value of MinPoints `1` is greater than the maximum number of points allowed `2`."
NIntegrate`SymbolicPiecewiseSubdivision::maxpwc = "The number of piecewise regions has exceeded the maximum value specified by the option MaxPiecewiseCases -> `1`. The integration will continue with no piecewise subdivision."
NIntegrate::mcrdz = "Method `1` is not appropriate for a region of dimension 0. Continuing with method Automatic."
NIntegrate::mcldinf = "Method `1` is not appropriate for an infinite region of dimension lower than that of the embedding space. Continuing with method Automatic."
NIntegrate::mcldm3 = "Method `1` is not implemented for a lower-dimensional region embedded in a space of dimension more than 3. Continuing with method Automatic."
NIntegrate::femrdim = "FiniteElement method can only be applied to regions of embedding dimension 1, 2, or 3."
NIntegrate::onereg = "NIntegrate is not implemented for more than one domain of type NumericalRegion or ElementMesh."
NIntegrate::femonly = "Method `1` is not applicable for this region domain. Continuing with the \"FiniteElement\" method."
NIntegrate::regm = "Method `1` is not applicable for a region domain. Continuing with method Automatic."
General::bcons = "The following constraints are not valid: `1`. Constraints should be equalities, inequalities, or domain specifications involving the variables."
General::lvar = "Variables `1` should be a list of variables, with each element being a variable, or a list containing a variable and lower and upper bounds for the starting region for that variable."
NMinimize::cnft = NMinValue::cnft = NArgMin::cnft = "The point `1` better satisfies the constraints, but evaluates to `2`, which is larger than the final result."
NMaximize::cnft = NMaxValue::cnft = NArgMax::cnft = "The point `1` better satisfies the constraints, but evaluates to `2`, which is smaller than the final result."
General::parchange = "Inappropriate parameter: `1` -> `2`, changed to `3`."
General::nosat = "Obtained solution does not satisfy the following constraints within Tolerance -> `2`: `1`."
General::belt = "Invalid integer elements: `1`. Currently only variables may have a specified domain."
General::elmt = "Invalid variable domain. All variables must be either integers or reals (reals by default)."
General::cnvxg = "The solution found by convex optimization methods is a global optimum."
General::ntcnvx = "The optimization was not solved by convex methods."
QuadraticOptimization::ntcnvx = "The objective function is not convex since the quadratic objective matrix is not convex."
General::incst = "`1` was unable to generate any initial points satisfying the inequality constraints `2`. The initial region specified may not contain any feasible points. Changing the initial region or specifying explicit initial points may provide a better solution."
General::noopmon = "The optimization was solved by an algorithm that does not provide monitoring information.  Choose a specific iterative method if this information is necessary."  
General::nsol = "There are no points that satisfy the constraints `1`."
General::nsolc = "There are no points that satisfy the constraints."
General::dinfeas = "The dual is infeasible, which implies that the primal optimization is either unbounded or infeasible."
General::cvdiv = "Failed to converge to a solution. The function may be unbounded."
General::ubnd = "The problem is unbounded."
General::maxits = "Value of option MaxIterations -> `1` should be a non-negative integer or Automatic."
General::ropn = "Value of option `1` -> `2` should be a non-negative real number."
General::roprl = "Value of option `1` -> `2` should be a real number x greater than `3`."
General::roprlu = "Value of option `1` -> `2` should be a real number between `3` and `4`."
NMinimize::bdmtd = NMaximize::bdmtd = NMinValue::bdmtd = NMaxValue::bdmtd = NArgMin::bdmtd = NArgMax::bdmtd = "Value of option Method -> `1` is not Automatic, \"DifferentialEvolution\", \"NelderMead\", \"RandomSearch\", or \"SimulatedAnnealing\"."
General::vlen = "The vector `1` and the weight vector `2` are of unequal lengths."
Norm::symb = "Norm has received a matrix with symbolic element(s)."
Norm::nvm = "The first Norm argument should be a scalar, vector, or matrix."
NDSolve`ScaledVectorNorm::vinp = "The ScaledVectorNorm argument `1` at position 1 is not a list of numbers."
Norm::winp = NDSolve`ScaledVectorNorm::winp = "The weight vector argument `1` is not a non-empty list of numbers."
Norm::ptype = "The second argument of Norm, `1`, should be a symbol, Infinity, or an integer or real number not less than 1 for vector p-norms; or 1, 2, Infinity, or \"Frobenius\" for matrix norms."
Norm::armsm = "The Arnoldi method cannot be used because the matrix is too small."
Norm::armmps = "The Arnoldi method cannot be used because matrix elements are not machine-precision real/complex numbers. The matrix is replaced with the corresponding dense matrix."
Norm::armmp = "The Arnoldi method cannot be used because matrix elements are not machine-precision real/complex numbers."
NDSolve::urange = NDSolveValue::urange = ParametricNDSolve::urange = ParametricNDSolveValue::urange = NDSolve`ProcessEquations::urange = NDSolve`ScaledVectorNorm::urange = "The scaling vector has a zero component, so the zero absolute tolerance leads to an unbounded value."
NDSolve`ScaledVectorNorm::pinp = "Argument `1` at position 1 in `2` should be a real number greater than or equal to 1 or a function to compute the norm of the scaled vector."
NDSolve`ScaledVectorNorm::sinp = "The scaling vector argument `1` is not a non-empty list of numbers."
NDSolve`ScaledVectorNorm::tinp = "Argument `1` should be a list of non-negative real numbers, {rtol, atol}, giving relative and absolute tolerances with at least one strictly positive."
NDSolve`ScaledVectorNorm::nvec = "No vector specified."
NDSolve::nfnan = NDSolveValue::nfnan = ParametricNDSolve::nfnan = ParametricNDSolveValue::nfnan = NDSolve`ProcessEquations::ufnan = NDSolve`ScaledVectorNorm::nfnan = "The value of the option NormFunction -> `1` applied to the current scaled error vector was `2`, which is not a number."
NDSolve`ScaledVectorNorm::fnnan = "The norm function applied to the scaled vector gave `1`, which is not a number."
NDSolve::nfp = NDSolveValue::nfp = ParametricNDSolve::nfp = ParametricNDSolveValue::nfp = NDSolve`ProcessEquations::nfp = "The value of the option NormFunction -> `1` applied to the current scaled error vector was `2`, which is not a non-negative real number."
NDSolve`ScaledVectorNorm::nfp = "The norm function applied to the scaled vector gave `1`, which is not a non-negative real number."
NotebookDirectory::nosv = NotebookFileName::nosv = "The notebook `1` is not saved."
NotebookEvaluate::nbemax = "Unable to call NotebookEvaluate in `1`. NotebookEvaluateRecursionLimit exceeded."
NotebookEvaluate::nbnfnd = "Unable to find the notebook `1`."
NotebookEvaluate::nbnsvd = "Unable to save changes to the notebook `1`."
NotebookImport::notanb = "No notebook file found at `1`."
NotebookImport::nimpbl = "`1` is not a valid Notebook, NotebookObject, CloudObject, or file name."
NotElement::bset = "The second argument `1` of NotElement should be one of: Primes, Integers, Rationals, Algebraics, Reals, Complexes, or Booleans."
NProduct::bdmtd = "`1` is not a valid specification of a numerical product approximation algorithm."
NProduct::emcon = NSum::emcon = "Euler-Maclaurin sum failed to converge to requested error tolerance."
NProduct::istep = "Cannot get from `1` to `2` in steps of `3`."
NProduct::itfn = "`1` does not have the correct form for an iterator."
NProduct::nplim = "Limit of product `1` is not a number."
NProduct::npnum = "Multiplicand `1` is not numerical at point `2` = `3`."
NProduct::npst = "Product step size `1` is zero or not a number."
NProduct::npz = "Some factors are 1. The algorithms are not very applicable."
NProduct::wynntd = NSum::wynntd = "WynnEpsilon requires the value `1` for the option `2` and the value `3` for the option `4` to satisfy `2` >= 2 (`4` + 1)."
System`Private`NRoot::bdst = "Starting value `1` is not sufficiently close to the true root."
System`Private`NRoot::nnum = "Starting value `1` is not a number."
NRoots::nomod = "NRoots does not take a modulus option."
NRoots::bdmtd = "Method `1` is not one of Automatic, \"Aberth\", \"JenkinsTraub\", or \"CompanionMatrix\"."
NRoots::nnumeq = "`1` is expected to be a polynomial equation in the variable `2` with numeric coefficients."
NRoots::bdmtd = "Method `1` is not one of Automatic, \"Aberth\", \"JenkinsTraub\", or \"CompanionMatrix\"."
System`Private`NRRoot::bpa = "Precision `2` is too low to find real roots of `1`."
System`Private`NRRoot::bfac = "Warning: using factorization `1` = `2` * `3`, which may not be correct. The difference is `4`."
NSolve::sfail = "Subsystem could not be solved for `1` at value `2`. The likely cause is failure to detect zero due to low precision. The likely effect is the loss of one or more solutions. Increasing WorkingPrecision might prevent some solutions from being lost."
NSolve::zerosol = "Scale of possible solution value `1` for variable `2` is too small. Must set this value to zero in order to avoid generation of spurious solutions. This may cause the loss of some solutions."
NSolve::closesols = "Projections of some solutions are close together. This may cause solutions to suffer from severe loss of precision. Increasing the value of WorkingPrecision may resolve this."
NSolve::illcnd = "Possible ill-conditioning detected in system. Likely cause is exact or approximate multiplicity. This may cause solutions to suffer from loss of precision. Use of sufficiently large WorkingPrecision may resolve this."
NSolve::nsolprec = "Cannot obtain small residual. Use of sufficiently large WorkingPrecision may resolve this."
NSolve::infsolns = "Infinite solution set has dimension at least `1`. Returning intersection of solutions with `2` == 1."
NSolve::hom = "The homotopy method requires a square system of polynomial equations in at least two variables."
NSum::bdmtd = "`1` is not a valid specification of a numerical summation approximation algorithm."
NSum::istep = "Cannot get from `1` to `2` in steps of `3`."
NSum::itfn = "`1` does not have the correct form for an iterator."
NSum::nslim = "Limit of summation `1` is not a number."
NSum::nsnum = "Summand (or its derivative) `1` is not numerical at point `2` = `3`."
NSum::nsst = "Summation step size `1` is zero or not a number."
NSum::nsumz = "Some terms are zero. The algorithms are not very applicable."
General::approx = "Unable to compute the exact result for `1`. Numerical approximations will be used instead."
General::sigz = "Number precision is lower than number of digits shown; padding with zeros."
General::reqsigz = "Requested number precision is lower than number of digits shown; padding with zeros."
General::dvec = "The dependency cannot be found for individual components of vector arguments, so the dependency will be treated in block form."
General::mpwc = "`1` was unable to convert `2` to Piecewise because the required number `3` of piecewise cases sought exceeds the internal limit $MaxPiecewiseCases = `4`."
General::nfil = "`1` is not a valid list of filters."
General::nomthd = "There is no method `1` for `2` objects."
General::nnum = "The function value `3` is not a number at `2` = `1`."
General::nnq = "The function value `3` is not a number or quantity at `2` = `1`."
General::nnum1 = "The function value `2` is not a number when the arguments are `1`."
General::nlnum = "The function value `3` is not a list of numbers with dimensions `4` at `2` = `1`."
General::nlnum1 = "The function value `2` is not a list of numbers with dimensions `3` when the arguments are `1`."
General::ngnum = "The gradient is not a vector of numbers at `2` = `1`."
General::ngnum1 = "The gradient is not a vector of numbers when the arguments are `1`."
General::njnum = "The Jacobian is not a matrix of numbers at `2` = `1`."
General::njnum1 = "The Jacobian is not a matrix of numbers when the arguments are `1`."
General::nhnum = "The Hessian is not a matrix of numbers at `2` = `1`."
General::nhnum1 = "The Hessian is not a matrix of numbers when the arguments are `1`."
General::nrnum = "The function value `3` is not a real number at `2` = `1`."
General::nrnq = "The function value `3` is not a real number or quantity at `2` = `1`."
General::nrnum1 = "The function value `2` is not a real number when the arguments are `1`."
General::nrlnum = "The function value `3` is not a list of real numbers with dimensions `4` at `2` = `1`."
General::nrlnum1 = "The function value `2` is not a list of real numbers with dimensions `3` when the arguments are `1`."
General::ninum1 = "The function value `2` is not an integer when the arguments are `1`."
General::nilnum = "The function value `3` is not a list of integers with dimensions `4` at `2` = `1`."
General::nilnum1 = "The function value `2` is not a list of integers with dimensions `3` when the arguments are `1`."
General::nbnum = "The function value `3` is not True or False at `2` = `1`."
General::nbnum1 = "The function value `2` is not True or False when the arguments are `1`."
General::nrgnum = "The gradient is not a vector of real numbers at `2` = `1`."
General::nrgnum1 = "The gradient is not a vector of real numbers of length when the arguments are `1`."
General::nrjnum = "The Jacobian is not a matrix of real numbers at `2` = `1`."
General::nrjnum1 = "The Jacobian is not a matrix of real numbers when the arguments are `1`."
General::nrhnum = "The Hessian is not a matrix of real numbers at `2` = `1`."
General::nrhnum1 = "The Hessian is not a matrix of real numbers when the arguments are `1`."
General::preal = "The parameter `1` should be real-valued."
General::boolder = "Unable to compute the derivative for the Boolean-valued function `1`."
General::intder = "Unable to compute derivatives of `1` with respect to integer- or Boolean-valued variables."
General::fdxact = "Finite differences cannot be used with WorkingPrecision->Infinity."
General::symd = "Unable to automatically compute the symbolic derivative of `1` with respect to the arguments `2`. Numerical approximations to derivatives will be used instead."
General::symd1 = "Unable to automatically compute the symbolic derivative of `1`. Numerical approximations to derivatives will be used instead."
General::symdv = "Unable to automatically compute the symbolic derivative for a function of vector arguments. Numerical approximations to derivatives will be used instead."
General::symfd = "Unable to compute the symbolic second derivative when the first derivative is computed using numerical approximations. Numerical approximations will be used instead."
General::spsder= "The sparsity pattern must be explicitly given for the supplied derivative value function, `1`."
General::sdsh = "The sparsity pattern `1` is inconsistent with the dimensions `2` of the derivative."
General::tma = "Too much accuracy requested at start of problem. Try increasing the value of WorkingPrecision or decreasing the values of AccuracyGoal and/or PrecisionGoal."
General::vardep = "The variable `1` has dependencies on the other variables, `2`. Try using variables that do not depend on each other."
General::vloc = "The variable `1` cannot be localized so that it can be assigned to numerical values."
General::vexdep = "The variable `1` has dependencies in the current session that cause it to evaluate to `2`, which cannot be used as a variable."
General::fsfq = "Unexpected state reached in `1`."
Experimental`CreateNumericalFunction::largd = "Argument specification `1` in `2` is not of the form {name, dimensions}."
Experimental`CreateNumericalFunction::dlist = "Dimension list expected instead of `1` in `2`."
Experimental`CreateNumericalFunction::largs = "Argument specification `1` in `2` is not of the form {name, sample value}."
Experimental`CreateNumericalFunction::nosamp = "Sample argument expected in specification `1`."
Experimental`CreateNumericalFunction::srect = "Sample argument `1` in specification `2` is not a number or array of numbers."
Experimental`CreateNumericalFunction::scdims = "Sample arguments given in specification `1` do not have consistent dimensions."
Experimental`CreateNumericalFunction::pval = "Sample parameter value `1` in `2` is not a number."
Experimental`CreateNumericalFunction::pdim = "Dimensions `1` in `2` for the parameter are inconsistent with the requirement that the parameter be a scalar."
Experimental`CreateNumericalFunction::dimsl = "`1` in list `2` is not a specification for the dimensions of an argument."
Experimental`CreateNumericalFunction::ardims = "The resulting dimensions for `1` cannot be computed automatically unless the option SampleArgument -> True and argument values are given in the second argument."
Experimental`CreateNumericalFunction::jg = "You cannot specify values for both the Gradient and Jacobian options."
Experimental`CreateNumericalFunction::neargs = "The first argument should be a non-empty list of argument specifications."
Experimental`CreateNumericalFunction::arglist = "The sample arguments `1` should be given as a list with elements corresponding to the variables `2`."
Experimental`CreateNumericalFunction::msym = "The value of the option `1` should be a symbol."
Experimental`CreateNumericalFunction::rdim = "The third argument `1` should be a list of positive machine integers containing the result dimensions."
Experimental`CreateNumericalFunction::aimm = "The total lengths of arguments specified by `1` are mismatched with the total length of inputs specified by `2` in `3`."
General::slist = "The value of the option `1` -> `2` is not a list of symbols."
General::stmb = "The value `1` of the option OptimizationSymbol is not a symbol."
General::colvl = "The value `1` of the option CompileOptimizations is not 0, 1, 2, All, or None."
General::lvl = "The value `1` of the option OptimizationLevel is not 0, 1, or 2."
General::smeth = "The method `1` in `2` for computing the derivative is not a function that will be evaluated to give the derivative or one of the strings \"FiniteDifference\" or \"Symbolic\"."
General::spopt = "The option Sparse -> `1` should be Automatic, True, False, or a SparseArray pattern object with corresponding nonzero elements."
Testing`Internal`MVectorNorm::mrange = "Either a vector element or a norm outside machine-precision boundaries."
Testing`Internal`MVectorNorm::mvntestp = "Incorrect p type in MTensor_VectorNorm( ) test driver; must be integer or real."
Testing`Internal`MVectorNorm::mvntestv = "Incorrect vector type in MTensor_VectorNorm( ) test driver; must be real or complex."
Testing`Internal`MScaledVectorNorm::mrange = "Either a vector element or a norm outside machine-precision boundaries."
Testing`Internal`MScaledVectorNorm::mvntestp = "Incorrect p type in MTensor_VectorNorm( ) test driver; must be integer or real."
Testing`Internal`MScaledVectorNorm::mvntestv = "Incorrect vector type in MTensor_VectorNorm( ) test driver; must be real or complex."
NumericQ::set = "Cannot set `1` to `2`; the lhs argument must be a symbol and the rhs must be True or False."
NumericQ::unset = "Cannot clear `1`; the argument must be a symbol."
On::none = "Message `1` not found."
Options::opmix = "Cannot mix streams and non-streams in `1`."
Options::opsym = "Second argument in `1` should be a symbol or a list of symbols."
OptionValue::nodef = "Unknown option `1` for `2`."
OptionValue::optnf = "Option name `1` not found in defaults for `2`."
PadLeft::level = PadRight::level = "The padding specification `1` involves `2` levels; the list `3` has only `4` level."
PadLeft::margin = PadRight::margin = "The list of margins `1` given in `2` must be of the same length (`3`) as the list of padded dimensions `4`."
ArrayPad::mlens = "Padding amount `1` should be an integer, pair of integers, or list of pairs of integers."
ArrayPad::overflow = "Padding sizes {`1`, `2`} for a dimension `3` do not give a result dimension that is a machine-sized integer."
ArrayPad::depth = "Padding amount `1` should specify padding in no more than the number of dimensions in array `2`."
ArrayPad::depthnonempty = "With padding `1`, the padding amount `2` should specify padding in no more than the number of non-empty dimensions in array `3`."
ArrayPad::mindimsize = "With padding `1`, the padding amount `2` should specify positive padding only in dimensions of length at least `3` in array `4`."
ArrayPad::arr = "First argument `1` to ArrayPad should be an array."
ArrayPad::inord = "Value of option InterpolationOrder -> `1` should be a non-negative integer or Infinity. Continuing with InterpolationOrder -> 1."
CenterArray::arg1 = "The specified array `1` can not be centered because it is ragged."
CenterArray::adimsp = "The specified array dimension `1` should be a positive machine integer, Inherited, or a list of such elements."
CenterArray::argpad = "Cannot pad array `1` with padding specification `2`."
ParametricPlot::bend = Plot::bend = "MaxBend `1` is not greater than or equal to 0."
ParametricPlot::pldiv = Plot::pldiv = "Value of PlotDivision -> `1` is not greater than or equal to 1."
General::plld = ParametricPlot3D::plld = "Endpoints for `1` in `2` must have distinct machine-precision numerical values."
General::glims = "Range specifications `1` and `2` contain the same iteration variable."
ContourPlot3D::glims = RegionPlot3D::glims = "Range specifications `1`, `2`, and `3` contain the same iteration variable."
ParametricPlot3D::ppfun = "Argument `1` is not a list with three or four elements."
ParametricPlot3D::pplr = "`1` is not a list starting with three real numbers at `2` = `3`."
ParametricPlot3D::ppta = "Value of option PlotPoints -> `1` is not Automatic, an integer >= 2, or a list of two of these values."
ParametricPlot3D::ppx = "Graphics3D object calculated in ParametricPlot3D is empty."
ParentForm::deflt = "The ParentForm of `1` is not defined on $BoxForms."
Partition::ohpdm = "The `1`-dimensional overhang parameter cannot indicate position in the `2`-dimensional block."
Partition::ohp = ListConvolve::ohp = ListCorrelate::ohp = "Overhang parameters in `1` must be nonzero machine-sized integers, or lists of nonzero machine-sized integers."
Partition::pdep = Developer`PartitionMap::pdep = "Depth `1` requested in object with dimensions `2`."
Partition::pttl = Developer`PartitionMap::pttl = "Partition arguments `2` and `3` must be the same length (since both are lists)."
Partition::npart = "The expression `1` cannot be partitioned."
BlockMap::ldep = "The expression has insufficient depth `1`."
BlockMap::ilsmp = "The specified argument `1` should be a single or a list of positive machine-sized integers."
BlockMap::ndep = "The length `1` of the specified block size should not be greater than `2`."
BlockMap::ddep = "The length `1` of the specified offset should not be greater than `2`."
BlockMap::dncpat = "The specified arguments `1` and `2` should have the same length."
BlockMap::lncpat = "Array depth of at least `2` requested in object with dimensions `1`.";
ArrayFilter::bdr = "Invalid block size or template specification `1`."
PartitionsP::nterms = PartitionsQ::nterms = "The number of terms to sum is not a machine-sized integer."
General::nninfseq = "Position `1` of `2` must be All, Infinity, a non-negative integer, or a List whose first element (required) is a non-negative integer, second element (optional) is a non-negative integer or Infinity, and third element (optional) is a nonzero integer."
IntegerPartitions::rat = "Position `1` of `2` must be a rational number."
IntegerPartitions::rseq = "Position `1` of `2` must be All, a rational number, or a list of rational numbers."
IntegerPartitions::seq = Subsets::seq = Subsequences::seq = "Position `1` of `2` must be All, None, an integer, or a List of 1, 2, or 3 integers, with the third (if present) nonzero."
IntegerPartitions::take = Subsets::take = "Warning: not all elements were found when attempting to take the sequence `1` from `2`, which has length `3`."
IntegerPartitions::undef = "`1` contains partitions that are undefined because they are infinitely large."
IntegerPartitions::infnone = "`1` has either no partitions or infinitely many, but the Wolfram Language has failed to determine which."
IntegerPartitions::toomany = "`1` requests a list of `2` partitions, but the longest list in the Wolfram Language contains `3` elements."
IntegerPartitions::bigk = "In trying to compute `1`, the Wolfram Language attempted to examine potential partitions with more than `2` elements (`2` is the length of the longest list in the Wolfram Language)."
IrreduciblePolynomialQ::undec = "Irreducibility testing methods currently implemented are not sufficient to decide whether the polynomial `1` is irreducible."
IrreduciblePolynomialQ::aundec = "Irreducibility testing methods currently implemented are not sufficient to decide whether the polynomial `1` is absolutely irreducible."
IrreduciblePolynomialQ::mundec = "Irreducibility testing methods currently implemented are not sufficient to decide whether the polynomial `1` is irreducible modulo `2`."
IrreduciblePolynomialQ::mpoly = "`1` is not a polynomial modulo `2`."
IrreduciblePolynomialQ::mext = "Conflicting option setting. If Modulus is not 0, then Extension should be All, Automatic or None."
Pattern::nodef = "No default setting found for `1` in position `2` when length is `3`."
Pattern::patm = "Too many (`1`) optional arguments required in `2`."
Pattern::patsym = "First element in pattern `1` is not a symbol."
Pattern::patvar = "First element in pattern `1` is not a valid pattern name."
Pattern::patv = "Name `1` used for both fixed and variable length patterns."
Optional::optloose = "Optional pattern `1` has no enclosing pattern so no optional value can be matched."
Permutations::fac = "In `1` there are at least `2` distinct elements in the input list, and the requested permutation lengths include one that is at least `2`. The result cannot be computed because it has length at least `2` factorial, which is not a machine integer."
Permutations::len = "`1` cannot be computed because its length is `2`, which is not a machine integer."
Pick::incomp = "Expressions `1` and `2` have incompatible shapes."
Piecewise::pairs = "The first argument `1` of Piecewise is not a list of pairs."
Play::pfnum = "Function `1` (after normalization) never evaluates to a machine-sized real number."
Play::playr = ListPlay::playr = "Value of PlayRange -> `1` is not a list of two machine-sized real numbers."
Play::plx = "First argument `1` does not contain any functions to play."
Play::sample = "Sample length `1` is not a positive machine-sized integer."
Play::sdep = ListPlay::sdep = "Value of SampleDepth -> `1` should be a positive machine-sized integer."
SparseArray::dims = "The dimensions `1` in `2` are not given as a list of positive machine integers."
SparseArray::exdims = "The dimensions cannot be determined from the positions `1`."
SparseArray::drnk = "The requested dimensions, `1`, have length inconsistent with the tensor rank (`2`) of the input."
SparseArray::pind = "The indices in `1` are not all positive."
SparseArray::ilist = "The implicit value `1` in `2` cannot be a list."
SparseArray::rect = "List of rules or non-empty rectangular array expected at position 1 in `1`."
SparseArray::rule = "`1` in `2` is not a replacement rule."
SparseArray::rule1 = "The rule `1` is not of the form indices -> values."
SparseArray::pos = "The left-hand side of `1` in `2` is not a position or pattern that will match a position."
SparseArray::posr = SymmetrizedArray::posr = "The left-hand side of `1` in `2` is not a position or a pattern that will match the position of an element in an array with depth `3`."
SparseArray::posd = "The left-hand side of `1` in `2` is not a position or a pattern that will match the position of an element in an array with dimensions `3`."
SparseArray::valnl = SymmetrizedArray::valnl = "The value specified by the rule `1` should not be a List."
SparseArray::bndst = "The starting position `1` for the band `2` is not an explicit element position in an array."
SparseArray::bndstr = "The starting position `1` for the band `2` is not an explicit element position in an array with depth `3`."
SparseArray::bndendr = "The ending position `1` for the band `2` is not Automatic or an explicit element position in an array with depth `3`."
SparseArray::bndstd = "The starting position `1` for the band `2` is not an explicit element position in an array with dimensions `3`."
SparseArray::bndendd = "The ending position `1` for the band `2` is not Automatic or an explicit element position in an array with dimensions `3`."
SparseArray::bndstp = "The step `1` for the band `2` is not an integer or list of integers having length equal to the array depth `3`."
SparseArray::bndstp0 = "To iterate over the elements in `1` specified for the band values, the step `2` needs to have at least `3` nonzero components."
SparseArray::bndtr = "There are insufficient positions available in the `1` to fit all the values `2` so some of the values will be omitted in the specification `3`."
SparseArray::bndvr = "The values `1` for a band specification should be a scalar, an array of depth less than or equal to `2`, or a list of arrays of depth `2`."
SparseArray::nlimit = "Cannot convert the sparse array `1` to an ordinary array because the `2` elements required exceed the current $SparseArrayNormalLimit value of `3`."
SparseArray`$SparseArrayNormalLimit::limset = StructuredArray`$StructuredArrayNormalLimit::limset = "Cannot set `1` to `2`; value must be Infinity or a non-negative machine-sized integer."
StructuredArray::nlimit = "Cannot convert the structured array `1` to an ordinary array because the `2` elements required exceed the current $StructuredArrayNormalLimit value of `3`."
StructuredArray::nrstrct = "`1` is not a registered structure."
StructuredArray::nosprop = "`1` is not in the list `2` of valid properties for `3` StructuredArray objects."
StructuredArray::stalg = "An algorithm for computing `1` was not found with `2`."
StructuredArray::stalgf = "The algorithm `1` given for `2` failed to evaluate to a result."
StructuredArray::stalgt = "The StructuredArray algorithm for computing `1` did not return a result with the correct form."
StructuredArray::stalgn = "A StructuredArray object of type `1` and dimensions `2` was expanded to a normal representation in order to compute `3`."
StructuredArray::stnrml = "A StructuredArray object of type `1` and dimensions `2` was expanded to a normal representation."
StructuredArray::stnrmlv = "A StructuredArray object of type `1` and dimensions `2` was expanded to a normal representation down to level `3`."
StructuredArray`StructuredMatrixProperties::stmpl = "The value `1` given by StructuredMatrixProperties is not a list of properties."
StructuredArray`StructuredMatrixProperties::stmp = "`1` is not a matrix property."
StructuredArray`StructuredMatrixProperties::stmpi = "The list `1` given by StructuredMatrixProperties has inconsistent properties."
General::spmat = "`1` is not a sparse matrix."
General::sparv = "Valid SparseArray expected at position `2` in `1`."
General::spts = "Scalar, rectangular tensor, or valid SparseArray expected at position `2` in `1`."
General::ptlen = "Objects of unequal length in `1` cannot be combined."
General::take = "Cannot take positions `1` through `2` in `3`."
General::lines = "Cannot take lines `1` through `2` in `3`."
Plot3D::gval = "Function value `1` at grid point xi = `2`, yi = `3` is not a real number."
ListPlot3D::gval = ListContourPlot::gval = ListDensityPlot::gval = ListPlot::gval = ListLinePlot::gval = "Value `1` is not a real number."
ListLinePlot::glval = ListPlot::glval = "`1` is not a valid pair of real numbers."
ListStepPlot::step = "The step specification `1` should be Right, Left, or Center."
OpenRead::nomethod = "Input stream method `1` is not one of the values in $InputStreamMethods."
OpenWrite::nomethod = OpenAppend::nomethod = "Output stream method `1` is not one of the values in $OutputStreamMethods"
Plot3D::plnc = "`1` is neither a machine-sized real number at `2`=`3` nor a list of a real number and a valid color directive."
PlotRange::gtype = Show::gtype = "`1` is not a type of graphics."
PlotRange::prng = "Value of option PlotRange -> `1` is not All, Full, Automatic, a positive machine number, or an appropriate list of range specifications."
LogPlot::invpr = LogLogPlot::invpr = LogLinearPlot::invpr = "Value of option PlotRange should be positive in the scaled dimensions."
General::invpr = "Value of option PlotRange is not compatible with the option ScalingFunctions -> `1`"
PlotRegion::plotr = "Value of PlotRegion -> `1` is not two pairs of real numbers in the form {{xmin, xmax}, {ymin, ymax}}."
PolynomialExtendedGCD::nuniv = Algebra`PolynomialPowerMod`PolynomialPowerMod::nuniv = "`1` and `2` are not univariate polynomials in the same variable."
PolynomialExtendedGCD::method = "Value of option Method -> `1` should be Automatic, GroebnerBasis, Subresultants, or \"Euclidean\"."
Algebra`PolynomialPowerMod`PolynomialPowerMod::expt = "Exponent `1` is not an integer."
Algebra`PolynomialPowerMod`PolynomialPowerMod::imodp = "Value of integer modulus `1` should be a prime number or zero."
Algebra`PolynomialPowerMod`PolynomialPowerMod::ninvm = "Polynomial `1` in `2` is not invertible modulo `3` and `4`."
Algebra`PolynomialPowerMod`PolynomialPowerMod::ninv = "Polynomial `1` in `2` is not invertible modulo `3`."
PolynomialMod::coef = "Value of option CoefficientDomain -> `1` should be Integers or Rationals."
PolynomialMod::polyi = "`1` is not valid input for PolynomialMod."
PolynomialMod::polym = "Modulus `1` is not a positive integer."
Algebra`PolynomialGCDModList::nogcd = "Cannot compute the GCD of `1` and `2` mod `3`."
PrimitivePolynomialQ::nprimemod = Algebra`PolynomialMakeMonicModList::nprimemod = "Modulus `1` is not prime."
Algebra`PolynomialModList::badmod = "Modulus `1` is not a positive integer."
Algebra`PolynomialModList::divby0 = "Cannot divide a univariate polynomial by zero."
Algebra`PolynomialModList::ninv = "Cannot invert `1` modulo `2`."
Algebra`PolynomialModList::nsfmod = "The polynomial `1` is not squarefree modulo `2`."
Algebra`PolynomialModList::unipoly = "The argument `1` is not an integer vector."
Algebra`PolynomialPthRootModList::noroot = "The `1`th root of `2` modulo `1` does not exist."
Algebra`PolynomialQuotientModList::divby0 = "Cannot divide a univariate polynomial by zero."
PossibleZeroQ::bdmtd = "Value of option Method -> `1` is not Automatic or \"ExactAlgebraics\"."
PowerMod::badmod = "The modulus `1` has too large prime factors."
ModularInverse::ninv = PowerMod::ninv = "`1` is not invertible modulo `2`."
ModularInverse::minv = "The two arguments to ModularInverse must be ordinary or Gaussian integers."
PowerMod::pmod = "The base and modulus arguments in `1` must be Gaussian integers and the power must be an integer or rational."
PowerMod::root = "The equation x^`1` = `2` (mod `3`) has no integer solutions."
PowerModList::arg1 = "The first argument `1` of PowerModList is not an integer."
PowerModList::arg2 = "The second argument `1` of PowerModList is not rational."
PowerModList::arg3 = "The third argument `1` of PowerModList is not a positive integer."
Prime::intpp = Internal`QuadraticFundamentalUnit::intpp = "Positive integer argument expected in `1`."
ZetaZero::largp = Prime::largp = PrimePi::largp = PerfectNumber::largp = MersennePrimeExponent::largp = "Argument `1` in `2` is too large for this implementation."
PrimePi::nsfmm = "Insufficient memory to allocate required sieves."
Product::prodwarn = "Warning: `1` contains a capital Pi. Use \[EscapeKey]prod\[EscapeKey] to enter a product sign."
Product::div = "Product does not converge."
Protect::pssl = "`1` is not a string, symbol, or list of strings and symbols."
Internal`QuadraticFundamentalUnit::fund = "The argument `1` of QuadraticFundamentalUnit is not the fundamental discriminant of a real quadratic number field."
Quantile::nquan = "The Quantile specification `1` should be a number or a list of numbers between 0 and 1."
Quantile::parm = Quartiles::parm = InterquartileRange::parm = QuartileDeviation::parm = QuartileSkewness::parm = "The Quantile parameters `1` should be given as a 2 x 2 matrix of real numbers {{a,b},{c,d}} or as a pair of real plot point parameters {a,b}."
General::tol = "Value of option Tolerance -> `1` is not a non-negative real number or Automatic."
General::tol2 = "Value of option Tolerance -> `1` is not a positive real number or Automatic."
Quiet::allall = "Arguments 2 and 3 of `1` should not both be All."
Quiet::anmlist = "Argument `1` of `2` should be All, None, a message name, or a list of message names."
Quiet::conflict = "In `1` the message name(s) `2` appear in both the list of messages to switch off and the list of messages to switch on."
Random::randn = "Range specification `1` in `2` is not a valid number or pair of numbers."
Random::randt = "Type specification `1` in `2` should be Real, Integer, or Complex."
RandomChoice::lrwl = "The items for choice `1` should be a non-empty list or a rule weights -> choices."
RandomChoice::wghtv = RandomSample::wghtv = "The weights given on the left-hand side of `1` should be a list of positive numerical quantities having the same length as the list given on the right-hand side."
RandomChoice::wghtvl = RandomSample::wghtvl = "The weights given on the left-hand side of `1` should have the same length as the data given on the right-hand side."
RandomChoice::wghtva = RandomSample::wghtva = "The association on the left-hand side of `1` should contain the same keys as the association given on the right-hand side."
RandomChoice::array = RandomInteger::array = RandomReal::array = RandomComplex::array = RandomVariate::array = RandomPoint::array = "The array dimensions `2` given in position 2 of `1` should be a list of non-negative machine-sized integers giving the dimensions for the result."
RandomChoice::arrsize = RandomInteger::arrsize = RandomReal::arrsize = RandomComplex::arrsize = "In array dimensions `1` at position 2 of `2`, the product of the first `3` dimensions is `4`, which is not a machine integer."
RandomInteger::udist = RandomReal::udist = RandomComplex::udist = RandomVariate::udist = "The specification `1` is not a random distribution recognized by the system."
RandomInteger::distv = "The result returned by `1` for the distribution `2` was `3`, which is not a vector of integers of length `4`."
RandomReal::distv = "The result returned by `1` for the distribution `2` was `3`, which is not a vector of reals of length `4`."
RandomComplex::distv = "The result returned by `1` for the distribution `2` was `3`, which is not a vector of complex numbers of length `4`."
RandomVariate::distv = "The result returned by `1` for the distribution `2` was `3`, which is not a vector of complex numbers of length `4`."
RandomInteger::unsdst = "The distribution `1` is defined on a set of real values. Use RandomReal instead."
RandomReal::unsdst = "The distribution `1` is defined on a set of integers. Use RandomInteger instead."
RandomVariate::unsdst = "The first argument `1` is not a valid distribution."
RandomInteger::unstyp = "The current random generator does not support generation of random integers in the given range."
RandomReal::unstyp = "The current random generator does not support generation of random reals in the given range."
RandomComplex::unstyp = "The current random generator does not support generation of random complex numbers in the given range."
RandomInteger::unifr = "The endpoints specified by `1` for the endpoints of the discrete uniform distribution range are not integers."
RandomReal::unifr = "The endpoints specified by `1` for the endpoints of the uniform distribution range are not real-valued."
RandomComplex::unifr = "The endpoints specified by `1` for the endpoints of the uniform distribution range are not complex-valued."
RandomReal::parx = RandomInteger::parx = RandomComplex::parx = "`1` should have `2` parameters."
RandomReal::parb = RandomInteger::parb = RandomComplex::parb = "`1` should have between `2` and `3` parameters."
RandomReal::parre = "The parameter `1` in position `2` of `3` should be a real number."
RandomReal::parpos = RandomComplex::parpos = "The parameter `1` in position `2` of `3` should be positive."
RandomReal::precw = "The precision of the parameter `1` is less than WorkingPrecision (`2`)."
RandomReal::posdof = "The degrees of freedom parameter `1` in position `2` of `3` should be positive."
RandomSample::lrwl = "The set of items to sample from, `1`, should be a non-empty list or a rule weights -> choices."
RandomSample::smplen = "RandomSample cannot generate a sample of length `1`, which is greater than the length of the sample set `2`. If you want a choice of possibly repeated elements from the set, use RandomChoice."
Random`MKL::bdmtd = "Value of option Method -> `1` is not one of `2`."
RandomPrime::noprime = "There are no primes in the specified interval."
RandomPrime::posdim = "The dimensions parameter `1` is expected to be a positive integer or a list of positive integers."
RandomPrime::prmrng = "First argument `1` is not a positive integer or a list of two positive integers."
RandomVariate::noimp = "Sampling from `1` is not implemented."
RandomVariate::noimpm = "Sampling from `1` is not implemented with Method -> `2`."
General::creg = "The first argument `1` is expected to be a parameter-free region."
RandomPoint::unbndreg = "The specified region appears to be unbounded. Appropriate bounds will be automatically computed. Explicit bounds may be specified as a third argument."
RandomPoint::pntv = "The result returned by `1` for region `2` was `3`, which not a list of vectors of length `4`."
RandomPoint::mprec = "Random sampling from `1` is currently only supported for machine precision."
RandomPoint::invbbox = "Bounding box `1` does not result in a valid bounding region of the same embedding dimension as the region `2`."
Range::range = "Range specification in `1` does not have appropriate bounds."
Raster::rscd = RasterArray::rscd = "Color `1` is incompatible with the previous color."
Raster::rslim = "Third argument `1` to `2` is not a list of two distinct real numbers."
Raster::rsrec = RasterArray::rsrec = "Second argument `1` in `2` is not a list of two coordinates."
Raster::rsval = "Non-numerical value `1` found at position `2` in first argument of `3`."
RasterArray::rscol = "Expression `1` at position `2` in first argument of `3` is not a valid color or gray-level directive."
RasterArray::obs = "RasterArray is obsolete. Translating to Raster."
Internal`RasterGraphics::argx = "Graphics called with 0 arguments; 1 argument is expected."
Internal`RasterGraphics::rrng = "Value of `1` is not All, Automatic, or an appropriate range specification."
Internal`RasterGraphics::optx = "Unknown option `1` in `2`."
Internal`RasterGraphics::nonopt = "Options expected (instead of `2`) beyond position 1 in `1`. An option must be a rule or a list of rules."
Internal`RasterGraphics::gmat = "`1` is not a rectangular array larger than 2 x 2."
Internal`RasterGraphics::zval = "Non-numerical value `1` found at position `2` in the first argument."
Read::readf = ReadList::readf = Skip::readf = "`1` is not a valid format specification."
Read::readn = ReadList::readn = Skip::readn = "Invalid real number found when reading from `1`."
Read::readt = ReadList::readt = Skip::readt = "Invalid input found when reading `1` from `2`."
Read::readx = ReadList::readx = Skip::readx = "`1` reads no entries."
Read::opstlnone = ReadList::opstlnone = Skip::opstlnone = "Value of option `1` -> `2` should be a string, a list of strings, or None."
RealDigits::digs = "Unable to determine the number of terms in the list of digits."
RealDigits::period = "`1` has a period of `2` digits in base `3`. Use RealDigits[x, b, n] to request n digits."
RealDigits::ndig = "The number of digits to return cannot be determined."
RealExponent::rbase = RealDigits::rbase = MantissaExponent::rbase = NumberExpand::rbase = "Base `1` is not a real number greater than 1."
ContinuedFraction::fnumx = DigitCount::fnumx = RealExponent::fnumx = RealDigits::fnumx = MantissaExponent::fnumx = "The value `1` did not evaluate to a sufficiently precise finite number."
ContinuedFraction::realx = RealDigits::realx = MantissaExponent::realx = "The value `1` is not a real number."
Rescale::nargs = "If the first argument is not a list or a SparseArray, two or three arguments are expected."
Rescale::rtwo = "The argument `1` at position `2` is expected to be a list of a lower bound and an upper bound."
Rescale::dinfdir = "Inconsistent doubly infinite range `1`; endpoints should differ exactly by a factor of -1."
Reduce::bddom = Solve::bddom = NSolve::bddom = "Value `1` of the domain argument should be Complexes, Reals, Algebraics, Rationals, Integers, Primes, or Automatic."
Resolve::bddom = FindInstance::bddom = "Value `1` of the domain argument should be Complexes, Reals, Algebraics, Rationals, Integers, Primes, Booleans, or Automatic."
Reduce::bdomv = Solve::bdomv = NSolve::bdomv = "Warning: `1` is not a valid domain specification. Assuming it is a variable to eliminate."
Reduce::naqs = FindInstance::naqs = Solve::naqs = NSolve::naqs = "`1` is not a quantified system of equations and inequalities."
Reduce::ratnz = "Reduce was unable to solve the system with inexact coefficients. The answer was obtained by solving a corresponding exact system and numericizing the result."
Resolve::ratnz = "Resolve was unable to eliminate quantifiers from the system with inexact coefficients. The answer was obtained by eliminating quantifiers from a corresponding exact system and numericizing the result."
Solve::ratnz = "Solve was unable to solve the system with inexact coefficients. The answer was obtained by solving a corresponding exact system and numericizing the result."
NSolve::ratnz = "NSolve was unable to solve the system with inexact coefficients. The answer was obtained by solving a corresponding exact system and numericizing the result."
Reduce::inex = "Reduce was unable to solve the system with inexact coefficients or the system obtained by direct rationalization of inexact numbers present in the system. Since many of the methods used by Reduce require exact input, providing Reduce with an exact version of the system may help."
Solve::inex = "Solve was unable to solve the system with inexact coefficients or the system obtained by direct rationalization of inexact numbers present in the system. Since many of the methods used by Solve require exact input, providing Solve with an exact version of the system may help."
Reduce::nsmet = "This system cannot be solved with the methods available to Reduce."
Solve::nsmet = "This system cannot be solved with the methods available to Solve."
NSolve::nsmet = "This system cannot be solved with the methods available to NSolve."
Solve::fulldim = NSolve::fulldim = "The solution set contains a full-dimensional component; use Reduce for complete solution information."
Solve::fdimc = NSolve::fdimc = "When parameter values satisfy the condition `1`, the solution set contains a full-dimensional component; use Reduce for complete solution information."
Solve::enum = NSolve::enum = "`1` was unable to enumerate integer solutions. Increasing the value of \"SolveDiscreteSolutionBound\" in SystemOptions[\"ReduceOptions\"] may help."
Solve::tmsol = NSolve::tmsol = "The total number `1` of solutions is too large to enumerate them. Returning one solution."
Reduce::fexp = Resolve::fexp = FindInstance::fexp = Solve::fexp = NSolve::fexp = "Warning: `1` used FunctionExpand to transform the system. Since FunctionExpand transformation rules are only generically correct, the solution set might have been altered."
Minimize::fexp = MinValue::fexp = ArgMin::fexp = "Warning: `1` used FunctionExpand to transform the problem. Since FunctionExpand transformation rules are only generically correct, the result may not be a global minimum."
Maximize::fexp = MaxValue::fexp = ArgMax::fexp = "Warning: `1` used FunctionExpand to transform the problem. Since FunctionExpand transformation rules are only generically correct, the result may not be a global maximum."
Reduce::incs = Resolve::incs = FindInstance::incs = Reduce`IntervalRoots::incs = Solve::incs = NSolve::incs = "Warning: `1` was unable to prove that the solution set found is complete."
Minimize::incs = MinValue::incs = ArgMin::incs = "Warning: `1` was unable to prove that the result is a global minimum."
Maximize::incs = MaxValue::incs = ArgMax::incs = "Warning: `1` was unable to prove that the result is a global maximum."
Reduce::nint = Resolve::nint = FindInstance::nint = Solve::nint = NSolve::nint = "Warning: `1` used numeric integration to show that the solution set found is complete."
Reduce::pmul = Resolve::pmul = FindInstance::pmul = Solve::pmul = NSolve::pmul = "Warning: Solutions that share the first 10 decimal digits with a singular point of the input may be missing."
Reduce::nitc = Resolve::nitc = FindInstance::nitc = Solve::nitc = NSolve::nitc = "Warning: `1` was unable to prove that the solution set found is complete because a numeric integration call did not finish in the allowed time of `2` seconds. Time allowed for numeric integration can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"NIntegrateTimeConstraint\" -> tsec}]."
CountRoots::nint = "Warning: Numeric integration was used to count roots."
CountRoots::pmul = "Warning: Roots that share the first 10 decimal digits with a pole of the input function may not have been counted."
CountRoots::nitc = "Root counting failed because a numeric integration call did not finish in the allowed time of `1` seconds. Time allowed for numeric integration can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"NIntegrateTimeConstraint\" -> tsec}]."
Minimize::nint = MinValue::nint = ArgMin::nint = "Warning: `1` used numeric integration to show that the result is a global minimum."
Minimize::nitc = MinValue::nitc = ArgMin::nitc = "Warning: `1` was unable to prove that the result is a global minimum because a numeric integration call did not finish in the allowed time of `2` seconds. Time allowed for numeric integration can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"NIntegrateTimeConstraint\" -> tsec}]."
Minimize::pmul = MinValue::pmul = ArgMin::pmul = "Warning: Minimum points that share the first 10 decimal digits with a singular point of the input may not be found."
Maximize::nint = MaxValue::nint = ArgMax::nint = "Warning: `1` used numeric integration to show that the result is a global maximum."
Maximize::nitc = MaxValue::nitc = ArgMax::nitc = "Warning: `1` was unable to prove that the result is a global maximum because a numeric integration call did not finish in the allowed time of `2` seconds. Time allowed for numeric integration can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"NIntegrateTimeConstraint\" -> tsec}]."
Maximize::pmul = MaxValue::pmul = ArgMax::pmul = "Warning: Maximum points that share the first 10 decimal digits with a singular point of the input may not be found."
Reduce::rhyp = Resolve::rhyp = FindInstance::rhyp = Solve::rhyp = NSolve::rhyp = "Warning: `1` assumed the Riemann hypothesis in order to prove the solution set found is complete."
Minimize::rhyp = MinValue::rhyp = ArgMin::rhyp = "Warning: `1` assumed the Riemann hypothesis in order to prove that the result is a global minimum."
Maximize::rhyp = MaxValue::rhyp = ArgMax::rhyp = "Warning: `1` assumed the Riemann hypothesis in order to prove that the result is a global maximum."
FindInstance::fwsol = "Warning: FindInstance found only `1` instance(s), but it was not able to prove `2` instances do not exist."
FindInstance::nsmet = "The methods available to FindInstance are insufficient to find the requested instances or prove they do not exist."
FindInstance::exvar = "The system contains a nonconstant expression `1` independent of variables `2`."
FindInstance::boolv = "The system is not Boolean valued at `1`."
Reduce::cpow = Resolve::cpow = FindInstance::cpow = Solve::cpow = NSolve::cpow = "`1` was unable to prove that a radical of an expression containing only real variables and parameters is real-valued. If you are interested only in solutions for which all radicals contained in the input are real-valued, use `1` with domain argument Reals."
Reduce::croot = Resolve::croot = FindInstance::croot = Solve::croot = NSolve::croot = "`1` was unable to prove that a Root object containing only real variables and parameters is real-valued. If you are interested only in solutions for which all Root objects contained in the input are real-valued, use `1` with domain argument Reals."
Reduce::elreg = Resolve::elreg = FindInstance::elreg = Solve::elreg = NSolve::elreg = "Unable to resolve the region membership condition `1`."
Reduce::nric = Resolve::nric = FindInstance::nric = Solve::nric = NSolve::nric = "The system `1` contains a nonreal constant `2` inside an inequality. With no domain argument given, all constants appearing in inequalities should be real."
Reduce::nddc = Resolve::nddc = FindInstance::nddc = Solve::nddc = NSolve::nddc = "The system `1` contains a nonreal constant `2`. With the domain `3` specified, all constants should be real."
Reduce::infc = Resolve::infc = FindInstance::infc = Solve::infc = NSolve::infc = "The system `1` contains an infinite object `2`."
Reduce::nexc = Resolve::nexc = FindInstance::nexc = Solve::nexc = NSolve::nexc = "The system `1` contains a numeric exception `2`."
Reduce::useq = "The answer found by Reduce contains unsolved equation(s) `1`. A likely reason for this is that the solution set depends on branch cuts of Wolfram Language functions."
Solve::useq = "The answer found by Solve contains equational condition(s) `1`. A likely reason for this is that the solution set depends on branch cuts of Wolfram Language functions."
NSolve::useq = "The answer found by NSolve contains equational condition(s) `1`. A likely reason for this is that the solution set depends on branch cuts of Wolfram Language functions."
Reduce::rmod = FindInstance::rmod = Solve::rmod = "Modulus `1` must be a non-negative integer other than 1."
Reduce::mdom = FindInstance::mdom = Solve::mdom = "Warning: Ignoring domain specification `1`; option setting Modulus -> `2` implies domain integers modulo `2`."
Reduce::melem = FindInstance::melem = Solve::melem = "Cannot use Element statements with option setting Modulus -> `1`."
Reduce::mineq = FindInstance::mineq = Solve::mineq = "Cannot use inequalities with option setting Modulus -> `1`."
Solve::mec = "The value of option MaxExtraConditions -> `1` should be a non-negative integer, Infinity, All, or Automatic."
Reduce::mcoef = FindInstance::mcoef = Solve::mcoef = "The system `1` contains a nonrational constant `2`. With Modulus -> `3` all constants should be integers or rational numbers with denominators invertible modulo `3`."
Reduce::munsp = FindInstance::munsp = Solve::munsp = "`1` was unable to solve the system. Increasing the value of \"MaxModularPoints\" in SystemOptions[\"ReduceOptions\"] may help."
Reduce::units = Resolve::units = Solve::units = NSolve::units = FindInstance::units = Minimize::units = MinValue::units = ArgMin::units = Maximize::units = MaxValue::units = ArgMax::units = Integrate::units = NIntegrate::units = "`1` was unable to determine the units of quantities that appear in the input."
FunctionDomain::bdom = FunctionRange::bdom = "Domain specification `1` should be Reals or Complexes."
FunctionDomain::impl = "The answer returned by FunctionDomain contains unsolved equations and/or inequalities."
FunctionDomain::nmet = "Unable to find the domain with the available methods."
FunctionRange::dims = "The first argument `1` and the third argument `2` to FunctionRange should be lists of equal length."
FunctionRange::eopt = "Unable to find the exact range. Returning bounds on the range computed using optimization methods."
FunctionRange::nopt = "Unable to find the exact range. Returning bounds on the range computed using numeric optimization methods."
FunctionRange::impl = "The answer returned by FunctionRange contains unsolved equations and/or inequalities."
FunctionRange::nmet = "Unable to find the range with the available methods."
Refresh::tracksym = "Value of option TrackedSymbols -> `1` is not a list of symbols, All, or Automatic."
Refresh::arg = "The value of the second argument `1` is not None."
RegularExpression::nocond = "No conditions allowed on right-hand side `1` of RegularExpression replacement rule."
RegularExpression::materr = "Internal problem during match; positive match might be missed."
RegularExpression::dollar = "The capturing group reference `1` in `2` has too large a number."
General::maxrec = RegularExpression::maxrec = "Recursion limit exceeded; positive match might be missed."
(* why does PCRE have an error message for no error?  It's included here, but the pcre library has been modified so that we should never get this message*)
RegularExpression::msg0 = "No error in `1`."
RegularExpression::msg1 = "\\ at end of pattern in `1`."
RegularExpression::msg2 = "\\c at end of pattern in `1`."
RegularExpression::msg3 = "Unrecognized character follows \\ in `1`."
RegularExpression::msg4 = "Numbers out of order in {} quantifier in `1`."
RegularExpression::msg5 = "Number too big in {} quantifier in `1`."
RegularExpression::msg6 = "Missing terminating ] for character class in `1`."
RegularExpression::msg7 = "Invalid escape sequence in character class in `1`."
RegularExpression::msg8 = "Range out of order in character class in `1`."
RegularExpression::msg9 = "Nothing to repeat in `1`."
RegularExpression::msg10 = "Operand of unlimited repeat could match the empty string in `1`."
RegularExpression::msg11 = "Internal error: unexpected repeat in `1`."
RegularExpression::msg12 = "Unrecognized character after (? or (?- in `1`."
RegularExpression::msg13 = "POSIX named classes are supported only within a class in `1`."
RegularExpression::msg14 = "Missing ) or \\E (after \\Q) in `1`."
RegularExpression::msg15 = "Reference to non-existent subpattern in `1`."
RegularExpression::msg16 = "Erroffset passed as NULL in `1`."
RegularExpression::msg17 = "Unknown option bit(s) set in `1`."
RegularExpression::msg18 = "Missing ) after comment in `1`."
RegularExpression::msg19 = "Parentheses nested too deeply in `1`."
RegularExpression::msg20 = "Regular expression is too large in `1`."
RegularExpression::msg21 = "Failed to get memory in `1`."
RegularExpression::msg22 = "Unmatched parentheses in `1`."
RegularExpression::msg23 = "Internal error: code overflow in `1`."
RegularExpression::msg24 = "Unrecognized character after (?< in `1`."
RegularExpression::msg25 = "Lookbehind assertion is not fixed length in `1`."
RegularExpression::msg26 = "Malformed number or name after (?( in `1`."
RegularExpression::msg27 = "Conditional group contains more than two branches in `1`."
RegularExpression::msg28 = "Assertion expected after (?( in `1`."
RegularExpression::msg29 = "(?R or (?[+-]digits must be followed by ) in `1`."
RegularExpression::msg30 = "Unknown POSIX class name in `1`."
RegularExpression::msg31 = "POSIX collating elements are not supported in `1`."
RegularExpression::msg32 = "This version of the Wolfram Language is compiled without UTF support in `1`."
RegularExpression::msg33 = "Spare error in `1`."
RegularExpression::msg34 = "Character value in \\x{} or \\o{} is too large in `1`."
RegularExpression::msg35 = "Invalid condition (?(0) in `1`."
RegularExpression::msg36 = "\\C not allowed in lookbehind assertion in `1`."
RegularExpression::msg37 = "The Wolfram Language does not support \\L, \\l, \\N{name}, \\U, or \\u in `1`."
RegularExpression::msg38 = "Number after (?C is > 255 in `1`."
RegularExpression::msg39 = "Closing ) for (?C expected in `1`."
RegularExpression::msg40 = "Recursive call could loop indefinitely in `1`."
RegularExpression::msg41 = "Unrecognized character after (?P in `1`."
RegularExpression::msg42 = "Syntax error in subpattern name (missing terminator) in `1`."
RegularExpression::msg43 = "Two named subpatterns have the same name in `1`."
RegularExpression::msg44 = "Invalid UTF-8 string in `1`."
RegularExpression::msg45 = "Support for \\P, \\p, and \\X has not been compiled in `1`."
RegularExpression::msg86 = "Malformed \\P or \\p sequence in `1`."
RegularExpression::msg47 = "Unknown property name after \\P or \\p in `1`."
(* This error message will need to be changed if MAX_NAME_SIZE is ever changed in config.h *)
RegularExpression::msg48 = "Subpattern name is too long (maximum 32 characters) in `1`."
(* This error message will need to be changed if MAX_NAME_COUNT is ever changed in config.h *)
RegularExpression::msg49 = "Too many named subpatterns (maximum 10000) in `1`."
RegularExpression::msg50 = "Repeated subpattern is too long in `1`."
RegularExpression::msg51 = "Octal value is greater than \\377 in 8-bit non-UTF-8 mode in `1`."
RegularExpression::msg52 = "Internal error: overran compiling workspace in `1`."
RegularExpression::msg53 = "Internal error: previously checked referenced subpattern not found in `1`."
RegularExpression::msg54 = "DEFINE group contains more than one branch in `1`."
RegularExpression::msg55 = "Repeating a DEFINE group is not allowed in `1`."
RegularExpression::msg56 = "Inconsistent NEWLINE options in `1`."
RegularExpression::msg57 = "\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number in `1`."
RegularExpression::msg58 = "A numbered reference must not be zero in `1`."
RegularExpression::msg59 = "An argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT) in `1`."
RegularExpression::msg60 = "(*VERB) not recognized or malformed in `1`."
RegularExpression::msg61 = "Number is too big in `1`."
RegularExpression::msg62 = "Subpattern name expected in `1`."
RegularExpression::msg63 = "Digit expected after (?+ in `1`."
RegularExpression::msg64 = "] is an invalid data character in JavaScript compatibility mode in `1`."
RegularExpression::msg65 = "Different names for subpatterns of the same number are not allowed in `1`."
RegularExpression::msg66 = "(*MARK) must have an argument in `1`."
RegularExpression::msg67 = "This version of the Wolfram Language is not compiled with Unicode property support `1`."
RegularExpression::msg68 = "\\c must be followed by an ASCII character in `1`."
RegularExpression::msg69 = "\\k is not followed by a braced, angle-bracketed, or quoted name in `1`."
RegularExpression::msg70 = "Internal error: unknown opcode in find_fixedlength() in `1`."
RegularExpression::msg71 = "\\N is not supported in a class in `1`."
RegularExpression::msg72 = "Too many forward references in `1`."
RegularExpression::msg73 = "Disallowed Unicode code point (>= 0xd800 && <= 0xdfff) in `1`."
RegularExpression::msg74 = "Invalid UTF-16 string in `1`."
RegularExpression::msg75 = "Name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN) in `1`."
RegularExpression::msg76 = "Character value in \\u.... sequence is too large in `1`."
RegularExpression::msg77 = "Invalid UTF-32 string in `1`."
RegularExpression::msg78 = "Setting UTF is disabled by the application in `1`."
RegularExpression::msg79 = "Non-hex character in \\x{} (closing brace missing?) in `1`."
RegularExpression::msg80 = "Non-octal character in \\o{} (closing brace missing?) in `1`."
RegularExpression::msg81 = "Missing opening brace after \\o in `1`."
RegularExpression::msg82 = "Parentheses are too deeply nested in `1`."
RegularExpression::msg83 = "Invalid range in character class in `1`."
RegularExpression::msg84 = "Group name must start with a non-digit in `1`."
RegularExpression::msg85 = "Parentheses are too deeply nested (stack check) in `1`."
RegularExpression::msg46 = "Missing newline after # in (?x) mode in `1`."
(* this message is not defined in the error_texts array in pcre_compile.c.  It is hard-coded in the function find_error_text, also in pcre_compile.c.  *)
RegularExpression::msgnotfound = "Unknown error (please report)."
RegularExpression::outofmemory = "Regular expression matching failed due to insufficient memory."
Remove::relex = "Cannot remove lexical symbol `1` except automatically (when `2` is removed)."
Remove::remal = "Symbol `1` already removed."
Remove::rmlck = "Symbol `1` is Locked and cannot be removed."
Remove::rmnsm = "There are no symbols matching \"`1`\"."
Remove::rmptc = "Symbol `1` is Protected and cannot be removed."
Remove::spsym = "Special symbol `1` cannot be removed."
General::ssym = "`1` is not a symbol."
General::renfd = "Cannot rename file `1` into a directory."
Repeated::order = RepeatedNull::order = "Range out of order in `1`."
Repeated::range = RepeatedNull::range = "Range specification in integers (max or {min, max}) expected at position `1` in `2`."
Replace::erep = "`1` must be evaluated before use."
Replace::reps = ReplaceAll::reps = ReplaceRepeated::reps = ReplaceList::reps = ReplacePart::reps = "`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing."
Replace::rmix = ReplaceAll::rmix = ReplaceRepeated::rmix = ReplaceList::rmix = "Elements of `1` are a mixture of lists and nonlists."
ReplaceRepeated::rrlim = "Exiting after `1` scanned `2` times."
ResetDirectory::dtop = "Directory stack is empty."
Resultant::method = Discriminant::method = "Value of option Method -> `1` should be Automatic, \"SylvesterMatrix\", \"BezoutMatrix\", Subresultants, or Modular."
Resultant::var = "Not a valid variable in `1`."
Rest::norest = "Cannot take Rest of expression `1` with length zero."
Most::nomost = "Cannot take Most of expression `1` with length zero."
Rest::norest1 = "Cannot take Rest of expression with length zero."
Most::norest1 = "Cannot take Most of expression with length zero."
Reverse::headlm = "Head `1` is inconsistent with Head `2` encountered at previous levels."
Riffle::rspec = "The third argument `1` should be a positive integer or a list with three integers."
Riffle::sepos = "The start and end positions in `1` should be nonzero machine-sized integers."
Riffle::npos = "The spacing between riffled elements given in `1` should be a positive machine-sized integer."
Riffle::inclen = "The start and end positions and the spacing between riffled elements given in `1` cannot be satisfied for the input list of length `2`."
Return::nofsdd = "No enclosing function, Scan, Do, or Dialog found for `1`."
Return::nofunc = "Function `1` not found enclosing `2`."
Return::obs = "Return's functionality of exiting a dialog is obsolete. To exit a dialog, use ExitDialog[] or ExitDialog[expr]. If an ExitDialog[expr] is encountered in the course of evaluation, the dialog will immediately be exited, returning expr."
RevolutionPlot3D::axis = "Value of option RevolutionAxis -> `1` is not \"X\", \"Y\", \"Z\", or a vector."
RepeatedTiming::tspec = "The second argument `1` should be a positive number, or Automatic."
Root::amb = "Root object `1` may be ambiguous. Changing the value of ExactRootIsolation from Root to True and redoing the computations is recommended."
Root::deg = "`1` has fewer than `2` root(s) as a polynomial in `3`."
Root::mdeg = "The degree `1` of the input polynomial `2` is not an integer between 1 and $MaxRootDegree."
PrimitivePolynomialQ::npoly = Root::npoly = "`1` is not a polynomial in `2`."
PrimitivePolynomialQ::nup = Root::nup = "`1` is not a univariate polynomial."
Root::overfl = "Overflow occurred during root isolation. The result may be incorrect."
Root::rnv = "`1` is neither a valid variable nor a valid root number."
Root::sbr = "Because of branch cuts, the series may represent a different root of `1` for some values of `2`."
PrimitivePolynomialQ::var = Root::var = "`1` is not a valid variable."
Root::trsp = "Nonpolynomial root specification `1` is not a list with two elements."
Root::rapp = "Root approximation `1` is not a number."
Root::cnvr = "Cannot verify the existence of a root of `1` equal to `2`."
Root::invrt = "`1` is not equal to a root of `2`."
Root::ambr = "`1` may be equal to more than one root of `2`. Assuming that `3` is equal to `4`."
Root::nunipf = Reduce`ExpLogRoots::nunipf = Reduce`AnalyticRoots::nunipf = Reduce`IntervalRoots::nunipf = "`1` is not a univariate numeric pure function."
Root::nunif = Reduce`ExpLogRoots::nunif = Reduce`AnalyticRoots::nunif = Reduce`IntervalRoots::nunif = "`1` is not a univariate numeric function in `2`."
Root::leql = "`1` and `2` are not non-empty lists of equal length."
Root::rnum = "`1` is not a valid root number."
Root::pfun = "`1` is not a pure function in `2` variables."
Root::vlcf = "The triangular polynomial system `1` does not have a root with indices `2` due to vanishing leading coefficients."
RootApproximant::bdeg = "The degree `1` should be an integer between 1 and $MaxRootDegree."
RootApproximant::mnni = "Value of method option `1` -> `2` should be a non-negative integer."
RootApproximant::mppi = "Value of method option `1` -> `2` should be a positive integer."
RootApproximant::mppn = "Value of method option `1` -> `2` should be a positive number."
RootApproximant::cplx = "An algebraic number of degree one cannot have a nonzero imaginary part. Approximating Re[`1`]."
Roots::badmod = "Cannot extract roots of input modulo `1`."
Roots::eqn = NRoots::eqn = "`1` is not an equation."
Roots::neq = NRoots::neq = "`1` is expected to be a polynomial in the variable `2`."
Roots::lexp = "Exponent of `1` in `2` is too large."
RootSum::pfn = "`1` is not a pure function."
RotateLeft::rotate = RotateRight::rotate = "Cannot rotate atomic expression `1`."
RotateLeft::rspec = RotateRight::rspec = "Rotation specification `1` should be a machine-sized integer or list of machine-sized integers."
RowReduce::rmeth = NullSpace::rmeth = Inverse::rmeth = "Value of option Method -> `1` should be \"CofactorExpansion\", \"OneStepRowReduction\", \"DivisionFreeRowReduction\", or Automatic."
Rule::rhs = RuleDelayed::rhs = "Pattern `1` appears on the right-hand side of rule `2`."
Run::shell = "Cannot execute shell."
Internal`SchurDecomposition::schurf = SchurDecomposition::schurf = HessenbergDecomposition::schurf = "`1` has received a matrix with infinite precision."
Internal`SchurDecomposition::schurn = SchurDecomposition::schurn = HessenbergDecomposition::schurn = "`1` has received a matrix with non-numeric elements."
General::ngen = "The generalized `1` is not implemented."
SeedRandom::eminit = "The initialization of random generator Method -> `1` failed. The current random generator will remain as before."
SeedRandom::bitw = "The \"BitWidth\" property for the random generator `1` evaluated to `2`. It should be a positive integer."
SeedRandom::gprop = "At least one of the properties \"GeneratesBitsQ\", \"GeneratesIntegersQ\", or \"GeneratesRealsQ\" needs to be True for the generator `1` to be used."
SeedRandom::initf = "Initialization of the `1` random number generator failed."
SeedRandom::initsf = "Random number generator initialization from the generator state `1` failed. The data has been corrupted."
SeedRandom::initmf = "Random number generator initialization from the specification Method -> `1` failed."
SeedRandom::nogen = "`1` is not one of the built-in random number generators `2`. A defined generator must be represented by a symbol."
SeedRandom::sfail = "Seeding of the `1` generator failed."
SeedRandom::seed = "Argument `1` in `2` should be an integer or a string."
NumericalMath`NSequenceLimit::bdmtd = "`1` is not a valid specification of a sequence limit extrapolation algorithm."
NumericalMath`NSequenceLimit::seqlim = "The general form of the sequence could not be determined, and the result may be incorrect."
NumericalMath`NSequenceLimit::seqw = "Sequence of length `1` is too short for use with Degree -> `2`."
NumericalMath`NSequenceLimit::wynn = "Value of Degree -> `1` should be a positive machine-sized integer or Infinity."
Series::esss = "Essential singularity encountered in `1`."
Series::icm = "Series in `1` to be combined have unequal expansion points `2` and `3`."
Series::lss = "Logarithmic singularity encountered in `1`."
Series::nmer = "`1` is not a meromorphic function of `2` at `3`."
Series::sbyc = "Division by a series with no coefficients in `1`."
Series::serlim = "Series order specification `1` is not a machine-sized integer."
PadeApproximant::sspec = Series::sspec = AsymptoticSolve::sspec = "Series specification `1` is not a list with three elements."
Series::vcnt = "Center point `2` of power series expansion involves the variable `1`."
SeriesData::csa = "Argument `1` in `2` is not a power series."
SeriesData::scmn = "Order of series `1` is negative."
SeriesData::scmp = "The constant term of series `1` does not match the expansion point of `2`."
SeriesData::sdatc = "Coefficient specification `1` in `2` is not a list."
SeriesData::sdatd = "Power denominator specification `1` in `2` is not a positive machine-sized integer."
SeriesData::sdatn = "Order specification `1` in `2` is not a machine-sized integer."
SeriesData::sdatv = "First argument `1` is not a valid variable."
SeriesData::slnc = "Argument `1` in Log is a series with no coefficients."
SeriesData::ssdn = "Attempt to evaluate a series at the number `1`. Returning Indeterminate."
Set::patset = "Warning: `1` in assignment `2` represents a named pattern; use symbol::tag to represent a message name."
Set::inset = "Assignments cannot be performed during inspection."
Set::lhsr = SetDelayed::lhsr = Unset::lhsr = TagSet::lhsr = TagSetDelayed::lhsr = TagUnset::lhsr = UpSet::lhsr = UpSetDelayed::lhsr = "Replacing rule `1` with rule `2` since their left-hand sides and conditions are equivalent."
Set::setraw = SetDelayed::setraw = UpSet::setraw = UpSetDelayed::setraw = TagSet::setraw = TagSetDelayed::setraw = "Cannot assign to raw object `1`."
Set::setrpt = SetDelayed::setrpt = UpSet::setrpt = UpSetDelayed::setrpt = TagSet::setrpt = TagSetDelayed::setrpt = "Cannot assign to raw object `1` in pattern `2`."
Set::shape = SetDelayed::shape = "Lists `1` and `2` are not the same shape."
Set::setpvs = Unset::setpvs = "`1` in the property value assignment is not a symbol."
Set::novalpv = Unset::novalpv = "Symbol `1` in property value assignment does not have an immediate value."
PropertyValue::pvobj = PropertyList::pvobj = SetProperty::pvobj = RemoveProperty::pvobj = "`1` is not an object with properties."
Set::pvobjs = Unset::pvobjs = "Property values cannot be assigned for `1` objects."
Set::pvw = Unset::pvw = "The property value `1` could not be set."
SetAccuracy::accbd = "Requested accuracy `1` is not a real number within the allowable range."
SetAccuracy::acclg = "Requested accuracy `1` would result in a precision greater than $MaxPrecision; bounding by $MaxPrecision instead."
SetAccuracy::accsm = "Requested accuracy `1` would result in a precision smaller than $MinPrecision; bounding by $MinPrecision instead."
SetFileDate::fdate = "Date specification should be either the number of seconds since January 1, 1900 or a {y, m, d, h, m, s} list."
SetFileDate::toobig = "Requested date is too far in the future."
SetFileDate::datetype = "Date type `1` should be \"Access\", \"Modification\", \"Creation\" (Windows only), or All."
SetFileDate::nocreationunix = "The Creation date of a file cannot be set on Macintosh or Unix."
SetOptions::strmopt = "The `1` option of stream `2` cannot be changed to `3`."
SetOptions::nspt = "SetOptions of `1` is not supported."
SetOptions::optf = "`1` has incorrectly formed option(s) `2`."
SetOptions::optnf = Options::optnf = AbsoluteOptions::optnf = "`1` is not a known option for `2`."
SetOptions::sstm = "Argument `1` is not a symbol or a stream."
SetOptions::sonvc = "Argument `1` is not a valid Association object."
SetStreamPosition::sbuf = "Requested position `1` in stream `2` is outside the file buffer; cannot reach outside the file buffer for nondisk files."
SetStreamPosition::stmrng = "Cannot set the current point in stream `2` to position `1`. The requested position exceeds the number of characters in the file."
SystemOptions::noset = "The value of SystemOption `1` cannot be modified."
SetSystemOptions::setpriority = "The process priority cannot be set to `1` because the kernel process does not have permission to do so."
Short::short = "Second argument `1` should be a positive real number."
Show::gcc = "Graphics of type `1` cannot be combined with other types of graphics."
Show::gcomb = "Could not combine the graphics objects in `1`."
Show::gmed = "No graphics output medium specified."
Show::shx = "No graphical objects to show."
Simplify::cfn = FullSimplify::cfn = "The cost function `1` does not evaluate to a real number at `2`."
Simplify::infd = FullSimplify::infd = "Expression `1` simplified to `2`."
Simplify::time = FullSimplify::time = "Time spent on a transformation exceeded `1` seconds, and the transformation was aborted. Increasing the value of TimeConstraint option may improve the result of simplification."
Simplify::gtime = FullSimplify::gtime = "Returning the simplest form found in the allowed time of `1` seconds. Increasing the value of the TimeConstraint option may improve the result of simplification."
MultiplySides::gcond = DivideSides::gcond = "Value of GenerateConditions -> `1` should be All, True, False, Automatic, or None."
AddSides::eqin = SubtractSides::eqin = MultiplySides::eqin = DivideSides::eqin = ApplySides::eqin = "`1` should be an equation or an inequality."
AddSides::eqlen = "Equations or inequalities `1` and `2` have different lengths and cannot be added."
SubtractSides::eqlen = "Equations or inequalities `1` and `2` have different lengths and cannot be subtracted."
MultiplySides::eqlen = "Equations or inequalities `1` and `2` have different lengths and cannot be multiplied."
DivideSides::eqlen = "Equations or inequalities `1` and `2` have different lengths and cannot be divided."
AddSides::arg2 = "Cannot add `1` to sides of an equation or an inequality."
SubtractSides::arg2 = "Cannot subtract `1` from sides of an equation or an inequality."
MultiplySides::arg2 = "Cannot multiply sides of an equation or an inequality by `1`."
DivideSides::arg2 = "Cannot divide sides of an equation or an inequality by `1`."
AddSides::iarg2 = "Cannot add `1` to sides of an inequality."
SubtractSides::iarg2 = "Cannot subtract `1` from sides of an inequality."
MultiplySides::iarg2 = "Cannot multiply sides of an inequality by `1`."
DivideSides::iarg2 = "Cannot divide sides of an inequality by `1`."
MultiplySides::complex = "Cannot multiply an equation involving complex quantities by an inequality."
AddSides::uneq = "Cannot add sides of two inequations."
SubtractSides::uneq = "Cannot subtract sides of two inequations."
MultiplySides::uneq = "Cannot multiply sides of two inequations."
DivideSides::uneq = "Cannot divide sides of an inequation or an inequality and an inequation."
AddSides::iuneq = "Cannot add sides of an inequation and an inequality."
SubtractSides::iuneq = "Cannot subtract sides of an inequation and an inequality."
MultiplySides::iuneq = "Cannot multiply sides of an inequation and an inequality."
DivideSides::iuneq = "Cannot divide sides of an inequation and an inequality."
MultiplySides::sgn = "Cannot multiply inequalities unless all terms have equal nonzero signs."
DivideSides::sgn = "Cannot divide inequalities unless all terms have equal nonzero signs."
MultiplySides::ineq = "Cannot multiply inequalities unless all terms have equal nonzero signs."
DivideSides::ineq = "Cannot divide by an inequality unless all terms have equal nonzero signs."
DivideSides::eqn = "Cannot divide by an equation or an inequation unless all terms are nonzero."
SingularValues::svdcmp = SingularValueList::svdcmp = SingularValueDecomposition::svdcmp = "Cannot compare singular values against the given tolerance `1`."
SingularValues::svdnsv = SingularValueList::svdnsv = SingularValueDecomposition::svdnsv = "Cannot compute all the singular values."
SingularValues::svdnsvc = SingularValueDecomposition::svdnsvc = "Cannot compute all the singular vectors."
SingularValueList::gsvdta = SingularValueDecomposition::gsvdta = "Cannot take the second argument. Only one argument is permitted for generalized `1`."
SingularValueList::gmatrix = SingularValueDecomposition::gmatrix = "Argument `1` at position `2` is not a pair of non-empty rectangular matrices."
BoxForm`SetSizeCountRule::notsym = "The left side of the rule `1` is not a symbol."
BoxForm`SetSizeCountRule::valbad = "The value specified on the right side of the rule `1` is not Automatic, None, \"StartCounting\", \"StopCounting\", a machine integer, or a list of machine integers."
Solve::circ = MainSolve::circ = Roots::circ = Reduce::circ = System`Private`OldReduce::circ = Eliminate::circ = SolveAlways::circ = AlgebraicRules::circ = "Removing solution `1` from list of solutions. It results from an underdetermined system of equations involving transcendental functions."
Solve::dinv = MainSolve::dinv = Eliminate::dinv = Roots::dinv = AlgebraicRules::dinv = Reduce::dinv = System`Private`OldReduce::dinv = SolveAlways::dinv = GroebnerBasis::dinv = PolynomialReduce::dinv = "The expression `1` involves unknowns in more than one argument, so inverse functions cannot be used."
Solve::incnst = "Inconsistent or redundant transcendental equation. After reduction, the bad equation is `1` == 0."
Solve::smod = "Unable to solve equations for modulus."
Solve::solex = MainSolve::solex = Roots::solex = Reduce::solex = System`Private`OldReduce::solex = Eliminate::solex = SolveAlways::solex = AlgebraicRules::solex = GroebnerBasis::solex = PolynomialReduce::solex = "`1` cannot handle one of the exponents."
Solve::svars = NSolve::svars = "Equations may not give solutions for all \"solve\" variables."
Solve::tdep = MainSolve::tdep = Roots::tdep = Reduce::tdep = System`Private`OldReduce::tdep = Eliminate::tdep = SolveAlways::tdep = AlgebraicRules::tdep = GroebnerBasis::tdep = PolynomialReduce::tdep = "The equations appear to involve the variables to be solved for in an essentially non-algebraic way."
Solve::ifun = NSolve::ifun = Eliminate::ifun = SolveAlways::ifun = "Inverse functions are being used by `1`, so some solutions may not be found; use Reduce for complete solution information."
Reduce::ifun = System`Private`OldReduce::ifun = MainSolve::ifun = AlgebraicRules::ifun = "Inverse functions are being used by `1`, so some solutions may not be found."
Solve::ifun2 = Eliminate::ifun2 = Reduce::ifun2 = System`Private`OldReduce::ifun2 = MainSolve::ifun2 = AlgebraicRules::ifun2 = SolveAlways::ifun2 = "Cannot obtain a solution with the InverseFunctions -> False option setting."
Sound::sdur = "Sound duration: `1` seconds."
Sound::sdur1 = "Sound duration: `1` second."
Sound::srate = "Sample rate: `1` samples/second."
Sound::ssnf = "`1` out of `2` sample points did not evaluate to real numbers."
Sound::ssnm = "A good PlayRange could not be found since most of the samples are not evaluating to machine-sized real numbers."
Sow::encl = "Expression `1` has no enclosing Reap."
Sow::enclt = "Tag `1` in `2` has no matching Reap."
SortBy::sbnval = "The function `1` does not produce values that can be used for sorting."
Developer`SparseLinearSolve::deprec = "Developer`SparseLinearSolve is deprecated. Use LinearSolve with SparseArray matrices instead."
SparseArray`PositiveDefiniteQ::spam = Developer`SparseLinearSolve::spam = "The sparse matrix `1` is not specified in the form {{i1, j1} -> a1, {i2, j2} -> a2, ...} with machine-sized integer position indices ik and jk and machine-sized real or complex values ak."
Developer`SparseLinearSolve::fovflw = "Machine overflow encountered factoring the sparse matrix."
Developer`SparseLinearSolve::sovflw = "Machine overflow encountered solving the sparse system."
Splice::splicd = "Missing right delimiter `1` at end of input file `2`."
Splice::splicf = "Cannot deduce output filename from `1`."
Splice::splict = "Cannot deduce output type from `1`."
Splice::splicx = "Invalid input `1`."
Stack::stackx = "Expression number `1` does not exist in `2`; there are `3` expressions of the requested form."
Developer`StringFromStream::nostream = "`1` is not an output stream opened with StreamToString."
StringCases::meta = StringFreeQ::meta = StringSplit::meta = StringReplaceList::meta = StringPosition::meta = StringReplace::meta = "Value of option MetaCharacters -> `1` is not None, Automatic, a string of length 3, or a list of three strings."
StringDrop::drop = "Cannot drop positions `1` through `2` in \"`3`\"."
StringExpression::cond = "Warning: restrictions on pattern variable `1` in `2` are ignored as they are not associated with the first occurrence of `1`."
StringExpression::invld = "Element `1` is not a valid string or pattern element in `2`."
StringExpression::repbd = "Repeated argument out of range (> 65535) for a string pattern in `1`."
StringExpression::anyorder = "AnyOrder would be too computationally complex in `1`."
StringForm::sfq = "Unmatched backquote in `1`."
StringForm::sfr = "Item `1` requested in \"`3`\" out of range; `2` items available."
StringInsert::ins = StringReplacePart::ins = "Cannot insert at position `2` in `1`."
StringMatchQ::nospell = " Warning: the SpellingCorrection option is ignored for patterns that are not a plain string."
StringReplace::srep = "`1` is not a valid string replacement rule."
StringReplacePart::ovlp = "Position `1` overlaps previous positions; new string `2` will not be inserted."
StringReplacePart::plen = Array::plen = "`1` and `2` should have the same length."
StringReplacePart::repart = "Cannot replace positions `1` through `2` in \"`3`\"."
StringReplacePart::spos = "Position specification {m, n} is expected at position `1` in `2`."
StringSplit::slen = "Positive integer, All, or Automatic expected at position `1` in `2`."
StringTake::take = "Cannot take positions `1` through `2` in \"`3`\"."
StringTake::ambgsntx = "Warning: interpreting list of integers as a list of sequence specifications."
StringTake::mseqs = "Sequence specification (+n, -n, {+n}, {-n}, {m, n}, or {m, n, s}) or a list of sequence specifications expected at position `2` in `1`."
Subdivide::sdmint = "The number of subdivisions given in position `2` of `1` should be a positive machine-sized integer."
Subresultants::slpr = "The algorithm failed due to a too low precision of input."
Subresultants::npolys = "`1` and `2` should be polynomials."
SubresultantPolynomials::npolys = SubresultantPolynomialRemainders::npolys = "`1` and `2` should be polynomials with exact coefficients and the degree of `1` in `3` should not be less than the degree of `2` in `3`."
Internal`SubresultantExtendedGCD::npolys = "`1` and `2` should be polynomials with exact coefficients."
Subresultants::mpolys = Internal`SubresultantExtendedGCD::mpolys = "`1` and `2` should be polynomials with rational number coefficients valid modulo `4`."
SubresultantPolynomials::mpolys = SubresultantPolynomialRemainders::mpolys = "`1` and `2` should be polynomials with rational number coefficients valid modulo `4` and the degree of `1` in `3` should not be less than the degree of `2` in `3`."
Subscripted::subn = "Subscripting specification `1` is not of the form n or {n1, n2}."
Subscripted::subv = "Specifications for superscripts and subscripts overlap."
Subscripted::subx = "Positions specified by `1` are not available in expression of length `2`."
Subsets::toomany = "The number of subsets (`2`) indicated by `1` is too large; it must be a machine integer."
Sum::div = "Sum does not converge."
Sum::gener = "Unable to check convergence."
Sum::sumwarn = "Warning: `1` contains a capital sigma; use \[EscapeKey]sum\[EscapeKey] to enter a summation sign."
Surd::noneg="Surd is not defined for even roots of negative values."
SurfaceColor::albedo = "Albedo specification `1` in first argument of `2` is not a valid GrayLevel or RGBColor directive."
SurfaceColor::shine = "Shininess specification `1` in third argument of `2` is not a positive real number."
SurfaceColor::specl = "Specularity specification `1` in second argument of `2` is not a valid GrayLevel or RGBColor directive."
MatrixPlot::clip = ArrayPlot::clip = SurfaceGraphics::clip = "Value of option ClipFill -> `1` is not None, Automatic, a color, or a list of two such values."
SurfaceGraphics::noproj = Graphics3D::noproj = "Unable to make a projection matrix; check the settings of ViewPoint, ViewCenter, and ViewVertical."
SurfaceGraphics::pmsr = DensityGraphics::pmsr = ContourGraphics::pmsr = "PlotRange `1` is so much smaller than MeshRange `2` that there is nothing left to plot."
SurfaceGraphics::shade = "Shading array `1` is not the same shape as the z-value array."
Switch::argct = "Switch called with `2` arguments. Switch must be called with an odd number of arguments."
Symbol::symname = "The string \"`1`\" cannot be used for a symbol name. A symbol name must start with a letter followed by letters and numbers."
SymmetricPolynomial::toobig = "Cannot create a polynomial with `1` terms."
SymmetricPolynomial::nmint = "`1` is not a non-negative machine integer."
SymmetricPolynomial::hideg = "The degree `1` of an elementary symmetric polynomial cannot be higher than the number of variables `2`."
SymmetricPolynomial::nvarl = SymmetricReduction::nvarl = "`1` is not a list of variables."
SymmetricReduction::neql = "Lists `1` and `2` have different lengths."
General::noinfo = "Input expression `1` contains insufficient information to interpret the result."
Syntax::snthex32 = "6 hexadecimal digits are required after \\| to construct a 32-bit character."
Syntax::sntrng = "Codepoint `1` is out of range.  32-bit characters must be between 0x000000 and 0x10FFFF."
Syntax::noinfoker = "This input can only be interpreted in the same kernel session that generated it."
Syntax::snthex = "4 hexadecimal digits are required after \\: to construct a 16-bit character."
Syntax::sntoct1 = "3 octal digits are required after \\ to construct an 8-bit character."
Syntax::sntoct2 = "2 hexadecimal digits are required after \\. to construct an 8-bit character."
Syntax::sntufn = "Unknown unicode longname `1`."
Syntax::sntunc = "Unicode longname `1` in the string is unterminated."
Syntax::sntmsng = "In `1`, '\\[' should be followed by a unicode longname followed by a ']'."
Syntax::stresc = "Unknown string escape \\`1`."
Syntax::syntyp = "\\ operators can only be used between \( \)."
Syntax::com = "Warning: comma encountered with no adjacent expression. The expression will be treated as Null. `1`."
General::nprmtv = "`1` is not currently supported within preemptive evaluations."
SystemDialogInput::unsupt = "The `1` dialog type is not currently supported on this platform."
SystemDialogInput::invt = "First argument `1` is not a valid dialog type."
TableForm::tfal = "Value of option TableAlignments -> `1` should be a list of alignment specifications (Top, Bottom, and Center for row dimensions, or Left, Right, and Center for column dimensions)."
TableForm::tfdir = "Value of option TableDirections -> `1` should be Row, Column, or a non-empty list of these values."
TableForm::tfh = "TableHeadings option contained `1`, which is not Automatic, None, or a list of labels."
TableForm::tfsp = "Value of TableSpacing -> `1` should be Automatic, a machine-sized number, or a list of machine-sized numbers."
TableForm::wtfsp = "Warning: TableSpacing value of `1` must be non-negative. Formatting will proceed with a value of 0."
TableView::badid = "The front end returned a box reference in an unrecognized format."
TableView::inside = "That operation requires that your selection be within this TableView."
TableView::onlyone = "That operation requires that one item is selected within this TableView."
TableView::nodel = "You cannot delete the only row or column in this TableView."
TagSet::tagnf = TagSetDelayed::tagnf = TagUnset::tagnf = "Tag `1` not found in `2`."
TagSet::tagpos = TagSetDelayed::tagpos = TagUnset::tagpos = "Tag `1` in `2` is too deep for an assigned rule to be found."
TeXForm::unspt = "TeXForm of `1` is not supported."
Convert`TeX`BoxesToTeX::notboxes = "`1` is not a valid box structure. The first argument in `2` must be a valid box structure."
Text::textn = "Text offset `1` is not a pair of numbers."
Text::textz = "Vector for text rotation cannot have value {0, 0}."
Thickness::thkn = AbsoluteThickness::thkn = "The argument in `1` is not a number."
Accumulate::tdlen = "Objects of unequal length in `1` cannot be added."
Thread::tdlen = "Objects of unequal length in `1` cannot be combined."
Thread::tpos = "Cannot thread over positions `1` through `2` in `3`."
Throw::nocatch = "Uncaught `1` returned to top level."
Throw::sysexc = "Uncaught SystemException returned to top level. Can be caught with Catch[\[Ellipsis], _SystemException]."
General::ticks = "`1` is not a valid tick specification."
General::timc = "Number of seconds `1` is not a positive machine-sized number or Infinity."
CreateScheduledTask::timspc = RunScheduledTask::timspc = ResetScheduledTask::timspc = "Incorrect timing specification `1`."
CreateScheduledTask::timt = RunScheduledTask::timt = ResetScheduledTask::timt = "Number of seconds `1` is not a positive number."
CreateScheduledTask::timtc = RunScheduledTask::timtc = ResetScheduledTask::timtc = "Count `1` is not a positive machine-sized integer or infinity."
CreateScheduledTask::tmspc = RunScheduledTask::tmspc = ResetScheduledTask::tmspc = "Time specification `1` should have the form time, {time}, or {time, count}."
ServiceConnect::apikey = "Could not obtain credentials for the service `1`"
ServiceConnect::dialog = "The value `1` is not valid for AuthenticationDialog"
ServiceConnect::done = "The service `1` has already been authenticated"
ServiceConnect::genconerr = "Could not connect to the service `1`"
ServiceConnect::invs = "`1` should be a valid Service name or ServiceObject, try using $Services"
ServiceConnect::key1 = "The `1` service does not save user connections, a standard connection will be created."
ServiceConnect::key2 = "The `1` service does not create new user connections, a standard connection will be created."
ServiceConnect::multser = "One service was chosen from multiple `1` services."
ServiceConnect::multst = "There are multiple connections stored. Most recent connection was loaded."
ServiceConnect::nameid = "The given connection id `1` corresponds to a different service than the specified service, `2`."
ServiceConnect::ncloud = "The specified connection was not found locally. Use CloudConnect before ServiceConnect to check for cloud-stored connections."
ServiceConnect::nost = "The specified connection could not be found. Try to create a new connection."
ServiceConnect::nostc = "The given connection id is not stored in your cloud."
ServiceConnect::nsave = "The connection could not be saved."
ServiceConnect::oauthver = "The OAuth version should be 1.0 or 2.0"
ServiceConnect::offline = "The Wolfram Language is currently configured not to use the Internet. To allow Internet use, check the \"Allow the Wolfram Language to use the Internet\" box in the Help \[FilledRightTriangle] Internet Connectivity dialog."
ServiceConnect::reffun = "The value `1` is not valid for RefreshAccessTokenFunction";
ServiceConnect::reqform = "The value `1` is not valid for RequestFormat";
ServiceConnect::skey = "The key or secret `1` must be a valid string";
ServiceConnect::sopt = "Options are not available for listing available services";
ServiceConnect::token = "Could not obtain a request token for the OAuth service `1`";
ServiceConnect::unkn = "The service `1` is unknown, try providing authentication options."
ServiceConnect::url = "The given url `1` is not a valid string";
ServiceConnect::verif = "The service could not be authenticated."
ServiceDisconnect::nsc = "The value given, `1`, should be a connected ServiceObject."
ServiceObject::invs = "`1` is not a valid ServiceObject."
ServiceObject::invid = "`1` doesn't have a valid connection uuid"
ServiceObject::noauth = "The service is not authenticated. Try using ServiceConnect."
ServiceObject::noid = "Connection uuid is missing in `1`"
ServiceObject::noget = "The parameter `1` is not available for the service `2`."
ServiceSubmit::connect = "Connection refused by service `1`."
ServiceSubmit::invldsrvc = "`1` should be a valid service name or ServiceObject. Try using $Services."
ServiceSubmit::invldschdl = "Service could not be run at the provided `1` schedule. Allowed schedules are `2`."
ServiceSubmit::noschdl = "`1` does not support scheduled requests."
ServiceSubmit::nosbmt = "ServiceSubmit for `1` requests is not supported."
ServiceSubmit::nostrm = "`1` does not support continuous requests."
ServiceSubmit::conntimeout = "Connection to the service `1` could not be established within `2`."
ServiceSubmit::noreq = "`1` must be a valid ServiceRequest object."
ServiceExecute::addperm = "The requested operation requires additional permissions. Try again after authorizing the WolframConnector."
ServiceExecute::apierr = "The service returned the following error message: `1`."
ServiceExecute::invreq = "The request `1` should be one of `2`[\"Requests\"], `2`[\"RawRequests\"], or the url for the desired api."
ServiceExecute::invs = "`1` should be a valid Service name or ServiceObject, try using $Services"
ServiceExecute::multser = "One service was chosen from multiple `1` services."
ServiceExecute::nargs = "The number of arguments given does not match the number of slots in the url template."
ServiceExecute::ndata = "The returned data is missing the `1` value."
ServiceExecute::noget = "The parameter `1` is not available for the service `2`."
ServiceExecute::nolink = "The service `1` is not authenticated. Try using ServiceConnect."
ServiceExecute::nparam = "The parameter `1` is required"
ServiceExecute::nval = "Invalid value for parameter `1` in service `2`."
ServiceExecute::offline = "The Wolfram Language is currently configured not to use the Internet. To allow Internet use, check the \"Allow the Wolfram Language to use the Internet\" box in the Help \[FilledRightTriangle] Internet Connectivity dialog."
ServiceExecute::ratel = "The rate limit for this query has been exceded."
ServiceExecute::reauth = "The service returned the following error message: `1`. Try reauthenticating with ServiceConnect[service, \"New\"]."
ServiceExecute::reftok = "Failed to refresh the access token for service `1`."
ServiceExecute::serror = "Server error."
ServiceExecute::serrormsg = "Server error. Error message: `1`"
SendMessage::invs = "`1` should be a valid Service name or ServiceObject, try using $Services"
SendMessage::nolink = "The service `1` is not authenticated. Try using ServiceConnect."
SendMessage::multser = "One service was chosen from multiple `1` services."
SendMessage::offline = "The Wolfram Language is currently configured not to use the Internet. To allow Internet use, check the \"Allow the Wolfram Language to use the Internet\" box in the Help \[FilledRightTriangle] Internet Connectivity dialog."
ServiceRequest::nosrv = "Could not create request."
ServiceRequest::nokey = "Could not create request. `1` key is missing."
ServiceInformation::nolink = "The service `1` is not authenticated. Try using ServiceConnect."
ServiceConnections`ServiceConnections::wname = "The argument `1` should be the name of a service from $Services."
ServiceConnections`SaveConnection::invso = "The argument `1` should be an active ServiceObject."
ServiceConnections`SaveConnection::cloud = "You need to be authenticated in cloud to save a ServiceObject. Try using CloudConnect."
ServiceConnections`SaveConnection::nosave = "`1` is not a user authenticated service, so the connection does not need to be saved."
ServiceConnections`SaveConnection::nsave = "The connection could not be saved."
ServiceConnections`SavedConnections::nosave = "`1` is not a user authenticated service, so the connections are not saved."
ServiceConnections`SavedConnections::wname = "The argument `1` should be the name of a service from $Services."
ServiceConnections`LoadConnection::cloud = "You need to be authenticated in cloud to load stored connections. Try using CloudConnect."
ServiceConnections`LoadConnection::invid = "`1` is not a valid connection uuid"
ServiceConnections`LoadConnection::wname = "The argument `1` should be the name of a service from $Services."
ServiceConnections`LoadConnection::wstr = "Value of option \"StorageLocation\" -> `1` should be \"Cloud\", \"Local\", Automatic or All."
ServiceConnections`LoadConnection::multst = "There are multiple connections stored. Most recent connection was loaded."
ServiceConnections`LoadConnection::nosave = "`1` is not a user authenticated service, so a connection does not need to be loaded."
ServiceConnections`LoadConnection::noso = "`1` does not have previously stored connections."
ServiceConnections`LoadConnection::nost = "The specified connection could not be found. Try to create a new connection."
ServiceConnections`DeleteConnection::invso = "The argument `1` should be a valid Service name or an active ServiceObject."
ServiceConnections`DeleteConnection::nodel = "`1` is not an authenticated service, so the connection does not need to be deleted."
General::sslccrt = "Could not establish a connection to the `1` service due to an SSL certificate error. Please make sure that the client certificate provided by `2` is installed correctly."
General::tasknc = "Could not create the task."
General::timnf = "The task `1` cannot not be found."
General::tasknv = "`1` is not a valid task specification."
General::taskid = "A string or a TaskObject is expected instead of `1`."
General::thnd = "The specified value for HandlerFunctions `1` is not a valid association."
General::khnd = "The specified value for HandlerFunctionsKeys `1` is not a valid list of strings."
General::invhk = "`1` is not a recognized element of HandlerFuntionsKeys."
General::invhf = "`1` is not a recognized value for an element of HandlerFunctions."
General::sched = "`1` is not an association containing recognized scheduling time specification."
General::rept = "The schedule specification `1` must have True or False for `2` instead of `3`. The default `4` will be used."
General::repint = "The schedule specification `1` must have a numeric value for `2` instead of `3`."
General::repct = "The schedule specification `1` must have a machine integer value for `2` instead of `3`."
SendEvent::invrs = "The argument `1` is not of the form \"name\" -> value."
SendEvent::evnstr = "The event name `1` is not a string."
SendEvent::evnf = "The task `1` cannot not be found."
CreateScheduledTask::offspc = RunScheduledTask::offspc = ResetScheduledTask::offspc = "Time offset `1` is not a non-negative number."
TreeForm::tlev = "Warning: level specification `1` is not a non-negative integer or Infinity; ignored."
General::nolpky = "The original `1` expression was not found."
General::nobox = "Unable to locate the summary box representing `1` in the notebook."
ToColor::colpc = ColorOutput::colpc = "Result `1` obtained during color conversion by applying function `2` to color `3` is not a GrayLevel, RGBColor, Hue, or CMYKColor directive."
ToColor::colpw = ColorOutput::colpw = "Result `1` obtained during color conversion by applying function `2` to color `3` has the wrong number of arguments for that color."
ToColor::tocol = "First argument `1` in ToColor should be a valid color directive."
ToDate::tdn = "First argument `1` should be an integer or a real number."
ToExpression::esntx = "Could not parse `1` as input."
ToExpression::esntxb = "Expression cannot begin with \"`1`\"."
ToExpression::esntxf = "\"`1`\" cannot be followed by \"`2`\"."
ToExpression::esntxi = "Incomplete expression \"`1`\"."
ToExpression::notstrbox = "`1` is not a string or a box. ToExpression can only interpret strings or boxes as Wolfram Language input."
ToNumberField::nnfel = "`1` does not belong to the algebraic number field generated by `2`."
Total::tlauto = "The nested option for the Method option value Automatic can be \"ExtraPrecision\" -> n, where n is an integer >= 0, or \"ExtraPrecision\" -> Automatic, not `1`."
Total::tlep = "The value of the option \"ExtraPrecision\" -> `1` should be a positive number or Automatic."
Total::tlmth = "The value of the option Method -> `1` should be Automatic or \"CompensatedSummation\"."
Total::tllen = "Lists of unequal length in `1` cannot be added."
ToString::notype = "FormatType `1` is not suitable for string-based output. Use a string-based format such as OutputForm."
Trace::tracb = TraceScan::tracb = TracePrint::tracb = TraceDialog::tracb = "Value of option `1` -> `2` should be False, True, All, or a list of two of these symbols."
Trace::tracd = TraceScan::tracd = TracePrint::tracd = TraceDialog::tracd = "Value of option `1` -> `2` should be False, True, or All."
TraceLevel::notrc = "No Trace function is currently active."
Reduce`ExpLogRoots::rbds = "`1` should be a pair of real numbers or real infinities."
Reduce`AnalyticRoots::cbds = "`1` should be a pair {a+b I, c+d I} with rational numbers a < b and c < d."
Reduce`AnalyticRoots::holo = "Unable to prove that `1` is holomorphic in the rectangle `2`. The solution set returned may be incomplete."
Reduce`AnalyticRoots::incs = "Only `1` out of the total of `2` solutions of `3` in the rectangle `4` have been found."
Reduce`AnalyticRoots::nint = "Warning: the number of solutions of `1` in the rectangle `2` has been determined using numeric integration."
Reduce`AnalyticRoots::pmul = "Warning: the number of solutions of `1` in the rectangle `2` may be incorrect if there are solutions that have the same first 10 decimal digits as a pole of `1`."
Reduce`AnalyticRoots::nitc = "Numeric integration necessary to determine the number of solutions of `1` in the rectangle `2` did not finish in the allowed time of `3` seconds. The solution set returned may be incomplete. Time allowed for numeric integration can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"NIntegrateTimeConstraint\" -> tsec}]."
Reduce`AnalyticRoots::unsn = "Unable to determine the number of solutions of `1` in the rectangle `2`. The solution set returned may be incomplete."
Reduce`IntervalRoots::rbds = "`1` should be a pair of real numbers."
Reduce`IntervalRoots::dpar = "`1` should be a pair of positive machine-sized integers."
Reduce`IntervalRoots::incsr = "`1` found `2` of an undetermined and possibly infinite number of solutions. Returning `3` solutions. The number of solutions returned can be specified with SetSystemOptions[\"ReduceOptions\" -> {\"IntervalRootsOptions\" -> {\"MaxIncomplete\" -> n}}]."
Transpose::permspec = ConjugateTranspose::permspec = "Invalid permutation specification found at position `2` in `1`."
Transpose::diagnl = ConjugateTranspose::diagnl = "Level rearrangement `1` would require collapsing dimensions of unequal lengths."
Transpose::newdims = ConjugateTranspose::newdims = "Level rearrangement `1` does not specify destination for level `2`."
Transpose::nmtx = ConjugateTranspose::nmtx = "The first two levels of `1` cannot be transposed."
Transpose::nmtx2 = ConjugateTranspose::nmtx2 = "The specified levels of `1` cannot be transposed."
Transpose::perm = ConjugateTranspose::perm = "The length of permutation `1` does not equal the depth of `2`."
Transpose::perm1 = ConjugateTranspose::perm1 = "Entry `1` in permutation `2` is not a positive machine integer."
Transpose::perm2 = ConjugateTranspose::perm2 = "Entry `1` in `2` is out of bounds for a permutation of length `3`."
Transpose::tperm = ConjugateTranspose::tperm = "Permutation `1` is longer than the dimensions `2` of the expression."
Transpose::tperm2 = ConjugateTranspose::tperm2 = "Permutation implied by `1` is longer than the dimensions `2` of the expression."
TuringMachine::rsize="The specified rule number `1` is greater than the largest possible rule number (`2`)."
TuringMachine::rneg="The specified rule number `1` should be non-negative."
TuringMachine::elist="The cell value `1` at position `2` of rule specification `3` cannot have head List."
TuringMachine::sspec="Position 2 in rule specification `1` must be an integer > 1."
TuringMachine::kspec="Position 3 in rule specification `1` must be an integer > 1."
TuringMachine::rspec="Position 4 in rule specification `1` must be a non-negative integer, a non-empty list of non-negative integers, or a non-empty list of offsets. In the latter case, each offset must be a non-empty list of integers and all offsets must have the same length."
TuringMachine::roff="Each offset at positions {_, 2, 3} in rule specification `1` must be an integer or a non-empty list of integers. An integer offset n means the same as {n}. All offsets must have the same length (where the length of an integer offset is taken to be 1)."
TuringMachine::nspec="The rule specification `1` must be a list of rules of the form {si, ai} -> {sn, kn, off}, or of the form n, {n}, {n, s}, {n, s, k}, or {n, s, k, r} where n, s, and k are integers and r is an integer, list of integers, or list of offsets."
TuringMachine::init="The initial condition `1` must take the form {statespec, tapespec}."
TuringMachine::initstate="The initial state `1` must take the form s, {}, {s}, {s, x}, or {s, x, dx}."
TuringMachine::initoffset="The initial machine head position `1` must be an index into a `2`-dimensional array."
TuringMachine::inittape="The initial tape `1` must take the form aspec, {cspec, e} or {cspec, bspec}, where aspec, bspec, and cspec are rank `2` arrays whose elements at level `2` are not lists, and e is a non-list expression. Both aspec and bspec must contain at least one element at level `2`."
TuringMachine::tspec="The time specification `1` must be an integer >= 0."
TuringMachine::ninits="Warning: in the initial state `1` the state `2` is not an integer in the range 1 <= state <= `3` indicated by the rule `4`."
TuringMachine::ninitc="Warning: in the initial state `1` the cell values c are not integers in the range 0 <= c < `2` indicated by the rule `3`."
Uninstall::unlink = "External package `1` has not been installed."
General::smtst = "Application of the SameTest function yielded `1`, which evaluates to `2`. The SameTest function must evaluate to True or False at every pair of elements."
Unique::usym = "`1` is not a symbol or a valid symbol name."
Unitize::post = "The threshold `1` should be positive."
UnitVector::nokun = "There is no unit vector in direction `1` in `2` dimensions."
Unset::cxun = "Cannot unset contexts."
Unset::norep = TagUnset::norep = "Assignment on `2` for `1` not found."
Unset::usraw = TagUnset::usraw = "Cannot unset raw object `1`."
Unset::usrpt = TagUnset::usrpt = "Cannot unset raw object `1` in pattern `2`."
SystemInformation::noinfo = "No information available."
SystemInformation::nocomp = "`1` is not a component recognized by SystemInformation."
SystemInformation::noprop = "`2` is not a property returned by SystemInformation[\"`1`\"]."
VectorAngle::length = "The vectors `1` and `2` have different lengths."
VectorAngle::vec = RankedMax::vec = RankedMin::vec = "Input `1` is not a vector."
RankedMax::rvec = RankedMin::rvec = "Input `1` is not a vector of reals or integers."
TakeLargest::rank = TakeLargestBy::rank = TakeSmallest::rank = TakeSmallestBy::rank = RankedMax::rank = RankedMin::rank = "The rank `1` is not an integer between 1 and `2`."
TakeLargest::rvec2 = TakeLargestBy::rvec2 = TakeSmallest::rvec2 = TakeSmallestBy::rvec2 = "Input `1` is not a real-valued vector."
TakeSmallest::lenarg = TakeLargest::lenarg = TakeSmallestBy::lenarg = TakeLargestBy::lenarg = "`1` requires a length specification."
TakeSmallest::retspec = TakeLargest::retspec = TakeSmallestBy::retspec = TakeLargestBy::retspec = "`1` is not a valid output specification for `2`."
ViewCenter::viewc = "A projection cannot be constructed for a ViewCenter that coincides with a ViewPoint."
ViewPoint::viewp = "A projection cannot be constructed for a ViewPoint inside the bounding box."
ViewVertical::viewv = "The ViewVertical vector must have a nonzero component perpendicular to a line from the ViewPoint to the ViewCenter."
With::dup = Module::dup = Block::dup = Dialog::dup = DynamicModule::dup = "Duplicate local variable `1` found in local variable specification `2`."
With::dups = Module::dups = "Conflicting local variables `1` and `3` found in local variable specification `2`."
With::lvw = "Local variable specification `1` contains `2`, which is not an assignment to a symbol."
With::lvws = "Variable `1` in local variable specification `2` requires a value."
WolframAlpha::conopen = "Using WolframAlpha requires internet connectivity. Please check your network connection. You may need to configure your firewall program or set a proxy in the Internet Connectivity tab of the Preferences dialog."
WolframAlpha::format = "`1` is not a recognized WolframAlpha format."
WolframAlpha::noiffi = "You cannot insert an inline free-form input at the current selection."
WolframAlpha::nopst = "The `2` pod is not reporting any additional information for the `1` pod state."
WolframAlpha::notboth = "Only one of IncludePods and ExcludePods should be specified at a time. IncludePods -> `1` will be used and ExcludePods -> `2` will be disregarded."
WolframAlpha::timeout = "The call to `1` has exceeded `2` seconds. Increasing the value of the TimeConstraint option may improve the result."
WolframAlpha::httperr = "The request to URL `1` was not successful. The server returned the HTTP status code `2`."
General::kbserr = "Request to knowledgebase server `1` failed with error code `2`."
General::conopen = "Using `1` requires internet connectivity. Please check your network connection. You may need to configure your firewall program or set a proxy in the Internet Connectivity tab of the Preferences dialog."
WordData::unknstag = "`2` is not valid for `1`."
WordData::unknpos = "`1` is not a valid part of speech."
XMLElement::attlhs = "`1` in `2` is not a valid name for an attribute in an XMLElement. It must be either a string (for the localname) or a list of two strings (for the {namespace, localname} pair)."
XMLElement::attrhs = "`1` in `2` is not a valid value for an attribute in an XMLElement. The value of the attribute must be a string."
XMLElement::attrslst = "`1` in `2` is not a list of attributes. The second item in an XMLElement must be a list of attributes, even if it is an empty list."
XMLElement::attrule = "`1` in `2` is not a valid attribute. Attributes must be specified in the form \"name\" -> \"value\" or {\"namespace\",\"localname\"} -> \"value\"."
XMLElement::cnts = "`1` is not valid in the contents of an XMLElement. The contents of an XMLElement must consist of Strings and XMLElements."
XMLElement::cntsList = "`1` in `2` is not a list of contents. The third item in an XMLElement must be a list of contents, even if it is an empty list."
XMLElement::name = "`1` in `2` is not a valid name for an XMLElement. It must be either a string (for the localname) or a list of two strings (for the {namespace, localname} pair)."
XMLElement::unqatt = "The attribute name (`1`) in `2` is not unique; there is already an attribute with this name in the same XMLElement. Two attributes with the same name cannot exist inside the same element."
XMLObject::decunsv = "`1` in `2` is not a valid setting for the Version option in an XMLObject[\"Declaration\"]. The only setting that is supported is \"1.0\"."
XMLObject::decvfst = "`1` in `2` is not a Version option. The first option to XMLObject[\"Declaration\"] must be of the form \"Version\" -> _String."
XMLObject::decvreq = "`1` has no \"Version\" option; the \"Version\" option is required to be the first item in an XMLObject[\"Declaration\"]."
XMLObject::declfst = "The XMLObject[\"Declaration\"] is not in position 1 of `1`. If present, an XMLObject[\"Declaration\"] must be the first item in the prolog of an XMLObject[\"Document\"]."
XMLObject::docbarg = "The argument at position `1` in `2` is expected to be a `3`"
XMLObject::docep = "`1` in `2` is not allowed in the list at position 3 of an XMLObject[\"Document\"]. Only XMLObject[\"Comment\"] and XMLObject[\"ProcessingInstruction\"] are allowed."
XMLObject::docprlgi = "`1` in `2` is not allowed in the prolog of an XMLObject[\"Document\"]. Only XMLObject[\"Declaration\"], XMLObject[\"Doctype\"], XMLObject[\"Comment\"], and XMLObject[\"ProcessingInstruction\"] are allowed in the prolog."
XMLObject::dtrtstr = "`1` in `2` is not a string. The first item in an XMLObject[\"Doctype\"] must be a string that is the name of the root element."
XMLObject::slone = "`1` in `2` is not a valid setting for the \"Standalone\" option to XMLObject[\"Declaration\"]. The option can only be set to \"yes\" or \"no\" and is case sensitive."
XMLObject::unq = "There is more than one occurrence of `1` in `2`. `1` is required to be unique."
XMLObject::unsenc = "`1` in `2` is not a supported setting for the encoding. The only supported encodings are UTF-8 and US-ASCII."
XML`SymbolicXMLErrors::unknobj = "`1` is not a recognized symbolic XML object. The only valid XML objects are XMLElement and XMLObject."
XML`MathML`BoxesToSymbolicMathML::attlhs = "`1` in `2` is not a valid name for an attribute to attach to the root <math> tag. An attribute name must be either a string (for the localname) or a list of two strings (for the {namespace, localname} pair)."
XML`MathML`BoxesToSymbolicMathML::attrhs = "`1` in `2` is not a valid value for an attribute to attach to the root <math> tag. The value of the attribute must be a string."
XML`MathML`BoxesToSymbolicMathML::attrule = "`1` is not a valid XML attribute to attach to the root <math> tag. Attributes must be specified in the form \"name\" -> \"value\" or {\"namespace\",\"localname\"} -> \"value\"."
XML`MathML`BoxesToSymbolicMathML::badba = "Could not translate a box expression or an annotation to SymbolicMathML. The box expression or annotation has been ignored."
XML`MathML`BoxesToSymbolicMathML::incasmml = "Internal MathML processing failure. Attributes `2` wrapped around a leaf tag `1`."
XML`MathML`BoxesToSymbolicMathML::notboxes = XML`MathML`BoxesToMathML::notboxes = "`1` is not a valid box structure. The first argument in `2` must be a valid box structure."
XML`MathML`BoxesToSymbolicMathML::uncnvbxs = "The boxes `1` are not convertible to a symbolic XML expression."
XML`MathML`BoxesToSymbolicMathML::unrecf = "The format `1` is not a recognized annotation for MathML."
XML`MathML`SymbolicMathMLToBoxes::bmml = "The `1`, `2`, occurred without a surrounding XML tag. An attempt has been made to correct this defect."
XML`MathML`SymbolicMathMLToBoxes::incrt = "The SymbolicMathML structure being interpreted has the root tag \"`1`\" instead of the correct tag \"math\"."
XML`MathML`SymbolicMathMLToBoxes::invsmml = "The structure \"`1`\" attempting to be converted to boxes is not a valid SymbolicMathML structure."
XML`MathML`SymbolicMathMLToBoxes::malsmml = "The structure \"`1`\" attempting to be converted to boxes has a malformed XML structure."
XML`MathML`SymbolicMathMLToBoxes::nmmlr = "The structure \"`1`\" attempting to be converted to boxes has the root XML tag \"`2`\", which is not a recognized MathML tag."
XML`MathML`SymbolicMathMLToBoxes::unknstrc = "`1` is not a valid MathML structure."
XML`MathML`SymbolicMathMLToBoxes::unkntag = "`1` is not a valid MathML tag. The tag `1` is being treated as a symbol."
XML`MathML`SymbolicMathMLToBoxes::msngargs = "The structure \"`1`\" is not a valid SymbolicMathML structure. The tag \"`2`\" is missing required arguments."
XML`MathML`SymbolicMathMLToExpression::invsmml = "The structure \"`1`\" attempting to be converted to an expression is not a valid SymbolicMathML structure."
XML`MathML`SymbolicMathMLToExpression::malsmml = "The structure \"`1`\" attempting to be converted to an expression has a malformed XML structure."
XML`MathML`SymbolicMathMLToExpression::nmmlr = "The structure \"`1`\" attempting to be converted to an expression has the root XML tag \"`2`\", which is not a recognized MathML tag."
XML`NotebookML`NotebookToSymbolicNotebookML::badobj = "Malformed notebook fragment `1` encountered. The fragment is being converted to SymbolicExpressionML."
XML`NotebookML`NotebookToSymbolicNotebookML::filonb = "Filename, notebook expression, or NotebookObject expected at position 1 in `1`."
XML`NotebookML`NotebookToSymbolicNotebookML::nogrcnv = "A front end is not available. A front end is necessary to translate the `1` into the `2` graphics format."
XML`NotebookML`NotebookToSymbolicNotebookML::unrecbd = "There is no built-in conversion for BoxData objects to `1`."
XML`NotebookML`NotebookToSymbolicNotebookML::unrecgd = "There is no built-in conversion for GraphicsData encoded as `1` to `2`."
XML`NotebookML`SymbolicExpressionMLToExpression::nbmlns = "`1` is not in the NotebookML Namespace; it is in the null namespace. Assuming that it was intended to be in the NotebookML Namespace."
XML`NotebookML`SymbolicNotebookMLToNotebook::noboxes = "A NotebookML BoxData element did not contain interpretable information. It cannot be displayed correctly."
XML`NotebookML`SymbolicNotebookMLToNotebook::nogrphx = "A NotebookML GraphicsData element did not contain interpretable information. It cannot be displayed correctly."
XML`NotebookML`SymbolicNotebookMLToNotebook::nbmlns = "`1` is not in the NotebookML Namespace; it is in the null namespace. Assuming that it was intended to be in the NotebookML Namespace."
XML`NotebookML`SymbolicNotebookMLToNotebook::unknxml = "`1` is not a valid NotebookML expression."
XML`Parser`InitializeXMLParser::memfail = "XMLInit failed due to a problem allocating memory."
XML`Parser`InitializeXMLParser::nfprserr = "`1`."
XML`Parser`InitializeXMLParser::prserr = "`1`."
XML`Parser`ReleaseXMLParser::bparsr = "XMLParser object expected at position 1 in `1`."
XML`Parser`ReleaseXMLParser::ilgprsr = "XMLParser[`1`]."
XML`Parser`XMLGet::badop = "Option `1` cannot take a value of `2`. It can only take `3`."
XML`Parser`XMLGet::ilgprsr = "XMLParser[`1`]."
XML`Parser`XMLGet::memfail = "XMLGet failed due to a problem allocating memory."
XML`Parser`XMLGet::nfprserr = "`1`."
XML`Parser`XMLGet::prserr = "`1`."
XML`Parser`XMLGet::put = "Received WSTP message `1` when generating XML output."
XML`Parser`XMLGet::unknop = "`1` is not a recognized option."
XML`Parser`XMLGet::xmlprsop = "XMLParser object or option expected at position `1` in `2`."
XML`Parser`XMLGetString::ilgprsr = "XMLParser[`1`]."
XML`Parser`XMLGetString::memfail = "XMLGetString failed due to a problem allocating memory."
XML`Parser`XMLGetString::nfprserr = "`1`."
XML`Parser`XMLGetString::prserr = "`1`."
XML`Parser`XMLGetString::xmlprsop = "XMLParser object or option expected at position `1` in `2`."
XML`SVG`GraphicsToSymbolicSVG::bdmgr = "Malformed Graphics expression may be incorrectly translated to SVG."
XML`SVG`GraphicsToSymbolicSVG::bsvgf = "Unexpected form: `1`."
XML`SVG`GraphicsToSymbolicSVG::bsvgns = "Unexpected ToSVGNumberString: `1`."
XML`SVG`GraphicsToSymbolicSVG::gtype = "`1` is not a type of graphics."
XML`SVG`GraphicsToSymbolicSVG::ncvrt = "Conversion from Graphics to SVG is missing a conversion for `1`."
XML`SVG`SymbolicSVGToGraphics::unsup = "SVG import is not currently supported."
ZTransform::div = "The Z transform `1` does not converge."
VertexNormals::errmatrixnor = "`1` must be a 3-vector matrix of `2` by `3`."
VertexNormals::errlistnor = "`1` must be a list of 3-vectors of length `2`."
VertexColors::errmatrixcol = "`1` must be a color-valued matrix of `2` by `3`."
VertexColors::errlistcol = "`1` must be a list of colors of length `2`."
ListPlot3D::invcolor = ListDensityPlot::invcolor = ListContourPlot::invcolor = "Invalid color `1` found."
Contours::ilevels =  "`1` is not a valid contour specification."
Mesh::ilevels = "`1` is not a valid mesh specification."
Method::meth = "`1` is an invalid method option."
ContourPlot3D::incmem = "The current value of `1` bytes may not be optimal. Increase this limit using Method -> {\"MaxMemoryUse\" -> n} or reduce the number of PlotPoints or MaxRecursion."
ContourPlot3D::noalmem = "Not enough memory to construct an algebraic surface. Use Method -> {\"MaxMemoryUse\" -> n} to increase memory."
MeshShading::colshd = "Invalid style tensor found `1`. The rank must be equal to the number of mesh functions."
General::dpts = "`1` duplicated points will not be processed."
General::invpt = "Point `1` not in general position, will not be processed."
Method::maxmem = "Method option MaxMemory -> `1` must be a positive integer or Infinity. Using `2` bytes as the default."
Plot3D::invfuncs = ParametricPlot3D::invfuncs = "Malformed set of functions `1`."
Plot::invfpts = ParametricPlot::invfpts = "`1` does not evaluate to a valid function expression."
ContourPlot::invctr = ListContourPlot::invctr = "`1` must be a machine-real value."
General::invregion = "`1` must be a Boolean function."
Filling::invfillentry = "`1` is not a valid Filling specification."
Filling::invfilling = "`1` must be Axis, Top, Bottom, Automatic, a numerical entry, or a list of valid Filling entries."
Filling::invfillsel = "`1` must be an integer in the range of 1 and `2`."
DensityPlot::largf = "`1` cannot be a list of more than one function."
General::invefunc = "`1` must be a function f or an equality of the form f == g."
DataRange::invdrange = "`1` must be of the form {xmin, xmax}."
General::pwregion = "Using `1` for clipping. This may produce invalid results. Use Method -> {\"SymbolicPiecewiseSubdivision\" -> False}."
General::pwfailed = "Symbolic Piecewise subdivision failed to create a suitable plotting domain subdivision. Use a regular plotting procedure, Method -> {\"SymbolicPiecewiseSubdivision\" -> True} to force piecewise evaluation."
General::reflevel = "MaxRecursion must be a non-negative integer."
ClipFill::legacycf = "ClipFill is no longer a valid option. Use ClippingStyle -> `1` instead."
General::ppts = "Value of option PlotPoints -> `1` is not an integer >= 2."
ContourPlot3D::ppts = "Value of option PlotPoints -> `1` is not an integer >= 2 or a list of 3 integers {nx, ny, nz}."
ListContourPlot3D::ppts = ListSurfacePlot3D::ppts = "Value of option MaxPlotPoints -> `1` is not an integer >= 2 or a list of three integers {nx, ny, nz}."
SliceContourPlot3D::slice = SliceDensityPlot3D::slice = SliceVectorPlot3D::slice = "Slice specification `1` should be a named slice, equation, surface or volume region, or list of slices."
ListSliceContourPlot3D::slice = ListSliceDensityPlot3D::slice = ListSliceVectorPlot3D::slice = "Slice specification `1` should be a named slice, surface or volume region, or list of slices."
DensityPlot3D::invlvar = SliceContourPlot3D::invlvar = SliceDensityPlot3D::invlvar = SliceVectorPlot3D::invlvar = "A sequence of variables of the form {x, xmin, xmax} or vars \[Element] region is expected beyond position `1`."
DensityPlot::legacycolfunc = ParametricPlot3D::legacycolfunc = Plot3D::legacycolfunc = "Use ColorFunction to specify coloring."
SiegelTheta::invmat = "`1` must be a symmetric matrix with a positive definite imaginary part."
PadeApproximant::nser = "A simple series expansion for `1` could not be found."
PadeApproximant::sing = "The series expansion of `1` has an irrational singularity at `2`."
PadeApproximant::degnum = "The function `1` has a zero of order `2` at `3` that is greater than the requested degree of the numerator."
PadeApproximant::degden = "The function `1` has a pole of order `2` at `3` that is greater than the requested degree of the denominator."
ChineseRemainder::pilist = "The arguments to ChineseRemainder must be two lists of integers of identical length, with the second list containing only positive integers."
PowersRepresentations::ppnt = "The value `1` of argument `2` must be a positive integer."
NumberFieldClassNumber::unkn = "The class number of the number field generated by `1` is not yet available."
SquaresR::pint = PowersRepresentations::pint = "The value `1` for argument `2` must be a non-negative integer."
SquaresR::nint = PowersRepresentations::nint = "The value `1` for argument `2` must be an integer."
SquareFreeQ::invopt = "The value `1` for argument `2` must be a valid option."
ExponentialMovingAverage::incdim = "Dimensions of dataset `1` are not compatible with dimensions of the smoothing parameter `2`."
MovingAverage::arg2 = FinancialIndicator::arg2 = "The second argument `1` must be a positive integer less than or equal to the length `2` of the first argument, or a vector of length less than or equal to the length of the first argument."
MovingMedian::arg2 = "The second argument `1` must be a positive integer less than or equal to the length `2` of the first argument."
MovingMedian::rpsmth = "The value `1` for the option RepeatedSmoothing must be either True or False."
MovingMedian::arg1 = "The first argument `1` must be a vector or matrix of real values."
MovingMedian::even = "The span `1` of the moving median should be odd for repeated smoothing to converge."
LinearFilter::arg2 = "The second argument `1` must be a vector, matrix, or list of matrices having the same number of columns as the first argument."
BinCounts::bincls = "`1` is not a valid value for the option BinClosure. Valid values are Left, Right, or a list containing Left and Right."
BinLists::bincls = "`1` is not a valid value for the option BinClosure. Valid values are Left, Right, or a list containing Left and Right."
BinLists::dims = BinCounts::dims = "The dimension `1` of the first argument is not the same as the number of binning specifications `2`."
BinLists::bins = BinCounts::bins = "The bin specification `1` is not a list of 2 or 3 real values."
BinLists::step = BinCounts::step = "The bin step size `1` is expected to be positive."
BinLists::cvals = BinCounts::cvals = "The bin specification `1` is not a list containing real values, Infinity, and -Infinity."
BinLists::vectmat = BinCounts::vectmat = "The first argument is expected to be a vector or matrix."
BinLists::dpct = BinCounts::dpct = "The number of unique cutoffs is `1` fewer than the number of cutoffs specified in dimension `2`. Binning will be done using the unique cutoffs."
Standardize::vectmat="The first argument is expected to be a vector or matrix."
Standardize::loc="The location function `1` evaluated to a list."
Standardize::scl="The scale function `1` evaluated to a list or zero."
Standardize::loc2="The location function `1` evaluated to a list for one or more of the columns."
Standardize::scl2="The scale function `1` evaluated to a list or zero for one or more of the columns."
Cumulant::arg1 = FactorialMoment::arg1 = Moment::arg1 = CentralMoment::arg1 = "The first argument `1` is expected to be a vector, a matrix, or a distribution."
CentralMoment::vectarg2 = Moment::vectarg2 = FactorialMoment::vectarg2 = Cumulant::vectarg2 = "The second argument `1` must be a single number or variable when the first argument is a vector."
CentralMoment::matarg2 = Moment::matarg2 = FactorialMoment::matarg2 = Cumulant::matarg2 = "The second argument `1` must be a single number, a variable, or a list of numbers or variables of length equal to the number of columns in the first argument when the first argument is a matrix."
ExpectedValue::arg2 = "The second argument `1` must be a non-empty vector or matrix."
ExpectedValue::dims = "The number of columns `1` in the second argument is not consistent with the length `2` of the third argument."
ExpectedValue::arg3 = "The third argument `1` must be a non-numerical value or a vector of non-numeric values."
JordanDecomposition::jdimp = "Unable to find the Jordan decomposition of the matrix with the given precision. Try higher precision or SchurDecomposition instead."
ExpectedValue::sum = "In the case of discrete distributions, the Assumptions option of ExpectedValue is ignored. Please refer to Expectation instead."
MomentConvert::nomatch = "Expression should contain moments of equal dimensions."
MomentEvaluate::nomatch = "Moments and data should have consistent dimensions."
(* *)
General::intprm = "Parameter `1` at position `2` in `3` is expected to be an integer."
General::pintprm = "Parameter `1` at position `2` in `3` is expected to be a positive integer."
General::nnintprm = "Parameter `1` at position `2` in `3` is expected to be a non-negative integer."
General::realprm = "Parameter `1` at position `2` in `3` is expected to be real."
General::posprm = "Parameter `1` at position `2` in `3` is expected to be positive."
General::nnegprm = "Parameter `1` at position `2` in `3` is expected to be non-negative."
General::probprm = "Parameter `1` at position `2` in `3` is expected to be between 0 and 1 inclusive."
General::pprobprm = "Parameter `1` at position `2` in `3` is expected to be positive and less than or equal to 1."
General::nuprobprm = "Parameter `1` at position `2` in `3` is expected to be non-negative and less than 1."
General::sprobprm = "Parameter `1` at position `2` in `3` is expected to be positive and less than 1."
General::corprm = "Parameter `1` at position `2` in `3` is expected to be greater than -1 and less than 1."
General::grt = "Parameter `1` at position `2` in `3` is expected to be greater than `4`."
General::grteq = "Parameter `1` at position `2` in `3` is expected to be greater than or equal to `4`."
General::lss = "Parameter `1` at position `2` in `3` is expected to be less than `4`."
General::lsseq = "Parameter `1` at position `2` in `3` is expected to be less than or equal to `4`."
General::bprm = "The parameters of distribution `1` are not valid. Use DistributionParameterAssumptions to obtain the parameter assumptions."
CoxIngersollRossProcess::bprm = "The parameters of process `1` are not valid. Use ProcessParameterAssumptions to obtain the parameter assumptions."
General::nnbprm = "The valid numeric parameters of distribution `1` are expected. Use DistributionParameterAssumptions to obtain the parameter assumptions."
General::vrprm = "The value `1` at position `2` in `3` is expected to be a list of real numbers."
General::vrlnprm = "The value `1` at position `3` in `4` is expected to be a length `2` list of real numbers."
General::vrposln = "The value `1` at position `3` in `4` is expected to be a length `2` list of positive numbers."
General::vprobprm = "The value `1` at position `2` in `3` is expected to be a list of non-negative numbers summing to 1."
General::vprobprm2 = "The value `1` at position `2` in `3` is expected to be a list of numbers between 0 and 1 inclusive."
General::vsprobprm = "The value `1` at position `2` in `3` is expected to be a list of non-negative numbers summing to at most 1."
General::vssprobprm = "The value `1` at position `2` in `3` is expected to be a list of non-negative numbers summing to less than 1."
General::vrpos = "The value `1` at position `2` in `3` is expected to be a list of positive numbers."
General::vrnonneg = "The value `1` at position `2` in `3` is expected to be a list of non-negative numbers."
General::vrposint = "The value `1` at position `2` in `3` is expected to be a list of positive integers."
General::vnnintprm = "The value `1` at position `2` in `3` is expected to be a list of non-negative integers."
General::posdefprm = "The value `1` at position `2` in `3` is expected to be a symmetric positive definite matrix."
General::realmat = "The value `1` at position `2` in `3` is expected to be a real matrix."
General::eqln = "The values `1` and `2` at positions `3` and `4` in `5` are expected to have the same length."
General::eqln2 = "The length of `1` at position `3` should be `6` more than the length of `2` at position `4` in `5`."
General::boxbndprm = "The value `1` at position `2` in `3` is expected to be a list of pairs of real numbers."
(* *)
MatrixPropertyDistribution::invmdi = "`1` is not a valid matrix distribution."
MatrixPropertyDistribution::sclrvctr = "`1` should be a scalar or vector expression."
(* *)
UniformDistribution::minmax = "The syntax UniformDistribution[min, max] is deprecated. Use UniformDistribution[{min, max}] instead."
UniformDistribution::arg1 = "The first argument `1` is expected to be a length 2 list or a list of length 2 lists."
TriangularDistribution::arg1 = "The first argument `1` is expected to be a list of length 2."
TriangularDistribution::arg2 = "The second argument `1` is expected to be a number or symbol."
DiscreteUniformDistribution::arg1 = "The first argument `1` is expected to be a length 2 list or a list of length 2 lists."
MixtureDistribution::nnegw = "The first argument `1` is expected to be a list of non-negative numbers of the same length as `2`."
MixtureDistribution::incompdist = "Second argument `1` is expected to a list of valid distributions of equal dimensionality."
ProbabilityDistribution::nvpdf = "The PDF of the given distribution is not non-negative."
ProbabilityDistribution::ignjmps = "The distribution function of `1` has negative atomic weight. Proceeding by ignoring the discontinuities, which may result in non-normalized density function."
RandomVariate::mcmc = "Failed to build Markov chain for `1` with options `2`.";
RandomVariate::mcmcin = "Failed to find an initial state for the Markov chain with positive density. Try supplying one manually.";
RandomVariate::mcmcin1 = "The initial state `1` for the Markov chain should have positive density.";
RandomVariate::mcmcintg = "The initial state `1` for the Markov chain should be an integer for `2`.";
RandomVariate::mcmcintg1 = "The initial state `1` for the Markov chain should be a list of integers for `2`.";
RandomVariate::mcmcthn = "Failed to reach \"MinEffectiveSampleSizeRatio\" -> `1` with thinning length `2`. Try increasing the thinning length.";
RandomVariate::szthin = "The option \"MinEffectiveSampleSizeRatio\" -> `1` is overriden by the option \"Thinning\".";
RandomVariate::hatsf = "The sampling function for hat needs to be specified when the ratio of hat and the target density is given."

CensoredDistribution::invarg1 = "The first argument of `1` is expected to be a valid censoring specification for the distribution `2`."
TruncatedDistribution::invarg1 = "The first argument of `1` is expected to be a valid truncation specification for the distribution `2`."
(* *)
InverseCDF::zipfpr = "The input precision `1` is less than the expected number of digits `2` in the desired inverse CDF. The result may contain significant numerical error."
Quantile::zipfpr = "The input precision `1` is less than the expected number of digits `2` in the desired quantile. The result may contain significant numerical error."
InverseCDF::badacc = "Warning: the value `1` given for the AccuracyGoal is not a positive number or Automatic. Setting to WorkingPrecision -10."
Quantile::badacc = "Warning: the value `1` given for the AccuracyGoal is not a positive number or Automatic. Setting to WorkingPrecision -10."
InverseCDF::badits = "Warning: MaxIterations -> `1` is not set to a positive integer; setting to `2`."
Quantile::badits = "Warning: MaxIterations -> `1` is not set to a positive integer; setting to `2`."
InverseCDF::badprec = "Warning: the value `1` given for the PrecisionGoal is not a positive number or Automatic. Setting to WorkingPrecision -10."
Quantile::badprec = "Warning: the value `1` given for the PrecisionGoal is not a positive number or Automatic. Setting to WorkingPrecision -10."
InverseCDF::badwork = "Warning: the value `1` given for the WorkingPrecision is not a positive real number. Setting to MachinePrecision."
Quantile::badwork = "Warning: the value `1` given for the WorkingPrecision is not a positive real number. Setting to MachinePrecision."
InverseCDF::over = "Warning: numeric overflow occurred during this search. This may mean that the search is starting from an inappropriate point or that insufficient precision is being used for these calculations. The returned inverse CDF may not be correct."
Quantile::over = "Warning: numeric overflow occurred during this search. This may mean that the search is starting from an inappropriate point or that insufficient precision is being used for these calculations. The returned quantile may not be correct."
InverseCDF::qcv = "InverseCDF failed to converge to the requested accuracy or precision for the inverse CDF within `1` iterations."
Quantile::qcv = "Quantile failed to converge to the requested accuracy or precision for the quantile within `1` iterations."
InverseCDF::qdig = "`1` working digits is insufficient to achieve the requested accuracy or precision for the inverse CDF."
Quantile::qdig = "`1` working digits is insufficient to achieve the requested accuracy or precision for the quantile."
InverseCDF::qmp = "Machine precision is insufficient to achieve the requested accuracy or precision for the inverse CDF."
Quantile::qmp = "Machine precision is insufficient to achieve the requested accuracy or precision for the quantile."
General::empt = "Argument `1` should be a non-empty list."
(* Reliability-related messages *)
ReliabilityDistribution::nonunate = FailureDistribution::nonunate = "The Boolean expression `1` is not positive unate. Use UnateQ to test if a Boolean expression is unate.";
ReliabilityDistribution::negdom = FailureDistribution::negdom = StandbyDistribution::negdom = "The lower domain boundary `1` of `2` is negative.";
ReliabilityDistribution::dupldist = FailureDistribution::dupldist = "The variable `1` is specified more than once.";
ReliabilityDistribution::vundef = FailureDistribution::vundef = "The variable `1` has no associated distribution.";
ReliabilityDistribution::mixdist = FailureDistribution::mixdist = "Lifetime distributions must be all univariate continuous, or all univariate discrete.";
 (* "Mixtures of continuous and discrete lifetime distributions are not supported. Multivariate distributions are not supported."; *)
StandbyDistribution::noncont = "`1` is not a continuous univariate lifetime distribution.";
StructuralImportance::nonunate = "The expression `1` is not positive unate. This can be checked with UnateQ.";
StructuralImportance::bvar = "`1` is not a valid Boolean variable.";
(* *)
EmitSound::nofe = "A front end is not available; Sound playback requires a front end."
TrimmedMean::arg1 = TrimmedVariance::arg1 = WinsorizedMean::arg1 = WinsorizedVariance::arg1 = SnDispersion::arg1 = QnDispersion::arg1 = BiweightMidvariance::arg1 = HodgesLehmannEstimator::arg1 = BiweightLocation::arg1 = "The first argument `1` is expected to be a real numeric vector or matrix."
TrimmedMean::arg2 = TrimmedVariance::arg2 = WinsorizedMean::arg2 = WinsorizedVariance::arg2 = "The second argument `1` is expected to be a non-negative number less than 0.5 or a list of two non-negative numbers that sum to less than 1."
SpatialMedian::geodist = "The only allowed DistanceFunction specifications for GeoPosition are Automatic or GeoDistance."
FindClusters::bdmtd = "The value of option Method -> `1` is not Automatic, \"Optimize\", or \"Agglomerate\"."
FindClusters::bdst = "The value of Method option SignificanceTest -> `1` is not Automatic, \"Gap\", or \"Silhouette\"."
FindClusters::amtd = "FindClusters is unable to automatically select an appropriate dissimilarity function for the input data `1`."
FindClusters::bditr = "The value of option \"Iterations\" -> `1` should be a positive integer."
FindClusters::bdnul = "The value of option \"NullSets\" -> `1` should be a positive integer greater than 1."
FindClusters::bdtol = "The value of option \"Tolerance\" -> `1` should be a real number."
FindClusters::nclst = "The number of clusters requested (`1`) is larger than the number of elements to cluster (`2`)."
FindClusters::gap = "The data to be clustered must consist of vectors of real machine numbers to use the \"Gap\" method. Try Method -> \"Silhouette\" instead."
FindClusters::bdlink = "Value of Agglomerate method option \"Linkage\" -> `1` is not \"Single\", \"Complete\", \"Average\", \"Weighted\", \"Centroid\", \"Median\", or \"Ward\"."
ClusteringComponents::xnum = FindClusters::xnum = "A non-numeric, negative, or complex dissimilarity value was computed; dissimilarities must be non-negative and real-valued."
SoundNote::invnote = "\"`1`\" is not a valid pitch specification."
SoundNote::invinst = "\"`1`\" is not a valid style specification."
SoundNote::instnum = "Too many styles were specified. There must be at most 15 styles plus percussion."
General::dataseterr = "`1` is not a valid dataset or list of datasets."
General::updpkg = "The `1` functionality has been updated. See the compatibility page for compatibility information. Use <<Legacy`.``1` to load the legacy version."
General::markersize = "Invalid size `1`. A PlotMarker must be of the form {marker, size}."
Commonest::arg1 = "The first argument is expected to be a list."
Commonest::arg2 = "The second argument `1` is expected to be a non-negative integer."
Commonest::dstlms = "The requested number of elements `1` is greater than the number of distinct elements `2`. Only `2` elements will be returned."
MaximalBy::dstlms = MinimalBy::dstlms = "The requested number of elements `1` is greater than the number of elements `2`. Only `2` elements will be returned.";
MaximalBy::arg1 = MinimalBy::arg1 = "The first argument is expected to be a list or association.";
MaximalBy::arg3 = MinimalBy::arg3 = "The third argument `1` is expected to be a non-negative integer.";
General::obsfun = "The function `1` is now obsolete and has been superseded by `2`."
General::obspkg = "`1` is now obsolete. The legacy version being loaded may conflict with current functionality. See the Compatibility Guide for updating information."
General::obspkgfn = "A version of `1` from the obsolete package `2` is being used. This may conflict with current functionality. See the Compatibility Guide for updating information."
General::newpkg = "`1` is now available as the `2`. See the Compatibility Guide for updating information."
General::exclul = "`1` must be a list of equalities or real-valued functions."
General::excluc = "`1` must be an equation, a real-valued function, or a pair of the form {func, pred}."
General::invisol = "`1` must be a list of valid 2D coordinates."
General::invisop = "`1` must be a valid 2D coordinate."
General::mppts = "Value of option MaxPlotPoints -> `1` is not Infinity, an integer >= 2, or a list."
General::axes = "Value of option Axes -> `1` is not True, False, or a length-two list of True or False."
General::axorg = "Value of option AxesOrigin -> `1` is not Automatic or a valid 2D coordinate."
General::prng = "Value of option PlotRange -> `1` is not All, Full, Automatic, a positive machine number, or an appropriate list of range specifications."
General::cfun = "Value of option ColorFunction -> `1` is not a valid color function, or a gradient ColorData entity."
General::invmaxrec = "MaxRecursion must be a non-negative integer; the recursion value is limited to `2`. Using MaxRecursion -> `1`."
General::accbend = "Target bending angle of `1` not satisfied; current maximal bending angle is `2`."
General::invmeshf = "MeshFunctions->`1` must be a pure function or a list of pure functions."
General::invnormalf = "Value of NormalsFunction -> `1` must be a function that returns a vector representing the normal to a surface at a point."
General::plnr = "`1` is not a machine-sized real number at `2` = `3`."
General::pptr = "`1` does not evaluate to a pair of real numbers at `2` = `3`."
General::pp3tr = "`1` does not evaluate to a triplet of real numbers at `2` = `3`."
General::nfunfail = "`1` cannot be initialized properly. Symbolic Normals, WorkingPrecision, and EvaluationMonitor will not take effect."
General::cflegacy = "ClipFill has been superseded by ClippingStyle. Use ClippingStyle -> `1` instead."
General::boolf = "`1` must be a Boolean function."
General::pwtime = "Time spent on the piecewise transformation of `1` exceeded `2` seconds, and the transformation was aborted. Increasing the value of option Method -> {\"PiecewiseTimeConstraint\" -> `2`} may improve the result."
General::pwtimec = "In \"PiecewiseTimeConstraint\" -> `1`, `1` is not a nonzero positive machine-sized integer."
General::iodeg = "`1` is not a valid interpolation order specification, or the given order is too high for the input array `2`."
General::ioparam = "Invalid or incompatible interpolation properties are given."
General::iodata2 = "`1` is not a valid numerical array for curve interpolation."
General::iodata3 = "`1` is not a valid numerical matrix for surface interpolation."
General::ioproc = "`1` may contain non-machine-precision numbers, complex numbers, or invalid entries."
General::valuef = "`1` must be a numerical function."
General::gmat = "`1` is not a rectangular array larger than 2 x 2."
General::invctrs = "Contours -> `1` must be a non-negative integer or a list of real contour values."
General::coldir = "`1` contains an invalid color or gray-level directives."
General::nodata = "Unable to download data for `1`."
General::olddata = "Unable to update data for `1` to the latest version."
General::network = "`1` requires active Internet connectivity."
GrammarApply::timeout2 = General::timeout = "A network operation for `1` timed out. Please try again later."
Blend::arg = "`1` is not a valid list of colors or images, or pairs of a real number and a color or an image."
Blend::argch = "Blend of images with Automatic color space and a different number of channels is not supported."
Blend::argp = "`1` should be a real number."
Blend::argl = "`1` should be a real number or a list of non-negative numbers, which has the same length as `2`."
Blend::argm = ToColor::colconv = "`1` should be one of RGBColor, Hue, CMYKColor, or GrayLevel."
Lighter::arg = Darker::arg = "`1` should be a valid color directive, an image, or a list of them."
Lighter::argp = Darker::argp = "`1` is not a real number between 0 and 1."
Lighter::argm = Darker::argm = "`1` should be one of \"RGB\", \"HSL\", or \"HSL\" paired with a positive number."
General::notent = "`1` is not a known entity, class, or tag for `2`. Use `2`[] for a list of entities."
General::notdate = "`1` is not a valid date range for `2`."
General::notprop = "`1` is not a known property for `2`. Use `2`[\"Properties\"] for a list of properties."
General::notpropx = "`1` is not a known property for `2`. Use `3`[`2`, \"Properties\"] for a list of properties."
General::notsubprop = "`1` is not a known subproperty of `2`. Use subproperty \"Properties\" for a list of subproperties."
GraphData::notdef = "GraphData has no value associated with the specified argument(s)."
PolyhedronData::notdef = "PolyhedronData has no value associated with the specified argument(s)."
UniformPolyhedron::notdef = "`1` is not a known polyhedron entity or Schlafli symbol."
General::meshr = "Value of DataRange -> `1` is not of the form {{xmin, xmax}, {ymin, ymax}}."
General::meshr3 = "Value of DataRange -> `1` is not of the form {{xmin, xmax}, {ymin, ymax}, {zmin, zmax}}."
Plot3D::njnum = ParametricPlot3D::njnum = ContourPlot3D::njnum = RegionPlot3D::njnum = "The Jacobian is not a matrix of numbers at `2` = `1`."
Covariance::vctmat = "The arguments to Covariance are not a pair of vectors or a pair of matrices of equal length."
Correlation::vctmat = "The arguments to Correlation are not a pair of vectors or a pair of matrices of equal length."
AbsoluteCorrelation::vctmat = "The arguments to AbsoluteCorrelation are not a pair of vectors or a pair of matrices of equal length."
Covariance::arg1 = "The first argument must be either a vector, a matrix, or a multivariate distribution."
Correlation::arg1 = "The first argument must be either a vector, a matrix, or a multivariate distribution."
Correlation::zerosd = "The standard deviation for one or more vectors or matrix columns is zero."
ExampleData::notcoll = "`1` is not a known collection for ExampleData. Use ExampleData[] for a list of collections."
ExampleData::notent = "`1` is not a known entity for the collection `2`. Use ExampleData[`2`] for a list of entities."
NotebookCompatibility`ObsolescenceNote::nos = "Automatic translation rules are not available for this case."
NotebookCompatibility`ObsolescenceNote::nosc = "Automatic translation rules are not available for this case. See the Compatibility Guide for updating information. "
NotebookCompatibility`ObsolescenceNote::err = "The following input cell could not be processed, possibly due to syntax error(s)."
NotebookCompatibility`ObsolescenceNote::spr = "As of Version 6, `1` has been superseded by `2`. "
NotebookCompatibility`ObsolescenceNote::sprm = "As of Version 6, `1` has been superseded by `2` and `3`. "
NotebookCompatibility`ObsolescenceNote::nspr = "As of Version 7, `1` has been superseded by `2`. "
NotebookCompatibility`ObsolescenceNote::nsprm = "As of Version 7, `1` has been superseded by `2` and `3`. "
NotebookCompatibility`ObsolescenceNote::sprf = "As of Version 6, `1` and `2` have been superseded by `3`. "
NotebookCompatibility`ObsolescenceNote::smcln = "`1` is terminated by a semicolon. Graphics output will be suppressed if it is not removed."
NotebookCompatibility`ObsolescenceNote::gfxlp = "Graphics output inside of Do, For, and While loops is suppressed unless Print is used."
NotebookCompatibility`ObsolescenceNote::pldrn = "As of Version 6, the polyhedron functions previously available through the `1` package have been superseded by `2`. "
NotebookCompatibility`ObsolescenceNote::psc = "As of Version 6, the graphics primitive PostScript is no longer supported."
NotebookCompatibility`ObsolescenceNote::obs = "As of Version 6, `1` is no longer supported. "
NotebookCompatibility`ObsolescenceNote::shad = "As of Version 6, the argument to `1` specifying shading has been superseded by the options `2` and `3`. "
NotebookCompatibility`ObsolescenceNote::rect = "As of Version 6, the third argument to Rectangle has been superseded by Inset."
General::datainst = "Installing data from Wolfram Research data server ...."
General::datainstx = "Installing data from Wolfram Research data server (`1`%)."
General::dataupd = "Updating data from Wolfram Research data server ...."
General::dataupdx = "Updating data from Wolfram Research data server (`1`%)."
General::datainit = "Initializing `1` indices ...."
General::invnump = "`1` contains an invalid parameter reference."
General::ntri = "The data generates an inconsistent triangulation. You can perturb the data to make it valid."
General::dloff = "The Wolfram Language is currently configured not to use the internet and could not download data for `1`. To allow internet access, use Help > Internet Connectivity..."
General::dlfail = "Internet download of data for `1` failed. Use Help > Internet Connectivity... to test or reconfigure internet connectivity."
General::dlrefused = "Data update refused. See http://www.wolfram.com/datarefused for more information."
ByteArray::batd = "Elements in `1` are not unsigned byte values."
NumericArray::natd = "Elements in `1` are inconsistent with type `2`."
NumericArray::nata = "Elements in `1` are inconsistent with all supported types."
NumericArray::natype = RawArrayConvert::natype = "Type `1` is not one of the supported array types `2`."
NumericArray::lend = "The argument at position `1` in `2` should be a list of data."
ByteArray::lend = "The argument at position `1` in `2` should be a vector of unsigned byte values or a Base64-encoded string."
NumericArray::bdmtd = "`1` should be either \"Check\", \"Coerce\", \"Round\", \"ClipAndCheck\", \"ClipAndCoerce\", \"ClipAndRound\" or Automatic."
NumericArray::mtol = "The Tolerance option for the method \"Check\" is nonzero and will be ignored."
NumericArray::nconvaa = "Elements of `1` cannot be stored as a single type without loss of information. Specify a target type or try using one of the following conversion methods: \"Coerce\", \"Round\", \"ClipAndCoerce\" or \"ClipAndRound\"."
NumericArray::nconvsa = "The argument `1` cannot be automatically converted to a NumericArray of type `2`. Try using one of the following conversion methods: \"Round\", \"ClipAndCoerce\" or \"ClipAndRound\"."
NumericArray::nconvas = "The argument `1` cannot be converted to a NumericArray using the method `2`."
NumericArray::nconvss = "The argument `1` cannot be converted to a NumericArray of type `2` using the method `3`."
General::bnadis = "The function `1` does not currently support traversal of `2` objects. Consider using Normal to convert `2` objects to normal expressions before calling `1`."
General::naitype = "The data type `1` inherited from the NumericArray is not supported."
General::notinenc = "The character '`1`' (code point `2`) cannot be represented in character encoding `3`."
General::ntbytenc = "`1` is not a byte-level character encoding."
General::irtsnoimp = "`1` currently only supports regularly sampled time series inputs. Use `2` or `3` to make the input regularly sampled."
General::imgerr = "A critical error was encountered during the process of `1`."
General::imginv = "Expecting an image or graphics instead of `1`."
General::imgdtype = "The specified data type `1` should be either \"Bit\", \"Byte\", \"Bit16\", \"Real32\", or \"Real64\"."
General::imgrng = "The specified argument `1` should be a pair of real or integer numbers."
General::imgprop = "`1` is not a valid property for an image."
General::imgnb = "`1` is not a binary image."
General::imgng = "`1` is not a grayscale image."
General::imgcstype = "`1` is an invalid color space specification."
General::imgcsmis = "The specified color space `1` and the number of channels `2` are not compatible."
General::imgcsmsw = "The specified color space `1` and the number of channels `2` are not compatible; using Automatic instead."
General::imgcsbit = "The specified color space `1` is not compatible with the image type \"Bit\". Try Automatic instead."
General::imgcolor = "The value of option `1` -> `2` is not a valid color specification for image color space `3`."
General::imgnsch = "`1` should be a single-channel image."
General::cscycl = "`1` does not support images with a cyclic Hue channel. Assuming Automatic color space instead."
GeodesicDilation::arg2 = GeodesicErosion::arg2 = "The second argument `1` is neither a rectangular array nor an image."
GeodesicErosion::imgchne = GeodesicDilation::imgchne = "`1` and `2` should be images with the same number of channels."
GeodesicErosion::dimsne = GeodesicDilation::dimsne = "`1` and `2` should be images or arrays with the same dimensions."
Image::imgarray = "The specified argument `1` should be an array of rank 2 or 3 with machine-sized numbers."
Image::imgil = "The specified value of Interleaving option `1` does not match the dimensions of the input data."
DynamicImage::nimg = "The first argument of DynamicImage cannot be interpreted as an image."
DynamicImage::nfile = "The first argument `1` of DynamicImage is not a file path."
DynamicImage::nurl = "The first argument `1` of DynamicImage is not an accessible URL."
DynamicImage::nimgfile = "The first argument `1` of DynamicImage is not a file path to an image."
DynamicImage::narg1 = "The first argument of DynamicImage is neither an image nor an image file."
DynamicImage::nsize = "The ImageSize option value `1` for DynamicImage is not a proper size specification"
DynamicImage::nzoom = "The ZoomFactor option value `1` for DynamicImage does not represent a positive number."
DynamicImage::npos = "The ZoomCenter option value `1` for DynamicImage does not represent a pair of coordinates."
DynamicImage::naspect = "The AspectRatio option value `1` has to be Automatic or a real value."
ImagePyramid::chn = "Pyramid levels have incompatible number of channels."
ImagePyramid::dim = "The image dimensions `1` do not fit an image pyramid structure."
ImagePyramid::factor = "The pyramid scaling factor `1` needs to be a real number smaller than 1."
ImagePyramid::idx = "Index specification `1` is not supported for image pyramid levels."
ImagePyramid::interr = "No image pyramid was generated due to an internal error."
ImagePyramid::kernel = "Kernel specification `1` is not supported."
ImagePyramid::len = "Index specification `1` does not match the number of provided pyramid levels."
ImagePyramid::scale = "Image dimensions `1` of pyramid levels do not scale properly."
General::pyrtype = "Pyramid type `1` is not supported."
General::npyrm = "Expecting an image pyramid instead of `1`."
General::npyrop = "First argument `1` is not a valid operation for image pyramid levels."
General::ncomppyr = "Image pyramids in list `1` do not exhbit the same number of levels."
General::pyrlvl = "The requested number of pyramid levels `1` needs to be a positive integer or infinity as level index or a list of image dimensions."
ImagePyramidTake::nrng = "Range specification `1` is not supported."
ImageGraphics::img3D = "3D images are currently not supported."
ImageGraphics::npre = "PreProcessing `1` not supported."
ImageGraphics::nmthd = "Method `1` not supported. Use \"Exact\", \"LinearSeparable\", \"MarchingSquares\", or \"DualMarchingSquares\" instead."
ImageGraphics::ncdf = "DistanceFunction `1` is not a valid distance function for LAB color tuples."
ImageGraphics::coln = "The second argument `1` should specify at least 2 but not more than 4096 colors."
ImageGraphics::colspec = "The second argument `1` should be Automatic, a list of colors, or a number of colors n with 2 <= n <= 4096."
ImageGraphics::npad = "Padding `1` is not supported."
ImageGraphics::imginv = "Expecting in the first argument an image or graphics instead of `1`."
ImageGraphics::mindist = "Value of option MinColorDistance -> `1` is not Automatic or a positive machine number."
ImageMesh::nmthd = "Method `1` not supported."
ImageMesh::nmthd3d = "Method `1` not supported for 3D images ."
ImageMesh::imginv = "Expecting an image or graphics instead of `1`."
Image3D::imgarray = "The specified argument `1` should be an array of rank 3 or 4 with machine-sized numbers or a list of images of consistent dimension and color space."
Image3D::img3dprop = "`1` should be a list of images of consistent dimension and color space."
ColorCombine::ccbinput = "`1` should be a list of images with the same image dimensions."
ColorConvert::ccvinput = "`1` should be a valid image, a color directive, a list of machine-sized real numbers of length up to 5, or a list of such objects."
ColorConvert::ccvchan = "`1` is not compatible with the color space `2`."
ColorConvert::csamb = "The image color space `1` is ambiguous."
ColorConvert::icccs = "The color space `1` is not supported in color profile `2`."
ColorConvert::cpdinv = "`1` is not a valid color profile."
Binarize::arg2 = "The argument `1` should be a real number, a pair of real numbers, or a function."
Binarize::mthdfail = FindThreshold::mthdfail = MorphologicalBinarize::mthdfail = "Unable to find a global threshold with the setting Method -> `1`. Using Method -> Automatic instead."
Binarize::nmthd = FindThreshold::nmthd = MorphologicalBinarize::bdmtd = HighlightImage::bdmtd = "Method -> `1` is not a valid thresholding method."
LocalAdaptiveBinarize::bdparams = "The argument `1` should be a real number or a list of one, two, or three real numbers."
General::rthres = "The specified threshold value `1` should represent a real number."
General::initc = "Lowercase symbol `1` was created in the System context during initialization."
General::initg = "Symbol `1` was created in the Global context during initialization."
General::matnodd = "The matrix `1` should be of odd dimensions."
ImageTake::takec = "Cannot take the specified columns of the image."
ImageTake::taker = "Cannot take the specified rows of the image."
ImageTake::takes = "`1` cannot be used as the step. Use a positive integer."
ImageTake::arg4 = "ImageTake can be called with four arguments only when the first argument is an Image3D."
ImagePad::imgpadn = "Expecting a number or a 2 by 2 matrix of numbers instead of `1`."
ImagePad::img3padn = "Expecting a number or a 3 by 2 matrix of numbers instead of `1`."
ImagePad::padnull = "Padding specification `1` corresponds to an empty image."
General::imgpadm = "`1` is not a valid image padding specification."
General::imgmaskm = "`1` is not a valid image-masking specification."
General::arrpadm = "`1` is not a valid data padding specification."
ImagePad::incpad = "The specified padding value `1` is not compatible with a `2`-channel image."
ImageReflect::bdrfl2 = "`1` is not a valid 2D reflection specification."
ImageReflect::bdrfl3 = "`1` is not a valid 3D reflection specification."
General::bdrad = "`1` is not a valid neighborhood range specification."
MinDetect::arg1 = MaxDetect::arg1 = GaborFilter::arg1 = GradientFilter::arg1 = GaussianFilter::arg1 = LaplacianGaussianFilter::arg1 = LaplacianFilter::arg1 = MeanFilter::arg1 = GeometricMeanFilter::arg1 = HarmonicMeanFilter::arg1 = Image`TrimmedMeanFilter::arg1 = (*ContraharmonicMeanFilter::arg1 =*) MedianFilter::arg1 = MinFilter::arg1 = MaxFilter::arg1 = CommonestFilter::arg1 = StandardDeviationFilter::arg1 = EntropyFilter::arg1 = Erosion::arg1 = Dilation::arg1 = Opening::arg1 = Closing::arg1 = GeodesicOpening::arg1 = GeodesicClosing::arg1 = TopHatTransform::arg1 = BottomHatTransform::arg1 = GeodesicDilation::arg1 = GeodesicErosion::arg1 = BilateralFilter::arg1 = KuwaharaFilter::arg1 = MeanShiftFilter::arg1 = GradientOrientationFilter::arg1 = GuidedFilter::arg1 = "The first argument `1` is neither a rectangular array nor an image."
GuidedFilter::arg2 = "The second argument `1` is neither a rectangular array nor an image."
GuidedFilter::igpat = "The first argument `1` and the second argument `2` should have the same type and the same dimensions."
GuidedFilter::bdeps = "The specified regularization parameter `1` should be a positive number."
GeodesicOpening::knlinv = GeodesicClosing::knlinv = "Expecting a machine-sized number or a binary array of rank `2` instead of `1`."
StandardDeviationFilter::shlen = LocalAdaptiveBinarize::shlen = "Cannot compute the standard deviation of one element."
StandardDeviationFilter::shrad = "Standard deviation of neighborhoods with only one event are not properly defined. Returning zero standard deviation."
ComponentMeasurements::invarg1 = SelectComponents::invarg1 = "Expecting a valid label matrix, an image, or a list of an image and a label matrix instead of `1`."
ComponentMeasurements::invprop = SelectComponents::invprop = "`1` is not a known image segment property."
ComponentMeasurements::invsegs = SelectComponents::invsegs = "Expecting a label matrix of machine integers instead of `1`."
ComponentMeasurements::invtest = "Expecting a valid test function instead of `1`."
SelectComponents::invtest = "Expecting a valid test function or an integer number instead of `1`."
SelectComponents::invtest2 = "Cannot infer any known component property from the test function `1`."
ComponentMeasurements::invdsegs = SelectComponents::invdsegs = "Expecting a segmentation matrix with dimensions `2` instead of `1`."
ComponentMeasurements::nullimg = SelectComponents::nullimg = "A valid image is required for computing `1`."
ComponentMeasurements::notsup = "`1` properties are not supported yet for Image3D and 3D arrays."
ImageMeasurements::notsup = "`1` properties are not supported yet for Image3D."
SelectComponents::notsup = "Property `1` is not supported yet for Image3D and 3D arrays."
SelectComponents::noprop = "`1` is not a valid property or property list that can be used to rank components."
DeleteSmallComponents::arg1 = DeleteBorderComponents::arg1 = "Expecting an image or a label matrix instead of `1`."
DeleteSmallComponents::size = "Expecting a numeric value to specify the size of the smallest allowed component instead of `1`."
ColorQuantize::dtypebit = "ColorQuantize is not compatible with the image type \"Bit\"."
ColorQuantize::invcolors = "Expecting a positive integer or a list of colors instead of `1`."
MeanShiftFilter::dist = ClusteringComponents::dist = "The value of option DistanceFunction -> `1` should be one of ManhattanDistance, EuclideanDistance, SquaredEuclideanDistance, NormalizedSquaredEuclideanDistance, CosineDistance, or CorrelationDistance.";
ClusteringComponents::distcomp = "The values of the options DistanceFunction -> `1` and Method -> `2` are incompatible.";
ClusteringComponents::datainv = "`1` is not an image or numerical array.";
ArrayComponents::datainv = "`1` is not a numeric or symbolic array.";
Colorize::invinput = "Expecting an integer matrix or an image instead of `1`."
Colorize::invarg2 = "A set of indices or color rules are expected instead of `1`."
MinDetect::invh = MaxDetect::invh = FillingTransform::invh = "The height specification `1` must be positive."
FillingTransform::invdmar = "The label matrix used to define the marker, `1`, should have the same dimensions as the input image."
FillingTransform::arg2 = "Expecting either a marker or depth specification as the second argument instead of `1`."
Developer`CreateRegistryKey::nocreate = "The registry key `1` could not be created."
Developer`RemoveRegistryKey::noremove = "The registry key `1` could not be removed either because the key does not exist or because the key has subkeys."
Developer`EnumerateRegistrySubkeys::nokey = Developer`ReadRegistryKeyValues::nokey = "Could not read from the registry key `1`."
Developer`WriteRegistryKeyValues::rulelist = "The argument `1` is not a correctly formed list of rules that describe registry entries. The list must contain only rules whose left-hand side is a String or Null, and whose right-hand side is a String, an unsigned 32-bit integer, or a list of non-empty Strings."
Developer`WriteRegistryKeyValues::nowrite = "The registry entries described by `1` could not be written to the registry key `2`."
Developer`RemoveRegistryKeyValues::noremove = "The registry entries named `1` could not be removed from the registry key `2`."
General::nd = "The value of the option DistanceFunction -> `1` is not one of EuclideanDistance, ManhattanDistance, or ChessboardDistance."
Image`GrayLevelThreshold::bdmtd = "The value of option Method -> `1` should be one of Automatic, \"Otsu\", \"Kapur\", \"KittlerIllingworth\", \"Mean\", \"Median\", or {\"BlackFraction\", p} where p specifies the fraction of black pixels."
General::ostype = "The value of option OperatingSystem -> `1` must be one of \"MacOSX\", \"Windows\", or \"Unix\"."
GaussianMatrix::bdmtd = GaussianFilter::bdmtd = LaplacianGaussianFilter::bdmtd = "The value of option Method -> `1` is neither \"Gaussian\" nor \"Bessel\"."
ShenCastanMatrix::bdmtd = "The value of option Method -> `1` is not \"ShenCastan\".";
SavitzkyGolayMatrix::size = GaborFilter::size = GaborMatrix::size = CrossMatrix::size = BoxMatrix::size = DiskMatrix::size = DiamondMatrix::size = GaussianMatrix::size = ShenCastanMatrix::size = "`1` would result in an array with dimensions `2`, which is not a list of machine-sized integers."
GaussianFilter::size = LaplacianGaussianFilter::size = GradientFilter::size = GradientOrientationFilter::size = "`1` corresponds to a kernel with dimensions that are not all machine-sized integers."
GaborFilter::bdsigma = GaborMatrix::bdsigma = GradientFilter::bdsigma = GradientOrientationFilter::bdsigma = LaplacianGaussianFilter::bdsigma = GaussianFilter::bdsigma = GaussianMatrix::bdsigma = ShenCastanMatrix::bdsigma = "The standard deviation specification `1` must be a non-complex number or a non-empty list of non-complex numbers."
BilateralFilter::bdsigma = ImageDisplacements::dsigma = "The standard deviation specification `1` must be positive."
CornerFilter::bdrd = ImageCorners::bdrd = "The radius and standard deviation specification `1` must be either a non-negative number or a pair of non-negative numbers."
ImageCorners::bdrad = NonlocalMeansFilter::bdrad = "The specified radius `1` should be either a non-negative number or a pair of non-negative numbers."
EdgeDetect::bdrad = CornerFilter::bdrad = Blur::bdrad = Sharpen::bdrad = GuidedFilter::bdrad = "The specified radius `1` should be either a non-negative number or a list of `2` non-negative numbers."
GaborFilter::bdrad = GaborMatrix::bdrad = GradientFilter::bdrad = GradientOrientationFilter::bdrad = LaplacianGaussianFilter::bdrad = GaussianFilter::bdrad = GaussianMatrix::bdrad = ShenCastanMatrix::bdrad = "The radius specification `1` must be a non-complex number or a non-empty list of non-complex numbers."
GaussianMatrix::noscale = "One of a radius or a standard deviation must be supplied for each dimension of a Gaussian matrix."
GaborFilter::noscale = GaborMatrix::noscale = ShenCastanMatrix::noscale = "One of a radius or a standard deviation must be supplied for each dimension."
GaborFilter::prec = GaborMatrix::prec = GaussianMatrix::prec = ShenCastanMatrix::prec = "There is insufficient precision to guarantee that the error bound `1` is satisfied. Increasing the precision of the input or increasing WorkingPrecision may improve the result."
GaborFilter::bdregn = GaborMatrix::bdregn = GaussianMatrix::bdregn = ShenCastanMatrix::bdregn = "The fraction specification `1` should be a number between 0 and 1 noninclusive, or a list of numbers between 0 and 1, noninclusive."
GaussianMatrix::arg1 = ShenCastanMatrix::arg1 = "The first argument `1` should be a single non-complex radius, or a list of one to three items."
GaborMatrix::arg1 = "The first argument `1` should be a single non-complex radius, or a list of one or two items."
GaborFilter::badk = GaborMatrix::badk = "The direction `1` should be a vector of real numbers whose length is the rank of the desired GaborMatrix.";
GaborFilter::arg2 = LaplacianGaussianFilter::arg2 = GradientFilter::arg2 = GradientOrientationFilter::arg2 = GaussianFilter::arg2 = "The second argument `1` should be a single non-complex radius, or a list of one or two items."
MeanShiftFilter::radius = "The value of `1` is not a valid radius specification for `2`."
MeanShift::arg1 = "The specified argument `1` should be a list or an image."
MeanShift::radius = "The specified radius `1` is not a positive value."
MeanShift::weights = "Weights -> `1` is not a valid weights specification."
NonlocalMeansFilter::rsearch = "The radius `1` specified at position `2` should be larger than the radius `3` specified at position `4`."
NonlocalMeansFilter::noise = "The specified noise power `1` should be either a positive number or Automatic."
ImageAdd::bdarg = ImageSubtract::bdarg = ImageMultiply::bdarg = "Expecting a number, image, or graphics instead of `1`."
ImageAdd::bdres = ImageSubtract::bdres = ImageMultiply::bdres = "The arithmetic attempted resulted in overflow."
ImageAdd::cscomp = ImageSubtract::cscomp = ImageMultiply::cscomp = "Colorspace->`1` and `2` are not compatible."
ImageAdd::bdchan = ImageSubtract::bdchan = ImageMultiply::bdchan = ImageDifference::bdchan = "The number of channels must be equal or one of them must be a single-channel image and the other a multichannel image."
ImageDifference::imginvd = "Expecting images of the same size in the input."
ImageAdjust::cntr = "The contrast specification `1` in `2` should be a real number or a list of real number."
ImageAdjust::brght = "The brightness specification `1` in `2` should be a real number or a list of real number."
ImageAdjust::gamma = "The gamma correction parameter `1` in `2` should be a positive number or a list of positive numbers."
ImageAdjust::arg2 = "Invalid correction parameters `1`."
ImageAdjust::arg3 = "The input range specification `1` should be a pair of values or a pair of lists of values."
ImageAdjust::rngin = "The input boundary specification `1` in `2` should be a number, Automatic, or a list of numbers and Automatic."
ImageAdjust::arg4 = "The output range specification `1` should be a pair of numbers or a pair of lists of numbers."
ImageAdjust::rngout = "The output boundary specification `1` in `2` should be a number or a list of numbers."
EstimatedImageBrightness::imginv = "The first argument `1` needs to be an Image or Image3D."
EstimatedImageBrightness::nmdl = "The second argument `1` needs to be a List containing scope and model sepcifications."
EstimatedImageBrightness::nfmt = "The third argument `1` needs to be a String determining the format of the result."
EstimatedImageBrightness::nmsk = "The Mask option specification `1` is not supported."
General::nprf = "The PerformanceGoal option specification `1` is not supported."
BrightnessEqualize::imginv = "The first argument `1` needs to be an Image or Image3D."
BrightnessEqualize::nflat = "The flat-field argument `1` is not a model, an image, or a number."
BrightnessEqualize::ndark = "The dark-field argument `1` is not a model, an image, or a number."
BrightnessEqualize::nmsk = "The Mask option specification `1` is not supported."
ImageAssemble::rnk = "Expecting a rank 1 or 2 array of Image or Graphics objects or a rank 1, 2, or 3 array of Image3D objects."
ImageAssemble::slice = "Expecting images of the same depth in one slice."
ImageAssemble::row = "Expecting images of the same height in one row."
ImageAssemble::col = "Expecting images of the same width in one column."
ImageAssemble::chan = "Expecting images with a compatible number of channels."
ImageCompose::alphau = "Alpha blending parameter in `1` should be a number between 0 and 1."
ImageCompose::modeinv = "Invalid alpha compositing specification `1`."
ImageCompose::posinv = ImageDistance::posinv = "Invalid position specification in `1`."
ImageCompose::csinv = "Cannot composite general multichannel images with different channel depths."
ImageConvolve::klinv = "The kernel `1` should be either a real-valued matrix or a single channel image."
ImageCooccurrence::matinv ="The kernel `1` should be an array with odd dimension numbers and the same number of dimensions as the input data."
ImageCooccurrence::input1 ="The input `1` should be an image or a list of two images."
ImageCooccurrence::bin ="The bin size `1` should be a positive integer number."
ImageCooccurrence::dimmis = "The input images in `1` should be of the same size."
ImageCorrelate::klinv = "`1` is not a valid kernel specification."
ImageCorrelate::klcst = "The distance function `1` is not defined for constant kernels."
ImageCorrelate::klzero = "The distance function `1` is not defined for zero-valued kernels."
ImageCorrelate::bdarg3 = "Applying the distance function `1` did not yield a real number."
ImageDeconvolve::imginv = "Expecting an image instead of `1`.";
ImageDeconvolve::klinv = "Expecting an Image object or an array of real numbers of rank 2 or 3 instead of `1`.";
ImageDeconvolve::klinv3 = "Expecting an Image3D object or an array of real numbers of rank 3 or 4 instead of `1`.";
ImageDeconvolve::kldims = "The dimensions of a kernel cannot be larger than the dimensions of an image.";
ImageDeconvolve::mtd = "The value of option Method -> `1` should be one of \"DampedLS\", \"Tikhonov\", \"TSVD\", \"Wiener\", \"Hybrid\", \"RichardsonLucy\", \"SteepestDescent\", or \"TotalVariation\" with possible suboptions.";
ImageDeconvolve::param = "The value of regularization parameter `1` should be a non-negative real number, a vector of such numbers (for multi-channel images), or Automatic."
ImageDeconvolve::padding = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", GrayLevel[level], or c, where c is any machine-size number.";
MeanShiftFilter::iters = ImageDeconvolve::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
ImageDeconvolve::resinv = "Applying Method -> `1` to specified arguments does not yield a correct image.";
ImageDeconvolve::prec = "The value of option \"Preconditioned\" -> `1` should be either True or False.";
ImageDeconvolve::tvnoise = "The value of option \"NoiseModel\" -> `1` should be one of \"Gaussian\", \"Laplacian\", or \"Poisson\".";
ImageDeconvolve::tvparam = "The value of option \"Regularization\" -> `1` should be a non-negative real number, a vector of such numbers (for multi-channel images), or Automatic."
ImageEffect::effect = "`1` is not a known image effect."
ImageEffect::parinv= "Invalid image effect parameters given in `1`."
ImageFilter::bdn = "`1` is not a valid neighborhood specification."
ImageApply::bdf = ImageFilter::bdf ="Applying `1` to `2` does not yield a number or list of numbers."
ImageApply::bdfr = ImageFilter::bdfr = "Applying `1` to `2` does not yield a number."
ImageApply::rnk = ImageFilter::rnk ="Applying `1` to `2` does not yield a full array of pixel values."
ImageMeasurements::roiempty = "The value of option Masking->`1` does not contain any labels."
General::roi = "Expecting an image, a graphics object, or a real-valued matrix to define the region of interest instead of `1`."
General::roi3d = "Expecting a 3D image or a real-valued 3D array to define the region of interest instead of `1`."
ImageApply::roicomp = ImageFilter::roicomp = "Applying `1` to the region of interest produces pixels incompatible with the ones of the input image."
ImageApply::arg2 = ImageApplyIndexed::arg2 = "The argument `1` should be an image or a list of commensurate images."
ImageApply::itlvimgs = ImageApplyIndexed::itlvimgs = "With Interleaving -> False, all images should have the same number of channels."
ImageApply::imgsroi = ImageApplyIndexed::imgsroi = "The value of option Masking -> `1` should be All when the second argument is a list of images."
General::knlinv = "Expecting a machine-sized number or a binary matrix instead of `1`."
HitMissTransform::seinv = "Expecting a composite structuring element formed of integers 1, 0, and -1 or a list of composite structuring elements instead of `1`."
SetAlphaChannel::autimginv = "`1` of color space Automatic does not support alpha channel."
SetAlphaChannel::invalpha = "Expecting an image or a number between 0 and 1 for the alpha channel specification instead of `1`."
SetAlphaChannel::invalphai = "The dimension of the specified alpha channel must be of the same size as the input image."
SetAlphaChannel::invalphav = "Alpha blending parameter in `1` should be a number between 0 and 1."
HighlightImage::invcolor = RemoveAlphaChannel::invcolor = BorderDimensions::invcolor = "`1` is an invalid color specification."
Image`ImageGeneralFilter::undef = "Filter `1` is not defined."
Image`ImageGeneralFilter::params = "Filter \"`1`\" does not work with the given parameters."
Image`ImageGeneralFilter::undef = "Filter `1` is not defined."
Image`ImageGeneralFilter::params = "Filter \"`1`\" does not work with the given parameters."
GaborMatrix::notrebl = GaussianMatrix::notrebl = ShenCastanMatrix::notrebl = "The value of the option `1` -> `2` must be a non-complex number, True, False, Automatic, or a list of non-complex numbers, True, False, or Automatic."
GaussianMatrix::undifrm = "The values of the options \"Renormalize\" -> `1` and \"Mean\" -> `2` are incompatible for an undifferentiated GaussianMatrix. \"Renormalize\" -> `1` and \"Mean\" -> False will be used instead."
ShenCastanMatrix::undifrm = "The values of the options \"Renormalize\" -> `1` and \"Mean\" -> `2` are incompatible for an undifferentiated exponential matrix. \"Renormalize\" -> `1` and \"Mean\" -> False will be used instead."
DiskMatrix::notre = DiamondMatrix::notre = BoxMatrix::notre = CrossMatrix::notre = "The first argument `1` must be a non-complex number or a list of non-complex numbers."
DiskMatrix::auto1 = DiamondMatrix::auto1 = BoxMatrix::auto1 = CrossMatrix::auto1 = "At least one of a radius or a width must be supplied in `1`."
DiskMatrix::auto2 = DiamondMatrix::auto2 = BoxMatrix::auto2 = CrossMatrix::auto2 = "At least one of a radius or a width must be supplied for each dimension in `1`."
BernsteinBasis::ivdeg = BSplineBasis::invdeg = "Degree `1` should be a non-negative machine-sized integer."
BernsteinBasis::invidx = BSplineBasis::invidx = "Index `1` should be a non-negative machine-sized integer."
BernsteinBasis::invidx2 = BSplineBasis::invidx2 = "Index `1` should be a machine-sized integer between `2` and `3`."
BSplineBasis::knotsdec = "Knot sequence `1` should be a non-decreasing sequence of real numbers."
BSplineBasis::knotslen = "Length of knot sequence `1` should be greater than or equal to `2`."
General::invcpts = "`1` should be a rectangular array of machine-sized real numbers of any depth, whose dimensions are greater than 1."
General::invdspec = "Argument `1` at position `2` should be a positive integer that does not exceed `3`, the depth of the given array, or a list of pairs of real numbers."
BSplineFunction::invlvl = BezierFunction::invlvl = "Argument `1` at position `2` should be a positive integer which should not exceed `3`, the depth of the given array."
BSplineFunction::invdeg = BezierFunction::invdeg = "Value of option SplineDegree -> `1` should be a positive integer, or a list of positive integers."
BSplineFunction::invdeg2 = "Value of option SplineDegree -> `1` is too high for the given array. It should be less than each dimension of the array."
BezierFunction::invdeg2 = "Value of option SplineDegree -> `1` should be a positive integer, or a list of integers, whose values are one less than each dimension of the array."
BSplineFunction::invcl = "Value of option SplineClosed -> `1` should be True, False, or a list of such values."
BSplineFunction::invknots = "Value of option SplineKnots -> `1` should be a non-decreasing real sequence of proper length, or a list of such sequences."
BSplineFunction::invwgts = "Value of option SplineWeights -> `1` should be a rectangular array of positive numbers, with the same dimensions as the control point array."
BSplineFunction::nmrarg = BezierFunction::nmparg = "Argument `1` at position `2` should be a machine-sized real."
TextRecognize::langinvx = "Supporting data for the language `1` could not be downloaded."
TextRecognize::langinvn = "Supporting data for the languages `1` could not be downloaded."
TextRecognize::langwrngx = "`1` is not a supported language."
TextRecognize::langwrngn = "`1` are not supported languages."
TextRecognize::imginv = "Expecting an image, a graphics, or a file instead of `1`."
TextRecognize::invlvl = "Expecting All, Automatic, \"Character\", \"Block\", \"Line\", or \"Word\"instead of `1`."
TextRecognize::invlvlfndtxt = "Expecting Automatic or \"Line\" instead of `1`, when Masking -> Automatic."
TextRecognize::invprop = "Expecting \"BoundingBox\", \"Image\", \"Strength\", \"Text\", or a list of these properties instead of `1`."
General::liberror = "A required library could not be located or opened."
Database`Database::notobj = "`1` is not a valid Database object."
Database`Database::notdb = "The database `1` is not open, or is invalid."
Database`QueryDatabase::stmt = "The statement \"`1`\" is invalid: \"`2`\"."
Database`QueryDatabase::query = "Could not process the query \"`1`\": \"`2`\"."
GeneralizedLinearModelFit::notfam = "`1` is not a valid ExponentialFamily value. Valid values are Automatic, \"Binomial\", \"Gamma\", \"Gaussian\", \"InverseGaussian\", \"Poisson\", \"QuasiLikelihood\", and {\"QuasiLikelihood\", ...} with suboptions \"VarianceFunction\" and \"ResponseDomain\"."
GeneralizedLinearModelFit::binrsp = LogitModelFit::binrsp = ProbitModelFit::binrsp = "The response values are expected to be between 0 and 1 for binomial models."
GeneralizedLinearModelFit::respmat = LinearModelFit::respmat = LogitModelFit::respmat = ProbitModelFit::respmat = "One or more elements in the last column of the first argument is not valid for the exponential family `1`."
GeneralizedLinearModelFit::respvec = LinearModelFit::respvec = LogitModelFit::respvec = ProbitModelFit::respvec = "One or more elements of the first argument is not valid for the exponential family `1`."
GeneralizedLinearModelFit::desmat = LinearModelFit::desmat = LogitModelFit::desmat = ProbitModelFit::desmat = "Unable to construct a numeric design matrix. Nominal variables may need to be specified, or non-numeric entries for numeric variables may need to be replaced."
GeneralizedLinearModelFit::resp = "One or more elements in the response vector is not valid for the exponential family `1`."
LinearModelFit::resp = "The response vector is expected to be a list of real numbers."
LogitModelFit::resp = ProbitModelFit::resp = "The response vector is expected to be a list of numbers between 0 and 1."
GeneralizedLinearModelFit::vrfun = "The function `1` is not a valid variance function on the domain `2`. A valid variance function must be non-negative on the response domain."
GeneralizedLinearModelFit::offset = LinearModelFit::offset = LogitModelFit::offset = ProbitModelFit::offset = "The LinearOffsetFunction `1` is not a real-valued function, Automatic, or None."
GeneralizedLinearModelFit::nomvars = LinearModelFit::nomvars = LogitModelFit::nomvars = ProbitModelFit::nomvars = DesignMatrix::nomvars = "`1` is not a valid NominalVariables value. Valid values are All, None, or a list of variables."
GeneralizedLinearModelFit::rank = LinearModelFit::rank = LogitModelFit::rank = ProbitModelFit::rank = "The rank of the design matrix `1` is less than the number of terms `2` in the model. The model and results based upon it may contain significant numerical error."
GeneralizedLinearModelFit::dpbss = LinearModelFit::dpbss = LogitModelFit::dpbss = ProbitModelFit::dpbss = DesignMatrix::dpbss = "The number of unique basis functions is `1` fewer than the number of basis functions specified in `2`. Duplicated basis functions will be removed."
GeneralizedLinearModelFit::terms = LinearModelFit::terms = LogitModelFit::terms = ProbitModelFit::terms ="Only `2` terms are needed to represent all nominal values and continuous basis functions, which is fewer than the total number of nominal terms and continuous basis functions `1`. A model for `2` terms of basis functions will be returned."
DesignMatrix::terms="Only `2` terms are needed to represent all nominal values and continuous basis functions, which is fewer than the total number of nominal terms and continuous basis functions `1`. A full rank matrix for `2` terms will be returned."
GeneralizedLinearModelFit::wts = LinearModelFit::wts = LogitModelFit::wts = ProbitModelFit::wts = NonlinearModelFit::wts = "The value of option Weights -> `1` should be a list of real numbers or a pure function."
GeneralizedLinearModelFit::wtsln = LinearModelFit::wtsln = LogitModelFit::wtsln = ProbitModelFit::wtsln = NonlinearModelFit::wtsln = "The number of weights `1` specified by Weights->`2` is not the same as the number of data points `3`."
GeneralizedLinearModelFit::wtsnn = LinearModelFit::wtsnn = LogitModelFit::wtsnn = ProbitModelFit::wtsnn = NonlinearModelFit::wtsnn = SpatialMedian::wtsnn = CentralFeature::wtsnn = "One or more weight values are not non-negative numbers. Weight values must be non-negative."
GeneralizedLinearModelFit::bdcl = LinearModelFit::bdcl = LogitModelFit::bdcl = ProbitModelFit::bdcl = NonlinearModelFit::bdcl = FittedModel::bdcl = "The value of option ConfidenceLevel -> `1` is not a number between 0 and 1."
GeneralizedLinearModelFit::dispfun = LogitModelFit::dispfun = ProbitModelFit::dispfun = "The value of option DispersionEstimatorFunction -> `1` is not a pure function, \"PearsonChiSquare\", or Automatic."
GeneralizedLinearModelFit::cvfun = LogitModelFit::cvfun = ProbitModelFit::cvfun = FittedModel::cvfun = "The value of option CovarianceEstimatorFunction -> `1` is not \"ExpectedInformation\" or \"ObservedInformation\"."
GeneralizedLinearModelFit::notlink = "The function `1` is not a valid link function or Automatic."
GeneralizedLinearModelFit::bnames = LinearModelFit::bnames = LogitModelFit::bnames = ProbitModelFit::bnames = "The length `1` of the list `2` is not the same as the number of columns `3` in the design matrix."
GeneralizedLinearModelFit::bvals = LinearModelFit::bvals = LogitModelFit::bvals = ProbitModelFit::bvals = "The list `1` contains invalid basis label values. Basis labels must be valid variables or strings."
GeneralizedLinearModelFit::desmat2 = LinearModelFit::desmat2 = LogitModelFit::desmat2 = ProbitModelFit::desmat2 = "The specified design matrix is not a matrix of real values."
GeneralizedLinearModelFit::notdata = LinearModelFit::notdata = LogitModelFit::notdata = ProbitModelFit::notdata = "The first argument is not a vector, matrix, or a list containing a design matrix and response vector."
FittedModel::qsint= "Unable to compute the quasi-likelihood integral."
FittedModel::qscnd= "A conditional result has been returned for the quasi-likelihood integral. The conditional result will be used, ignoring the conditions of convergence."
FittedModel::prpopt="The options `1` are not relevant to property computations and will be ignored."
FittedModel::dspzero="The estimated dispersion is zero. Properties requiring division by the dispersion parameter will not be computed."
FittedModel::dspnum="The estimated dispersion `1` is not a positive number. Properties requiring division by the dispersion parameter will not be computed."
FittedModel::badcov = "Unable to estimate the covariance matrix. Properties requiring covariances or standard errors will not be computed."
FittedModel::ansint= "Unable to compute the Anscombe residual integral."
FittedModel::anscnd="A conditional result has been returned for the Anscombe residual integral. The conditional result will be used, ignoring the conditions of convergence."
GeneralizedLinearModelFit::linknum = LinearModelFit::linknum = LogitModelFit::linknum = ProbitModelFit::linknum = "The LinkFunction `1` did not evaluate to a real number when applied to one or more of the response values."
GeneralizedLinearModelFit::irlsfail = LogitModelFit::irlsfail = ProbitModelFit::irlsfail = FittedModel::irlsfail = "Non-real values were encountered during the IRLS process. The specified model may not be appropriate for the data."
LinearModelFit::varfun = NonlinearModelFit::varfun = FittedModel::varfun="The value of option VarianceEstimatorFunction -> `1` is not a pure function or Automatic."
GeneralizedLinearModelFit::mvdims = LinearModelFit::mvdims = LogitModelFit::mvdims = ProbitModelFit::mvdims = "The number of rows `1` in the design matrix is not the same as the length of the `2` of the response vector."
FittedModel::varzero="The estimated variance is zero. Properties requiring division by the variance or standard error will not be computed."
FittedModel::varnum="The estimated variance `1` is not a positive number. Properties requiring division by the variance or standard error will not be computed."
FittedModel::constr = "The property values `1` assume an unconstrained model. The results for these properties may not be valid, particularly if the fitted parameters are near a constraint boundary."
FittedModel::dof = "The number of parameters `1` is not less than the number of data values `2`. Some property values cannot be computed."
FittedModel::nosvd = "Unable to obtain the singular value decomposition for the design matrix corresponding to the linearized problem. Some property values cannot be computed."
FittedModel::zerocov = "`` cannot be computed in the case of zero elements on the diagonal of \"CovarianceMatrix\"."
FittedModel::bands="Unable to compute confidence bands for models that are not symbolically differentiable."
FittedModel::nodm = "Unable to compute an approximate design matrix because derivatives of the model could not be found. Some property values cannot be computed."
FittedModel::noqrd = "Unable to obtain the QR decomposition of the design matrix corresponding to the linearized problem. Curvature measures and parameter bias cannot be computed."
FittedModel::crvrnk = "Parameter solution locus has dimensionality of only `1` at the parameter estimate, which is less than full dimensionality `2`. Confidence region curvature is given by 1/Sqrt[Quantile[FRatioDistribution[`1`, `3`], `4`]]."
FittedModel::noinv = "Unable to obtain an inverse or pseudoinverse for the R matrix in the QR decomposition of the design matrix corresponding to the linearized problem. Curvature measures and parameter bias cannot be computed."
FittedModel::pefail = "Maximum parameter-effects curvature search failed to converge in `` iterations. The parameter-effects curvature may not be maximum value."
FittedModel::bdfit = "The sum of squared errors is not a non-negative number. The model may suffer from significant numerical error or may not be appropriate for the data."
FittedModel::errdf ="The model contains no degrees of freedom for Error. The data is insufficient to obtain a meaningful analysis of variance."
Entropy::targ = "Argument `1` at position `2` should be a List, a SparseArray, or a String."
FittedModel::infail = "Maximum intrinsic curvature search failed to converge in `` iterations. The intrinsic curvature may not be maximum value."
ImageRotate::imgang = "Angle `1` should be a real number, one of Top, Bottom, Left, Right, or a rule from one to another."
ImageRotate::imgang3d = "Angle `1` should be a real number or a pair consisting of a real number and a 3D vector with nonzero magnitude."
ImageResize::imgrsasp = Thumbnail::imgrsasp = "Value of option AspectRatio -> `1` should be a positive number or a pair of positive numbers."
ImageResize::imgrssz = Thumbnail::imgrssz = ImageRotate::imgrssz = "The size `1` is not a valid image size specification."
Thumbnail::imginv = "Expecting an image or a file name instead of `1`."
Thumbnail::fnexst = "File `1` not found."
Thumbnail::ftype = "File format `1` is not supported."
Thumbnail::toolarge = "Thumbnail scale is `1` and, thus, too large. Resetting scale to 1.";
Thumbnail::toosmall = "Thumbnail scale is `1` and, thus, too small. Resetting scale to 1/512.";
EdgeDetect::bdmtd = ImageLines::bdmtd = ImageCorners::bdmtd = ImageSaliencyFilter::bdmtd = CornerFilter::bdmtd = Radon::bdmtd = WatershedComponents::bdmtd = ImageKeypoints::bdmtd = "Value of Method -> `1` is not a valid method specification."
GradientFilter::bdmtd = GradientOrientationFilter::bdmtd = "The value of option Method -> `1` should be either one of \"Bessel\", \"Gaussian\", \"ShenCastan\", \"Sobel\", or a commensurate list of arrays."
GradientOrientationFilter::undefor = "With images, the value of option \"UndefinedOrientation\" -> `1` should be a real number."
ChessboardDistance::nvm = "The argument `1` at position `2` of `3` should be a number, vector, or matrix."
General::vfldata = "`1` is not a valid vector field dataset or a valid list of datasets."
General::chlyt = "Value of option ChartLayout -> `1` is not a recognized chart layout."
General::ldata = "`1` is not a valid dataset or list of datasets."
General::sclfn = "The scaling function `` cannot be used to scale coordinates."
PairedBarChart::chorn = PairedHistogram::chorn = "Value of option BarOrigin -> `1` is not XAxis or YAxis."
BarChart::chorn = RectangleChart::chorn = Histogram::chorn = BoxWhiskerChart::chorn = DistributionChart::chorn = "Value of option BarOrigin -> `1` is not Bottom, Left, Right, or Top."
BarChart3D::chorn = RectangleChart3D::chorn = Histogram3D::chorn = "Value of option BarOrigin -> `1` is not Back, Bottom, Front, Left, Right, or Top."
PieChart::chorn = SectorChart::chorn = PieChart3D::chorn = SectorChart3D::chorn = "Value of option SectorOrigin -> `1` is not a valid starting position for the first sector."
BarChart::chspc = PairedBarChart::chspc = RectangleChart::chspc = BarChart3D::chspc = RectangleChart3D::chspc = BoxWhiskerChart::chspc = DistributionChart::chspc = "Value of option BarSpacing -> `1` is not a size or pair of sizes."
PieChart::chspc = SectorChart::chspc = PieChart3D::chspc = SectorChart3D::chspc = "Value of option SectorSpacing -> `1` is not a size or pair of sizes."
General::chsty = "Value of option ChartStyle -> `` is not a style or group of styles."
General::chelem = "Value of option ChartElements -> `` is not a graphic, a list containing a graphic and sizes, or a list of these."
BarChart3D::chelem = RectangleChart3D::chelem = BubbleChart3D::chelem = Histogram3D::chelem = "Value of option ChartElements -> `` is not a three-dimensional graphic or a list of three-dimensional graphics."
General::chelfn = "Value of option ChartElementFunction -> `` is not a valid chart element function, or an appropriate ChartElementData entity."
Placed::labpos = Labeled::labpos = "`` is not a valid position for the placement of labels."
Callout::copos = "`` is not a valid position for the placement of callouts."
Callout::ldpos = "The callout anchor position `` should be Automatic, or an absolute or scaled coordinate position."
BubbleChart::chbscl = "Value of option BubbleScale -> `` should be \"Diameter\" or \"Area\"."
BubbleChart3D::chbscl = "Value of option BubbleScale -> `` should be \"Diameter\" or \"Volume\"."
BubbleChart::chbsz = BubbleChart3D::chbsz = "Value of option BubbleSizes -> `` is not a valid bubble size range."
DiscretePlot::eitr = DiscretePlot3D::eitr = "Iterator `` should correspond to a non-empty set of numbers."
Histogram::tbins = Histogram3D::tbins = DensityHistogram::tbins = PairedHistogram::tbins = HistogramList::tbins = DateHistogram::tbins = HistogramDistribution::tbins = "The bin specification `` generated too many bins; using automatically chosen bins instead."
Histogram::hbins = Histogram3D::hbins = DensityHistogram::hbins = PairedHistogram::hbins = HistogramList::hbins = DateHistogram::hbins = HistogramDistribution::hbins = GeoHistogram::hbins = "The bin specification `` cannot be used to determine either how many or which bins to use."
Histogram::hspec = Histogram3D::hspec = DensityHistogram::hspec = PairedHistogram::hspec = HistogramList::hspec = DateHistogram::hspec = HistogramDistribution::hspec = GeoHistogram::hspec = "The height specification `` is not one of the named height functions or a function that can be used to compute the heights for each bin."
Histogram::hfilter = Histogram3D::hfilter = DensityHistogram::hfilter = PairedHistogram::hfilter = HistogramList::hfilter = DateHistogram::hfilter = HistogramDistribution::hfilter = "The data filter `` could not be used to filter data from the dataset."
GeoHistogram::outsiderange = "Polygon lies outside range of GeoGridPosition."
BoxWhiskerChart::bwspec = "`1` cannot be used as a box-and-whisker symbol specification."
QuantilePlot::ldata = ProbabilityPlot::ldata = ProbabilityScalePlot::ldata = "`1` is not a valid dataset, distribution, or a valid list of datasets and distributions."
QuantilePlot::ref = ProbabilityPlot::ref = "The reference distribution `1` is not a valid dataset or distribution."
ProbabilityScalePlot::ref = "The reference distribution `1` is not \"Normal\", \"Weibull\", \"Exponential\", \"LogNormal\", \"Rayleigh\", \"Frechet\", or \"Gumbel\"."
QuantilePlot::estmd = ProbabilityPlot::estmd = ProbabilityScalePlot::estmd = "Unable to estimate a reference distribution from the data."
SmoothHistogram::dfun = SmoothHistogram3D::dfun = SmoothDensityHistogram::dfun = "The distribution function `1` is not \"PDF\", \"CDF\", \"HF\", \"CHF\", or \"SF\"."
FinancialIndicator::badpara = "Financial indicator `` requires more data points to compute a result."
FinancialIndicator::incmptbldata = "The data and the parameter(s) are incompatible for the computation of the Financial indicator `1`. Try providing more data and/or change the parameter(s)."
FinancialIndicator::ind = "Indicator `1` is not a known entity for FinancialIndicator. Use FinancialIndicator[] for a list of entities."
FinancialIndicator::badparam = "`1` parameter is expected for `2`.";
FinancialIndicator::insuffdatafeed = "`1` requires the following data feed: `2` or {Open, High, Low, Close, Volume}."
MandelbrotSetMemberQ::maxiter = "Maximum number of iterations reached. Point may not actually be in the Mandelbrot set, but just extremely close.";
MandelbrotSetPlot::baditer = "Number of iterations must be a positive whole number."
MandelbrotSetPlot::badresol = "Value of option ImageResolution must be a positive number."
MandelbrotSetPlot::badbounds = "Either width or height of bounding box is zero."
MandelbrotSetPlot::badescrad = "Value of option EscapeRadius must be a positive number > 2."
JuliaSetPlot::noorbs = "No attractive behavior detected."
JuliaSetPlot::badpr = "PlotRange should be Automatic, a number, or of the form {{xmin,xmax},{ymin,ymax}}."
JuliaSetPlot::polyesctime = "Escape time method works only for polynomials."
JuliaSetPlot::baditer = "MaxIterations must be a positive whole number."
JuliaSetPlot::badresol = "Value of option ImageResolution must be a positive number."
JuliaSetPlot::badtolerance = "Value of option \"ClosenessTolerance\" must be a positive number."
JuliaSetPlot::badbound = "Value of option \"Bound\" must be a positive number."
JuliaSetPlot::nopoints = "No points found within the specified bound. Try adjusting the \"Bound\" option."
JuliaSetPlot::constfunc = "The Julia set of a constant function is nonexistent."
JuliaSetPlot::nosprt = "Nonrational functions are not supported."
NumberLinePlot::nondom = "Domain expected beyond position `1` in `2`."
HistogramTransform::refinv = HistogramTransformInterpolation::refinv = "`1` should be an image, a dataset, a distribution, or a list of datasets compatible with the argument at position 1.";
HistogramTransform::imginv = HistogramTransformInterpolation::imginv = "`1` should be an image, a dataset, or a list of datasets.";
HistogramTransform::lvls = HistogramTransformInterpolation::lvls = "`1` should be a positive integer or Automatic.";
ImagePartition::arg2 = "`1` is not a valid size specification for image partitions."
ImagePartition::arg3 = "`1` is not a positive number or a pair of positive numbers."
ImageCrop::arg2 = "`1` is not a positive integer, pair of integers, Full or Automatic."
ImageCrop::arg3 = "`1` is not a list of two numbers or two valid symbolic cropping values."
ImageCrop::cspecsym = "Cropping value `1` is not one of Center, Left, Right, Top, or Bottom."
ImageCrop::ratio = "Aspect ratio `1` must be a positive real number or Automatic."
ImageCrop::incomp = "Range specification `1` and aspect ratio `2` have incompatible values."
ImageCrop::unsup ="The size or specification format is not supported."
General::scvalue = "`1` must be a positive real number or a Scaled number between 0 and 1. Automatic value will be used."
General::strmpts = "`1` is not a valid StreamPoints specification."
General::vectsc = "`1` is not a valid VectorScale specification."
ImageLevels::arg2 = ImageHistogram::arg2 = "`1` is not a positive integer, \"Byte\", or All."
ImageLevels::arg3 = ImageHistogram::arg3 = "The specified range `1` is not All, a pair of numbers, or a number and All."
ImageLevels::meth = ImageHistogram::meth = "Value of option `1` -> `2` should be \"IncludeOutOfRange\" or \"ExcludeOutOfRange\"."
ImageLevels::clip = ImageHistogram::clip = "Value of option `1` -> `2` should be True or False."
ImageLevels::channels = "Length of range argument `1` does not match number of image channels `2`."
ImageHistogram::opapp = "Value of option Appearance -> `1` is not one of Automatic, \"Transparent\", \"RGB\", \"Stacked\", or \"Separated\"."
ImageHistogram::opapp2 = "Value of option Appearance -> `1` for non-RGB images is not valid. Use Automatic, \"Transparent\", \"Stacked\", or \"Separated\" instead."
General::ltrng = "Invalid latitude specification `1`."
General::invdtm = "Unknown geodetic datum `1`. Use GeodesyData[\"Datum\"] for a list of available named datums."
General::secs = "Warning: Numeric date `1` is interpreted as seconds since the beginning of 1900, not as a year specification."
GeoPosition::extend = GeoDirection::extend = GeoDestination::extend = GeoDisplacement::extend = "Entity `1` is extended. Proceeding with an average location `2`."
GeoPosition::geotag = GeoMarker::geotag = "Unable to extract geo location information from image `1`."
GeoPositionENU::origin = "Origin `1` is expected to be a valid GeoPosition, GeoPositionENU, or GeoPositionXYZ object."
GeoGridPosition::invset = "`1` is not a valid setting."
GeoGridPosition::dom = "Cannot project position `1` because it falls outside of the domain of applicability of the projection `2`."
General::invlen = "`1` is not a valid distance specification."
General::invazm = "`1` is not a valid bearing specification."
General::invdur = "`1` is not a valid time-difference specification."
GeoDestination::pole = "GeoDestination cannot calculate based on the north pole or the south pole."
General::sppole = "Latitudes 90 and -90 cannot be used as standard parallels of a geo projection."
General::sconic = "Conic projection `1` with standard parallels `2` is singular."
General::projh0 = "Centering of geo projection requires a nonzero elevation."
General::sazim = "Cannot perform geo projection at the antipode of the centering."
General::model =  "Formulas for projection `1` are unavailable."
General::njc = "Jacobian formulas for projection `1` are unavailable."
General::invproj = "Invalid projection specification `1`."
General::noproj = "Undefined projection or Jacobian for parameters `1`."
General::nopoint = "Cannot compute projection or Jacobian at coordinates `1`."
General::badpoint = "Singular value of the projection distortion at coordinates `1`."
General::getloc = "Cannot obtain location data from geo vector object."
General::getvec = "Cannot obtain vector data from geo vector object."
General::vproj = "Cannot perform geo projection on geo vector object."
General::nogv = "Invalid geo vector object `1`."
General::vstra = "Dimensions `1` of vector data array are incompatible with dimensions `2` of location array."
General::vstrl = "Length `1` of vector data list is incompatible with length `2` of location list."
General::vstr = "Invalid structure of first argument of geo vector object."
General::gvc = "Cannot convert from geo vector object of type `1`."
General::qdims = "Invalid quantity dimensions of geo vector units `1`."
General::gvdim = "Geo vector dimension `1` should be between 2, 3 or 4."
GeoGridVector::csym = "Invalid geo vector coordinate system `1`."
GIS`GeoAreaDistortion::projpars = "Cannot compute area distortion for the projection specification `1`."
GIS`GeoAreaDistortion::axesmodel = "Cannot compute area distortion for the geo model specification `1`."
GIS`GeoDirectionDistortion::projpars = "Cannot compute direction distortion for the projection specification `1`."
GIS`GeoDirectionDistortion::axesmodel = "Cannot compute direction distortion for the geo model specification `1`."
GIS`GeoDistanceDistortion::projpars = "Cannot compute distance distortion for the projection specification `1`."
GIS`GeoDistanceDistortion::axesmodel = "Cannot compute distance distortion for the geo model specification `1`."
GIS`TissotDistortionMatrix::projpars = "Cannot compute Tissot matrix for the projection specification `1`."
GIS`TissotDistortionMatrix::axesmodel = "Cannot compute Tissot matrix for the geo model specification `1`."
GeoLength::geopath = "Invalid geo path `1`."
GeoArea::georeg = "Invalid geo region `1`."
GeoArea::orient = "Invalid orientation specification `1`."
GeoArea::pts = "Invalid list of points `1`."
GeoArea::mpol = "Missing polygon information for `1`."
GeoArea::fcnest = "Cannot determine nesting structure of boundaries in FilledCurve object. Assuming {outer, inner1, inner2, ...}."
GeoServer::maxtl = "Number of requested tiles, `1`, is too large."
GeoServer::invlyr = "Invalid layer `1` for `2` in the `3` geo server. The default layer is `4`."
GeoServer::ctos = "Unable to store terms of service approval for `1` in the cloud."
GeoServer::notos = "To use the `1` tile provider, you must accept the terms of service."
GeoServer::ext = "Zoom level `1` not available in the `2` geo server. Switching to the external tile provider `3`."
GeoServer::mlim = "You have reached your monthly limit for high-resolution geo imagery. To request information on extending it, contact us at `1`."
GeoServer::credits = "Available `1` service credits are not enough to download `2` more tiles through integrated services."
GeoServer::nocld = "Connection to the tile provider `1` is not allowed from this cloud platform."
GeoServer::body = "Unknown celestial globe `1`.";
GeoServer::extly = "Unknown layer `2` for external tile provider `1`."
General::urls = "Cannot construct tile URLs for the given geo server."
General::unkopt = "Unknown parameter `1`."
General::invopt = "Invalid value `1` for parameter `2`. Using default value `3`."
General::invlopt = "Invalid list of options `1`."
General::method = "Method \"`1`\" is not a valid method."
General::ellipsoids = "Ellipsoids of input parameters do not match."
General::invcoord = "`1` is not a valid coordinate specification."
General::invpos = "`1` is not a valid position specification."
General::invloc = "`1` is not a valid location specification."
General::invlloc = "`1` is not a valid list of location specifications."
General::locs = "Argument `1` at position `2` does not represent a non-empty list of locations."
General::invcrs = "`1` is not a valid course specification."
General::datum = "No direct transformation between datums `1` and `2` is available."
General::datumtrns = "No direct transformation between datums `1` and `2` is available. Using intermediate datum \"`3`\"."
General::datums = "Found incompatible datums `1`."
GeoProjectionData::rename = "Geo projection `1` has been renamed `2`."
PolarAxes::polaraxes = "Value of option PolarAxes -> `1` is not True, False, or a length-two list of True or False."
PolarAxes::polaraxorg = "Value of option PolarAxesOrigin -> `1` is not Automatic, a valid 2D polar coordinate or a list of valid position specifications."
PolarAxes::polargrid = "PolarGridLines specification should be None, Automatic, or a list of polar grid line specifications."
PolarAxes::polarticks = "Value of PolarTicks -> `1` should be None, Automatic, or a list of tick specifications."
System`Private`Arguments::rspec = "The range specification `1` should have the form m, {m, n} or {m, Infinity}, where m and n are integers and 0 <= m <= n."
System`Private`Arguments::optrs = "Option specification `1` in `2` is not a symbol or a rule for a symbol or string."
EdgeDetect::bdthr = ImageLines::bdthr = MorphologicalBinarize::bdarg2 = ImageCorners::bdthr = "Invalid threshold specification `1`."
EdgeDetect::bdf = "Applying `1` to the upper threshold `2` does not yield a number."
ImageLines::bddis = "The specified distinctness `1` should be a number between 0 and 1."
ImageCorners::bdsf = "The specified value of option \"StrengthFraction\" -> `1` should be a number greater than 0 and less than or equal to 1."
ImageCorners::mxref = "The specified value of option \"MaxRefinement\" -> `1` should be a non-negative number."
LinearAlgebra`Private`CholeskyUpdate::nmat = LinearAlgebra`Private`CholeskyDowndate::nmat = "Argument `1` at position `2` must be numeric non-empty square matrix."
LinearAlgebra`Private`CholeskyUpdate::nvec = LinearAlgebra`Private`CholeskyDowndate::nvec = "Argument `1` at position `2` must be numeric non-empty vector."
LinearAlgebra`Private`CholeskyDowndate::npdef = "Downdated matrix is not positive definite."
PrincipalComponents::noprc = "Cannot compute the principal components transform of the matrix `1`."
LinearSolve::parpreo = LinearSolveFunction::parpreo = "Preordering failed during the symbolic factorization. It is possible that the matrix is singular."
LinearSolve::parreo = LinearSolveFunction::parreo = "PARDISO produced an error message of \"reordering problem\". It is possible that the matrix is singular."
LinearSolve::parpiv = LinearSolveFunction::parpiv = "Zero pivot was detected during the numerical factorization or there was a problem in the iterative refinement process. It is possible that the matrix is ill-conditioned or singular."
LinearSolve::pardm = LinearSolveFunction::pardm = "PARDISO produced an error message of \"diagonal matrix problem\". It is possible that the matrix is singular."
LinearSolve::paroocmem = LinearSolveFunction::paroocmem = "Not enough memory is available for PARDISO out-of-core solver."
LinearSolve::paroocfop = LinearSolveFunction::paroocfop = "PARDISO out-of-core solver is unable to open temporary data files."
LinearSolve::paroocfrw = LinearSolveFunction::paroocfrw = "PARDISO out-of-core solver is unable to read or write temporary data files."
LinearSolve::parierr = LinearSolveFunction::parierr = "Internal error occurred in PARDISO solver."
LinearSolve::parme = LinearSolveFunction::parme = "`1` is not a supported PARDISO method. It should be Cholesky, Unsymmetric, or Automatic."
LinearSolve::parooc = LinearSolveFunction::parooc = "Value of option OOC -> `1` is not Automatic, True, or False."
LinearSolveFunction::nsupcn = "The matrix condition number cannot be computed."
CrossingDetect::arg1 = ContourDetect::arg1 = Image`StepDetect::arg1 = "The specified argument `1` should be either an image or an array of rank 1, 2, or 3 with machine-sized numbers."
CrossingDetect::cnn1 = ContourDetect::cnn1 = Image`StepDetect::cnn1 = "Cannot perform detection of one element with CornerNeighbors -> None. Use CornerNeighbors -> Automatic instead."
EstimatedDistribution::ntdist = "The value `1` is not a recognized distribution."
FindDistributionParameters::ntdist = "The value `1` is not a recognized distribution."
General::ntsprt = "One or more data points are not in support of the process or distribution `1`."
General::nvsprt = "The support of the distribution `1` could not be determined. The validity of the data for `1` could not be determined."
General::rlstrt = "The value `1` in the starting value specification `2` is expected to be a real number."
EstimatedDistribution::nttp = "The value `1` is not a valid estimator type."
FindDistributionParameters::nttp = "The value `1` is not a valid estimator type."
EstimatedDistribution::prms = EstimatedProcess::prms = "The parameters to be estimated in `1` are not the same as the parameters in `2`."
FindProcessParameters::notmpl = "Process structure templates are not supported for FindProcessParameters.";
FindDistributionParameters::prms = FindProcessParameters::prms = "The parameters to be estimated in `1` are not the same as the parameters in `2`."
EstimatedDistribution::ntpe = "The value `1` is not a valid ParameterEstimator value. The estimator should be one of \"MaximumLikelihood\", \"MethodOfMoments\", \"MethodOfCentralMoments\", \"MethodOfCumulants\", or \"MethodOfFactorialMoments\"."
FindDistributionParameters::ntpe = "The value `1` is not a valid ParameterEstimator value. The estimator should be one of \"MaximumLikelihood\", \"MethodOfMoments\", \"MethodOfCentralMoments\", \"MethodOfCumulants\", or \"MethodOfFactorialMoments\"."
EstimatedDistribution::mthd = "The Method `1` is not valid for the estimator `2`."
FindDistributionParameters::mthd = "The Method `1` is not valid for the estimator `2`."
EstimatedDistribution::bdmtd = FindDistributionParameters::bdmtd = RandomVariate::bdmtd = "The value `1` is not a valid Method specification."
EstimatedDistribution::mrdln = "The number of moments `1` specified by the \"MomentOrders\" value `2` is not the same as the number of parameters to be estimated `3`."
FindDistributionParameters::mrdln = "The number of moments `1` specified by the \"MomentOrders\" value `2` is not the same as the number of parameters to be estimated `3`."
EstimatedDistribution::mmval = "One or more moments could not be evaluated."
FindDistributionParameters::mmval = "One or more moments could not be evaluated."
EstimatedDistribution::mmindet = "One or more moments evaluated to an infinite or indeterminate value."
FindDistributionParameters::mmindet = "One or more moments evaluated to an infinite or indeterminate value."
EstimatedDistribution::mmfalse = "One or more moment equations returned False."
FindDistributionParameters::mmfalse = "One or more moment equations returned False."
EstimatedDistribution::mmincn = "The moment equations are inconsistent."
FindDistributionParameters::mmincn = "The moment equations are inconsistent."
EstimatedDistribution::nveq = "The number of equations is not the same as the number of parameters."
FindDistributionParameters::nveq = "The number of equations is not the same as the number of parameters."
EstimatedDistribution::prdparm = "Unable to estimate parameters shared by multiple distributions. Estimation of shared parameters is only implemented for identical distributions within ProductDistribution."
FindDistributionParameters::prdparm = "Unable to estimate parameters shared by multiple distributions. Estimation of shared parameters is only implemented for identical distributions within ProductDistribution."
EstimatedDistribution::intprm = "The maximum likelihood estimate cannot be obtained with the specified method because there are integer parameter restrictions."
FindDistributionParameters::intprm = "The maximum likelihood estimate cannot be obtained with the specified method because there are integer parameter restrictions."
EstimatedDistribution::prsntp = "Unable to find a solution for the requested type `1`. Estimation of PearsonDistribution without a specified type may provide a result."
FindDistributionParameters::prsntp = "Unable to find a solution for the requested type `1`. Estimation of PearsonDistribution without a specified type may provide a result."
EstimatedDistribution::prsntp1 = "The solution `1` is not consistent with the requested type `2`. Estimation of PearsonDistribution without a specified type may provide a result."
FindDistributionParameters::prsntp1 = "The solution `1` is not consistent with the requested type `2`. Estimation of PearsonDistribution without a specified type may provide a result."
EstimatedDistribution::binp = "With probability parameter `1` the count parameter `2` cannot be estimated."
FindDistributionParameters::binp = "With probability parameter `1` the count parameter `2` cannot be estimated."
EstimatedDistribution::stvlsunits = "The units of starting values are incompatible with those of the input data and/or target distribution."
FindDistributionParameters::stvlsunits = "The units of starting values are incompatible with those of the input data and/or target distribution."
FindDistributionParameters::noqdrules = "Unable to determine units for the distribution parameters to make unit dimensions of `1` agree with the unit dimensions of the data."
EstimatedDistribution::llfv = FindDistributionParameters::llfv = "The likelihood of `1` with given data does not attain its maximum for finite values of `2`."
EstimatedDistribution::noimpm = FindDistributionParameters::noimpm = "Estimation of `1` is not implemented for the method specified by ParameterEstimator -> `2`."
General::mpestmat = "The dimensions of the estimated Markov matrix must be equal to or greater than the largest state index in the data."
MarkovProcessProperties::invmproc = FirstPassageTimeDistribution::invmproc = "The first argument `1` is not a valid finite-state Markov process."
MarkovProcessProperties::invmprop = "The specified argument `1` is not a valid property for `2`."
General::symsmat = "The transition matrix should be numeric."
LogLikelihood::syminit = "The initial state should be a vector or a positive integer."
DiscreteMarkovProcess::invp0 = ContinuousMarkovProcess::invp0 = HiddenMarkovProcess::invp0 = "The initial state probabilities must be either an integer between 1 and `1` or a non-negative vector of length `1` that sums to 1."
DiscreteMarkovProcess::invsm = HiddenMarkovProcess::invsm = "The state transition matrix must be a non-negative square matrix with rows summing to 1."
ContinuousMarkovProcess::invsm = "The state transition matrix must be square with non-negative off-diagonal elements and with rows summing to 0."
ContinuousMarkovProcess::invqvec = "The transition rate vector is invalid."
HiddenMarkovProcess::invem = "The emission distributions are invalid, or of different types or different dimensionality."
HiddenMarkovProcess::inctem = "The lengths of the transition matrix and list of emissions are inconsistent."
HiddenMarkovProcess::sspath = "There must be a path from each silent state to one or more emitting states."
FindHiddenMarkovStates::impseq = MarkovProcesses`ForwardAlgorithm::impseq = EstimatedProcess::impseq = FindProcessParameters::impseq = "The emission data is inconsistent with the given hidden Markov model."
FindHiddenMarkovStates::nodate = MarkovProcesses`ForwardAlgorithm::nodate = EstimatedProcess::nodate = FindProcessParameters::nodate = LogLikelihood::nodate = Likelihood::nodate = "`1` does not allow times to be specified as dates."
FindHiddenMarkovStates::nopdf = MarkovProcesses`ForwardAlgorithm::nopdf = EstimatedProcess::nopdf = LogLikelihood::nopdf = MarkovProcesses`StateAndEmissionLogLikelihood::nopdf = "The PDF for one or more emission distributions could not be evaluated for the given data."
EstimatedProcess::invpar = FindProcessParameters::invpar = EstimatedDistribution::invpar = FindDistributionParameters::invpar = "The symbolic model has duplicate or invalid parameters."
EstimatedProcess::incsp0 = FindProcessParameters::incsp0 = "The estimated initial state `1` is inconsistent with the one specified in the symbolic process."
EstimatedProcess::sminsfdt = FindProcessParameters::sminsfdt = "There is insufficient data to estimate the transition matrix."
EstimatedProcess::eminsfdt = FindProcessParameters::eminsfdt = "There is insufficient data to estimate the emission distribution for one or more hidden states."
EstimatedProcess::aifail = FindProcessParameters::aifail = "Unable to automatically select initial parameters. Please specify a reasonable initial estimate for the parameters."
EstimatedProcess::supund = FindProcessParameters::supund = "Supervised training requires a TemporalData for the state path to be specified via the StateData option or included as metadata. The default method Automatic will be used."
EstimatedProcess::seuneq = FindProcessParameters::seuneq = "The emission sequence is shorter than the state sequence. In the absence of an initial process, silent states should be specified in the elided form."
EstimatedProcess::cnomsg = FindProcessParameters::cnomsg = "The clustering-based estimation method does not allow Missing values in the data."
EstimatedProcess::invemd = FindProcessParameters::invemd = "The emission distributions computed by the algorithm are invalid. This may indicate that there is not enough data, an underflow occurred, or that other distributions would be a better fit to the data."
EstimatedProcess::uneqft = FindProcessParameters::uneqft = "All of the sequences must start at the same time."
EstimatedProcess::prcdmn = FindProcessParameters::prcdmn = "The dimensionality of the data must match that of the process to be estimated."
EstimatedProcess::invproc = FindProcessParameters::invproc = "Estimated process parameter(s) yielded an invalid process."
EstimatedProcess::vctri = FindProcessParameters::vctri = "Failed to fit the same integration order across all the dimensions. Try relaxing assumptions regarding the vector integration order."
SmoothKernelDistribution::hvtl = "The data contains extreme outliers. Density estimation may fail with automatic settings."
SmoothKernelDistribution::intrp = "The estimate of the density is not smooth enough to interpolate. Try increasing the bandwidth or InterpolationPoints option."
General::bwspc = "The bandwidth specification `1` cannot be used as a fixed bandwidth or in an automatic bandwidth selection method."
General::krfn = "The function `1` should be one of \"Biweight\", \"Cosine\", \"Epanechnikov\", \"Gaussian\", \"Rectangular\", \"SemiCircle\", \"Triangular\", \"Triweight\", or a pure function."
SmoothKernelDistribution::sns = "The adaptive sensitivity setting `1` must be a number between 0 and 1."
SmoothKernelDistribution::intpts = "The InterpolationPoints option value `1` must be an integer or list of integers of length equal to the dimension of the data, with each integer greater than 1."
SmoothKernelDistribution::mxkrn = "The MaxMixtureKernels option value `1` should be an integer greater than 1, All, or a list of such specifications with length equal to the dimension of the data."
SmoothKernelDistribution::mebw = "The MaxExtraBandwidths option value `1` should be a number greater than zero, a list of two such numbers, or a list of such specifications with a length equal to the dimension of the data."
KernelMixtureDistribution::sjbw = "Unable to solve for the Sheather\[Hyphen]Jones bandwidth; Silverman's method will be used."
KernelMixtureDistribution::lscv = "Unable to minimize the least squares cross\[Hyphen]validation function; Silverman's method will be used."
KernelMixtureDistribution::bwspc = "The bandwidth specification `1` cannot be used as a fixed bandwidth or in an automatic bandwidth selection method."
KernelMixtureDistribution::krfn = "The function `1` should be one of \"Biweight\", \"Cosine\", \"Epanechnikov\", \"Gaussian\", \"Rectangular\", \"SemiCircle\", \"Triangular\", \"Triweight\", or a pure function."
KernelMixtureDistribution::invd = "The MaxMixtureKernels option must be All for symbolic data."
KernelMixtureDistribution::invd2 = "The named bandwidth specification `1` requires numeric data and is not compatible with symbolic data."
KernelMixtureDistribution::sns = "The adaptive sensitivity setting `1` must be a number between 0 and 1."
KernelMixtureDistribution::intpts = "The InterpolationPoints option value `1` must be an integer or list of integers of length equal to the dimension of the data, with each integer greater than 2."
KernelMixtureDistribution::mxkrn = "The MaxMixtureKernels option value `1` should be an integer greater than 1, All, a list of real values, or a list of such specifications with length equal to the dimension of the data."
KernelMixtureDistribution::rctt = "A rectangular array is expected at position `2` in `1`."
SurvivalDistribution::trnc = "The argument `1` at position 2 should be a list containing only real numbers and pairs {a,b} such that a is less than b. The list cannot be a constant array."
SurvivalDistribution::espc = "The argument `1` at position `2` should be a list containing only real numbers and pairs {a,b} such that a is less than b. The list cannot be a constant array."
SurvivalDistribution::argln = "The arguments in `1` should be of equal length."
SurvivalDistribution::cspc = "The argument `1` at position {1,1} should contain non-negative real values or lists of non-negative real values of length 1 to 3."
SurvivalDistribution::invd = "The given data cannot be used to represent censored observations."
SurvivalDistribution::invobs = "The observation at `1` cannot be interpreted as a censored observation."
SurvivalDistribution::dropd = "An observation at `1` was dropped because the weight was set to zero."
SurvivalDistribution::newobs = "The weight specification `4` for an observation at `3` caused observations to be added at `2`."
SurvivalDistribution::mthd = "The Method option `1` must be one of Automatic , \"Noncensored\", \"KaplanMeier\", \"SelfConsistency\", or \"IntervalSelfConsistency\"."
SurvivalDistribution::dlmt = "The \"EstimationPoints\" suboption `1` should be a vector of real numbers."
SurvivalDistribution::sbopt = "The suboption `1` should be of the form \"EstimationPoints\" \[Rule] d, where d is a vector of real numbers."
General::cnsls = "Converting censored events from type `2` to type `1` may result in a loss of information."
General::trlss = "Converting truncated events from type `1` to type `2` may result in a loss of information."
SurvivalDistribution::estmtr = "The estimation method `1` is not valid. The automatic method `2` will be used."
SurvivalDistribution::maxit = "The value `1` must be a non-negative integer, Infinity, or Automatic. The value `2` will be used for the option MaxIterations."
EmpiricalDistribution::wtspc = "The argument at position `2` in `1` should be a vector of non-negative values with length equal to the data."
Censoring::invi = "The indicator `1` must be one of 0, 1, -1, Left, Right, or None."
Censoring::indl = "The length `3` of the vector at position 1 and length `2` of the vector at position 2 must be equal."
InverseRadon::bddim = Image`TransformPixelCoordinates::bddim = Radon::bddim = "The specified dimensions `1` should be a pair of positive integers."
Image`TransformPixelCoordinates::pos = "The specified argument `1` should be a list of pairs of numbers."
Image`TransformPixelCoordinates::bdrule = "The specified argument `1` should be of the form s1 \[Rule] s2, where s1 and s2 are names of coordinate systems."
ImageFeatureTrack::bdarg1 = ImageDisplacements::bdarg1 = "The specified argument `1` should be a list of commensurate images."
ImageFeatureTrack::bdmxd = "The value of option \"MaxDistance\" -> `1` should be a positive number or a pair of positive numbers."
ImageFeatureTrack::pos = "The specified points `1` should be a list of positions."
ImageFeatureTrack::bdtol = ImageDisplacements::bdtol = "The value of option Tolerance -> `1` should be a positive number."
ImageDisplacements::flow = "The initial value of the optical flow at position 2 should be an array of real numbers with dimensions `1`."
KarhunenLoeveDecomposition::bdarg1 = "The specified argument `1` should be either a list of commensurate images or an array of real numbers."
KarhunenLoeveDecomposition::bdmtx = "Expecting a transformation matrix with real numbers instead of `1`."
Radon::theta = "The angle specification `1` should be a pair of real numbers or a real number."
Radon::dist = "The distance specification `1` should be a pair of different real numbers."
Radon::ctr = "The center specification `1` should be a pair of real numbers."
InverseRadon::hfilter = "`1` is not a valid filter specification."
InverseRadon::bdproj = "The projection specification `1` should be a positive integer or All."
ChromaticityPlot::clrspace = "The argument `1` is not a color profile, a supported color space, an image, a graphic, a color directive, or a list of them."
ChromaticityPlot::reference = "The argument `1` is not a reference space or a list of a reference space and a brightness value."
ChromaticityPlot::refspace = "The reference space `1` is not a supported color space."
ChromaticityPlot::refbrght = "The brightness `1` should be a number between 0 and 1."
ChromaticityPlot::spctrm = "Accepted values for the Appearance option are \"VisibleSpectrum\", \"FilledVisibleSpectrum\", None, or Automatic."
ChromaticityPlot::style = "Accepted values for the PlotStyle option are \"Filled\", None, a list of them, or Automatic."
ChromaticityPlot::whtpt = ChromaticityPlot3D::whtpt = "Accepted values for the WhitePoint option are All, None, Automatic, a valid color, a supported reference white, or a list of them."
ChromaticityPlot::mppts = ChromaticityPlot3D::mppts = "Value of option MaxPlotPoints -> `1` is not Infinity or a positive integer."
ChromaticityPlot3D::clrspace = "The argument `1` is not a color profile, a supported color space, an image, a graphic, a color directive, or a list of them."
ChromaticityPlot3D::refspace = "The reference space `1` is not a supported color space."
ChromaticityPlot3D::spctrm = "Accepted values for the Appearance option are \"VisibleSpectrum\", None, or Automatic."
ChromaticityPlot3D::style = "Accepted values for the PlotStyle option are None, Automatic, an opacity value, or a list of them."
ChromaticityPlot3D::mesh = "Accepted values for the Mesh option are True, False, or a list of them."
ColorToneMapping::invarg = "Argument `1` should be a range, a pair of a range and a compression factor, or a list of such pairs."
ColorToneMapping::invmth = "`1` is not a supported method. Use \"BaseLuminance\", \"DodgingAndBurning\", \"Luminance\", \"LogLuminance\", or \"RGB\"."
ImageExposureCombine::imginv = ImageFocusCombine::imginv = "`1` should be a list of images."
ColorBalance::invspec = "`1` is not a valid specification."
ColorBalance::invmsk = "The mask specification must have the same size as the original image."
ColorDistance::invarg = "`1` and `2` should be two valid color directives, images, or lists of objects with the same dimensions."
ColorDistance::invdist = ImageRecolor::invdist = "`1` is not Automatic or a valid distance specification."
ColorDistance::tdlen = "Objects of unequal length `1` and `2` cannot be combined."
RandomColor::bdmdl = "`1` is not a valid model specification. Models can be specified through color directives patterns."
RandomColor::bdcol = "`1` should be a supported color space or color directive."
RandomImage::bddist = "The specified random distribution `1` should generate a real number or a list of real numbers."
RandomImage::compat = "The specified color space `1` and the distribution `2` are not compatible."
ConstantImage::bdarg = "The argument `1` should be a machine-sized number, a list of machine-sized numbers, or a valid color directive."
RadialGradientImage::bddim = LinearGradientImage::bddim = ConstantImage::bddim = RandomImage::bddim = "The specified dimensions `1` should be a positive integer or a list of positive integers for every spatial dimensions."
ImageCollage::invarg = "`1` should be a list of images, a list of rules weight -> image, or a rule weights -> images."
ImageCollage::invimg = "Expecting a list of images or graphics instead of `1`."
ImageCollage::invnum = "Expecting a list of positive real numbers instead of `1`."
ImageCollage::bdfit = "`1` is not a valid fitting specification. Accepted values are \"Fit\", \"Fill\", and \"Stretch\""
ImageCollage::bddim = "`1` is not a valid size specification."
ImageCollage::backgr = "The specified value Background -> `1` is not a valid color directive or None."
ImageCollage::bdmtd = "The specified value Method -> `1` is not a valid method specification."
ImageCollage::padsz = "The value of option ImagePadding -> `1` is not a valid padding size specification."
ImageCollage::padding = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or a valid color directive."
WordCloud::invarg = "`1` is not a valid argument. Expecting a list of strings or weighted strings."
WordCloud::invelem = "`1` is not a supported element. The following wrapper can be used: Annotation, Button, EventHandler, Hyperlink, PopupWindow, StatusArea, Style, Tooltip."
WordCloud::invwght = "The weight specification used is invalid. At least one weight must be a positive real number."
WordCloud::invmsk = "`1` is not a valid mask specification. Expecting an Image, a Graphics, a Region, Automatic, or None."
WordCloud::nomem =  "Not enough memory available to compute the word cloud."
RadialGradientImage::invarg = LinearGradientImage::invarg = "The argument `1` should be a rule between positions and gradient color specification; either side of the rule can be omitted."
RadialGradientImage::bdrng = LinearGradientImage::bdrng = "Value of option DataRange -> `1` is not All, Automatic, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
RadialGradientImage::padding = LinearGradientImage::padding = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or a valid color directive."
ImageKeypoints::sys = "ImageKeypoints is not yet available on `1`."
ImageKeypoints::props = "Invalid property specification `1`."
General::maxf = "The value of option MaxFeatures -> `1` should be All, Automatic, Infinity, or a non-negative number."
ImageKeypoints::rthres = "The value of option KeypointStrength -> `1` should be a non-negative number."
HighlightImage::mkinv = ImageForestingComponents::mkinv = WatershedComponents::mkinv = RegionBinarize::mkinv = MeanShift::parti = "Expecting either an image or graphics with dimensions `2` or a list of positions to specify markers instead of `1`."
Thinning::invniter = Pruning::invniter = MorphologicalTransform::invniter = "Expecting a non-negative integer value for the number of iterations."
InverseDistanceTransform::labimginv = Thinning::labimginv = Pruning::labimginv = "`1` is not a valid image nor label matrix."
Thinning::invmethod = "`1` is not a valid method option."
Pruning::opttf = "Invalid method option."
MorphologicalTransform::imglistinv = "`1` is not a valid image nor a list of valid images."
MorphologicalTransform::funcinv = "`1` is not a valid function, nor a rule number, nor a function string, nor a list of the above."
MorphologicalTransform::binimginv = "`1` is not a binary image nor a list of binary images."
HitMissTransform::imgconpad = MorphologicalTransform::imgconpad = MorphologicalBranchPoints::imgconpad = Thinning::imgconpad = Pruning::imgconpad = SkeletonTransform::imgconpad = "`1` is not a valid constant image padding specification."
SkeletonTransform::mtdinv = "The value of option Method->`1` should be \"MedialAxis\" or \"ReducedMedialAxis\"."
MorphologicalBranchPoints::imglistinv = "`1` is not a valid image nor a list of valid images."
MorphologicalBranchPoints::binimglistinv = "`1` is not a valid binary image nor a list of valid binary images."
General::invbvtd = "The argument `1` at position `2` should be a matrix of real numbers of dimension 2 with length greater than 2."
General::invbvtd2 = "The argument `1` at position `2` should be a real number between -1 and 1 or a matrix of real numbers of dimension 2 with length greater than 2."
General::mtrxln =" The argument `1` at position `2` should be a matrix of real numbers with length greater than the dimension of the matrix."
General::rctnln = "The argument `1` at position `2` should be a rectangular array of real numbers with length greater than the dimension of the array."
General::rctnln2 = "The argument `1` at position `2` should be a list containing two rectangular arrays of real numbers where each array has length greater than its dimension."
General::rctnln3 = "The argument `1` at position `2` should be a rectangular array of real numbers with length greater than the dimension of the array or two such arrays."
General::mtrxln3 = "The argument `1` at position `2` should be a matrix of real numbers with length greater than the dimension of the matrix or two such matrices."
General::rctnlnk = "The argument `1` at position `2` should be a list containing two or more rectangular arrays of real numbers where each array has length greater than its dimension."
General::mtrxlnk = "The argument `1` at position `2` should be a list containing two or more matrices of real numbers where each matrix has length greater than its dimension."
General::rctndmln = "The argument `1` at position `2` should be a list containing two rectangular arrays of real numbers where each array has length greater than its dimension."
General::mtrxdmln = "The argument `1` at position `2` should be a list containing two matrices of real numbers where each matrix has length greater than its dimension."
General::rctndmln1 = "The argument `1` at position `2` should be a rectangular array of real numbers with length greater than the dimension of the array or two such arrays with the same dimensions."
General::mtrxdmln1 = "The argument `1` at position `2` should be a matrix of real numbers with length greater than the dimension of the matrix or two such matrices with the same dimensions."
General::rctndmlnk = "The argument `1` at position `2` should be a list containing two or more rectangular arrays of real numbers, each with length greater than the dimension of the array."
General::mtrxdmlnk = "The argument `1` at position `2` should be a list containing two or more matrices of real numbers, each with length greater than the dimension of the matrix."
General::rctnlnm = "The argument `1` at position `2` should be a list containing two rectangular arrays of real numbers of equal length where each array has length greater than its dimension."
General::mtrxlnm = "The argument `1` at position `2` should be a list containing two matrices of real numbers of equal length where each matrix has length greater than its dimension."
General::rctndm = "The argument `1` at position `2` should be a list containing two rectangular arrays of real numbers of equal dimension where each array has length greater than its dimension."
General::mtrxdm = "The argument `1` at position `2` should be a list containing two matrices of real numbers of equal dimension where each matrix has length greater than its dimension."
General::rctndm1 = "The argument `1` at position `2` should be a rectangular array of real numbers with length greater than the dimension of the array or two such arrays of equal dimensionality."
General::mtrxdm1 = "The argument `1` at position `2` should be a matrix of real numbers with length greater than the dimension of the matrix or two such matrices of equal dimensionality."
General::rctndmk = "The argument `1` at position `2` should be a list containing two or more rectangular arrays of real numbers with equal dimensionality, each with length greater than the dimension of the array."
General::mtrxdmk = "The argument `1` at position `2` should be a list containing two or more matrices of real numbers with equal dimensionality, each with length greater than the dimension of the matrix."
General::rctnlnm1 = "The argument `1` at position `2` should be a rectangular array of real numbers with length greater than the dimension of the array or two such arrays of equal length."
General::mtrxlnm1 = "The argument `1` at position `2` should be a matrix of real numbers with length greater than the dimension of the matrix or two such matrices of equal length."
General::rctnlnmk = "The argument `1` at position `2` should be a list containing two or more rectangular arrays of real numbers with equal length, each with length greater than the dimension of the array."
General::mtrxlnmk = "The argument `1` at position `2` should be a list containing two or more matrices of real numbers with equal length, each with length greater than the dimension of the matrix."
General::rctnlndst = "The argument `1` at position `2` should be a valid distribution or a rectangular array of real numbers with length greater than the dimension of the array. The dimensionality of the arguments at positions 1 and `2` must match."
General::vctnln = "The argument `1` at position `2` should be a vector of real numbers with length greater than 1."
General::vctnlnm = "The argument `1` at position `2` should be a vector of real numbers with length greater than 1 or a list containing two such vectors of equal length."
General::vctnln1 = "The argument `1` at position `2` should be a vector of real numbers with length greater than 1 or a list containing two such vectors."
General::vctnlnm2 = "The argument `1` at position `2` should be a list containing two vectors of real numbers of equal length greater than 1."
General::vctnln2 = "The argument `1` at position `2` should be a list containing two vectors of real numbers with length greater than 1."
General::vctnln3 = "The argument `1` at position `2` should be a vector of real numbers with length equal to the vector given in position 1."
General::mtrxln3 = "The argument `1` at position `2` should be a matrix of real numbers with length equal to the vector given in position 1."
General::rctnln4 = "The argument `1` at position `2` should be a rectangular array of real numbers with length equal to the array given in position 1."
General::vctnlnmk = "The argument `1` at position `2` should be a list containing two or more vectors of real numbers of equal length no less than 2."
General::vctnlnk = "The argument `1` at position `2` should be a list containing two or more vectors of real numbers with length no less than 2."
General::vctnln1k = "The argument `1` at position `2` should be a vector of real numbers or a list containing two or more vectors of real numbers with length no less than 2."
General::rctndstr = "The argument `1` at position 1 should be a vector or matrix of real numbers or a multivariate distribution."
General::rctneqln = "The arguments to `1` are not a pair of vectors or matrices of equal length."
General::mtrxeqln = "The arguments to `1` are not a pair of matrices of equal length."
General::invldtd = "The argument `1` cannot be interpreted as valid input data."
General::dgnstcs = "The option value `1` cannot be interpreted as a diagnostic test setting and will be ignored."
General::pvdist = "P-value cannot be computed since the distribution `1` could not be estimated from the given data."
General::nortst = "At least one of the p-values in `1`, resulting from a test for normality, is below `2`. The tests in `3` require that the data is normally distributed."
General::vrnceql = "At least one of the p-values in `1`, resulting from a test for equal variances, is below `2`. The tests in `3` require that the data has equal variances."
General::ntsymmd = "The p-value in `1`, resulting from a test for symmetry, is below `2`. The tests in `3` require that the data is symmetric about a common median."
General::nteqln = "The data is of length `1`. The `2` test is restricted to testing datasets of equal length."
General::ntunf = "The `1` test cannot be used to assess fit to `2`. The `1` test is only useful as a test for uniformity."
General::ties = "Ties exist in the data and will be ignored for the `1` test, which assumes unique values."
General::nrmt = "The `1` test is being used to test fit to `2` but is only valid as a test for normality."
General::htdrng = "The `1` test is only valid for sample sizes between `2` and `3`."
General::unvrt = "The `1` test is not implemented for univariate testing."
General::mtvt = "The `1` test is not implemented for multivariate testing."
General::cnsrngr = "The `1` test cannot be used with censored data."
General::trncr = "The `1` test cannot be used with truncated data."
General::wtddr = "The `1` test cannot be used with weighted data."
General::datcmp = "The tests in `3` require at least `2` datasets for comparison but only `1` is present."
General::tstdm = "There are `2` datasets present, but the tests in `3` require `1` datasets."
General::dscrt = "The p-value returned by the `1` test may not reflect the true size of the test for discrete test distributions."
General::agmtdtk = "At least one of the `2` samples is augmented. The `1` test cannot be used with augmented data."
General::agmtdt2 = "At least one of the `2` samples is augmented. The `1` test cannot be used with augmented data."
General::agmtdt1 = "The data is augmented. The `1` test cannot be used with augmented data."
General::nvldtst = "No valid tests were found under the given assumptions. The `1` test will be used but may produce unreliable results."
General::invprp = "The argument `1` is not a valid property. Specify \"Properties\" to obtain a list of valid properties."
General::tstsz = "The argument `1` is expected to be a number between 0 and 1. The default value of `2` will be used."
General::mthd = "The option value `1` is not a valid method option. The default method `2` will be used."
General::seed = "Argument `1` in `2` should be an integer or a string."
General::altnsp = "The alternative hypothesis `1` is not supported for the `2` test. The value \"Unequal\" will be used."
General::altnsp1 = "The alternative hypothesis `1` is not supported for the `2` test with `3` samples. The value \"Unequal\" will be used."
General::zrvr = "The input data has zero variance. The statistic cannot be computed."
General::dscrtd = "The distribution `1` is discrete. The statistic may not be reliable for discrete distributions."
General::dlngth = "The data is of length `1` but `2` data points are required to compute the statistic."
General::althyp = "The option value `1` should be one of \"Greater\", \"Less\", or \"Unequal\". The default value `2` will be used."
General::sigmnt = "The argument `1` should be a positive number."
General::ksmp = "The tests in `2` are not defined for the `1` sample case."
General::sigksmp = "The argument `1` is ignored for the `2` sample case."
General::nllval = "The argument `1` should be an integer, a real number, or a list of such numbers with length equal to the dimensionality of the data."
General::mvpvl = "The alternative `1` is not supported for the tests in `2` with multivariate data."
General::kwncvr = "The argument `1` should be a positive number or a positive definite matrix with dimension equal to the data."
General::fitfl = "Failed to estimate the parameters in `1`. Verify that all data values are in the domain of `1`."
General::estprm = "The p-value returned by the `1` test is not valid for the `2` when the parameters in `3` have been estimated from the data."
General::wtmthd = "The weight specification `1` at position `2` should be one of \"Equal\", \"Peto\", \"Gehan\", \"AndersenPeto\", \"TaroneWare\", a non-negative real number, or a list containing two such numbers."
General::wfncmp = "The weight specification `1` is not implemented for interval censored data."
General::pstvnt = "The setting for `1` given in `2` should be a positive integer."
General::insdt = "There is insufficient data to estimate the test statistic."
HoeffdingD::dtlnth = "The argument `1` at position `2` is expected to have length greater than 5."
SymletWavelet::word = CoifletWavelet::word = BattleLemarieWavelet::word = "Specified order `1` should be a positive machine integer less than or equal to `2`.";
ShannonWavelet::lim = MeyerWavelet::lim = BattleLemarieWavelet::lim = "Specified limit `1` should be a positive machine integer.";
ReverseBiorthogonalSplineWavelet::odd = BiorthogonalSplineWavelet::odd = "The orders should be both odd or both even.";
DGaussianWavelet::dord = "Specified order of derivative `1` should be a positive machine integer.";
MexicanHatWavelet::width = "Specified width parameter `1` should be a positive machine number.";
GaborWavelet::freq = "Nondimensional frequency parameter `1` should be a positive machine number.";
General::bdwave ="The wavelet specification `1` cannot be used to perform `2`.";
General::bbdwave ="The specification `1` is not a valid wavelet specification recognized by the system.";
General::lprec = "Precision of input `1` is less than WorkingPrecision `2`. Increasing the precision of the input or decreasing WorkingPrecision may improve the result.";
General::wlist="Argument `1` should be one of rectangular array of any depth, image, sound, or sampled sound list.";
General::datl ="Insufficient data length to perform wavelet decomposition using `1`.";
General::wmidi = "Wavelet transform cannot be applied to MIDI notes.";
General::refine="Refinement specification `1` must be Automatic or Full or a nonzero positive machine integer.";
General::maxl ="Refinement specification `1` exceeds maximum allowable decomposition level `2`.";
General::plyout = "Plot layout specification `1` is not valid.";
ContinuousWaveletTransform::pnum = "`1` `2` should be a positive machine number greater than 0.";
ContinuousWaveletData::nvec=ContinuousWaveletTransform::nvec = "Argument `1` is not a non-empty list or vector of numeric quantities, sound, or sampled sound list.";
ContinuousWaveletData::incompatibledata = "`1` object cannot be constructed from complex wavelet data.";
ContinuousWaveletTransform::refine ="Refinement specification `1` must be Automatic or a list of the form {octave, voice} of positive machine integers.";
ContinuousWaveletTransform::wprec = "Requested precision `1` is not a machine-sized real number.";
InverseContinuousWaveletTransform::cwd="First argument `1` to `2` should be a ContinuousWaveletData object.";
DiscreteWaveletData::bpad=StationaryWaveletPacketTransform::bpad = StationaryWaveletTransform::bpad ="`1` is defined for Periodic boundary padding only.";
LiftingWaveletTransform::bpad ="LiftingWaveletTransform is defined for Periodic and numeric padding only.";
LiftingWaveletTransform::bmethod="Option value Method `1` should be one of Automatic or IntegerLifting.";
StationaryWaveletTransform::bmethod = StationaryWaveletPacketTransform::bmethod = "Option value Method `1` should be Automatic.";
InverseWaveletTransform::bmethod = DiscreteWaveletTransform::bmethod = DiscreteWaveletPacketTransform::bmethod = "Option value Method `1` is invalid.";
InverseWaveletTransform::btree = "Inverse wavelet packet transform encountered an invalid best basis tree specification `1`. Recomputing best basis may resolve the issue.";
InverseWaveletTransform::maxlf ="Specified number of refinement levels `2` for the inverse wavelet transform is greater than the total number of refinement levels `1` used for the wavelet decomposition.";
General::bdindex = "Specified index pattern `1` is invalid.";
General::invcwd = "Invalid continuous wavelet data object.";
General::invdwd = "Invalid discrete wavelet data object.";
General::woptx = "Unknown option `1` is not one of `2`.";
General::dwd="First argument `1` to `2` should be a DiscreteWaveletData object.";
General::noprop = "`1` is not a valid property.";
General::nslist = "`1` is not a list of strings."
General::nlist="Argument `1` is not a non-empty list or rectangular array of numeric quantities.";
General::pfilt = "The wavelet specification `1` is not a known built-in wavelet and has not been properly set up as a user-defined wavelet with property `2`.";
General::nfilt = "Computed filter coefficients `1` must contain numeric values.";
General::bind = "Specified index values in filter coefficients `1` must contain integer values.";
Threshold::bdelta = "`1` is not a valid threshold value or method.";
General::fprec = "Precision of filter coefficients `1` is less than WorkingPrecision `2`. Increasing the precision of the filter coefficients or decreasing WorkingPrecision may improve the result."
ContinuousWaveletData::invfr = DiscreteWaveletData::invfr="`1` is an invalid output form.";
ContinuousWaveletData::idxprop = DiscreteWaveletData::idxprop="`1` should be one of valid wavelet index, index pattern, property name, or a list of these.";
ContinuousWaveletData::cdim = "Encountered inconsistent dimensions of input wavelet coefficient rules `1` and `2`; they should be equal.";
ContinuousWaveletData::wrule = "First argument `1` should be a list of rules of the form {{oct,voc}->coef...}, where {oct,voc} are the corresponding octave and voice specification and coef is a non-empty vector of numeric quantities, sound, or sampled sound list.";
LiftingFilterData::idxprop = "`1` is not a valid property.";
DiscreteWaveletData::wrank="Input wavelet coefficient rules have inconsistent ranks `1` and `2`.";
ContinuousWaveletData::datch=DiscreteWaveletData::datch="Input wavelet coefficient rules have inconsistent number of data channels `1` and `2`.";
DiscreteWaveletData::wrule="First argument `1` should be a list of rules of the form {wind->coef...}, where wind is the wavelet index specification and coef is a rectangular array of any depth, image, sound, or sampled sound list.";
DiscreteWaveletData::invcoef="Input wavelet coefficient rules are inconsistent to match any wavelet transform pattern.";
DiscreteWaveletData::wtype="Input wavelet coefficient rules have inconsistent data wrappers `1` and `2`.";
DiscreteWaveletData::ddims="Dimensions of input wavelet coefficient rules are inconsistent to perform `1` using `2`.";
DiscreteWaveletData::idims ="Based on input wavelet coefficient rules, the dimensions of the original data should be `2` instead of `1`.";
DiscreteWaveletData::imgfun = "Invalid function argument `1` was specified. Function argument must be of the form func[img] and should return an image of the same dimension as the input image.";
WaveletBestBasis::wtrans = "DiscreteWaveletData was not computed using a wavelet packet transform.";
WaveletBestBasis::zerocf = "Cost function must have the property CostFunction[{0,0,0,0}]=0.";
WaveletBestBasis::addcf = "Cost function must be additive, i.e., CF([a b]) = CF(a) + CF(b) for all finite length vectors a and b.";
WaveletBestBasis::invcf = "Cost function `1` when applied to a test vector of dimensions {16} did not evaluate to a real number.";
WaveletBestBasis::nobest = "With cost function `1`, there is no wavelet basis with lower cost value than the original data.";
WaveletBestBasis::nvect = "Cost function `1` cannot be applied to non-numeric wavelet coefficients.";
WaveletBestBasis::ftree="Input tree index specification `1` does not form a valid tree.";
WaveletBestBasis::bdelta = "Threshold value `1` should be a positive number.";
WaveletBestBasis::ptype = "Second argument of Norm `1` should be an integer or a real number greater than 0.";
WaveletBestBasis::bwind = InverseWaveletTransform::bwind = "Specified wavelet index `1` is inconsistent. A wavelet index specification is consistent if for each {w_1,...,w_n} that is included no {w_1,...,w_k} for k<n is included.";
WaveletPhi::wconv=WaveletPsi::wconv="Refinement equation failed to converge.";
WaveletPhi::maxrec = WaveletPsi::maxrec = "Warning: MaxRecursion must be a non-negative integer. Using MaxRecursion -> Automatic.";
WaveletPhi::wprop = WaveletPsi::wprop = "Third argument must be one of Dual or Primal.";
WaveletFilterCoefficients::invpro = WaveletPhi::invpro = WaveletPsi::invpro = "Property `1` is not applicable to `2`.";
WaveletFilterCoefficients::wfilt ="Wavelet filter coefficients for `1` are not computable.";
WaveletFilterCoefficients::nsft = "Unable to compute a factorization that satisfies wavelet energy conservation.";
WaveletMapIndexed::invdim = "Dimensions of modified wavelet coefficients do not match the original dimensions of wavelet coefficients.";
WaveletMapIndexed::wd = "Second argument `1` to `2` should be a DiscreteWaveletData or ContinuousWaveletData object.";
WaveletThreshold::method = "`1` is not a valid wavelet thresholding method.";
WaveletThreshold::bdelta = "`1` is not a valid wavelet threshold value.";
WaveletThreshold::gdeg ="Garrote degree `1` should be a positive machine integer.";
WaveletThreshold::nwcoeff = "Wavelet coefficients are not a non-empty list or rectangular array of numeric quantities.";
WaveletThreshold::deltaf = "Thresholding function `1` when applied to wavelet coefficient at wavelet index `2` did not evaluate to a positive number.";
WaveletThreshold::zeromad = "Warning: `1` threshold at wavelet index `2` cannot be computed because median absolute deviation of wavelet coefficients is zero; proceeding with threshold value 0.";
Threshold::gdeg=WaveletThreshold::gdeg = "Degree parameter `1` should be a positive machine integer.";
Threshold::rfirm=WaveletThreshold::rfirm = "Range parameter `1` should be a positive machine number.";
Threshold::param=WaveletThreshold::param = "Thresholding parameter `1` should be a machine number between 0 and 1.";
WaveletMatrixPlot::wtrans=WaveletImagePlot::wtrans = "Pyramid plot layout cannot be constructed for `1`.";
WaveletMapIndexed::sfun = WaveletMatrixPlot::sfun = "Invalid function argument `1` was specified. Function argument must be of the form func[coeff,wind] and should return an array of the same dimension as the input array.";
WaveletMapIndexed::imgfun = WaveletImagePlot::imgfun = "Invalid function argument `1` was specified. Function argument must be of the form func[img,wind] and should return an image of the same dimension as the input image.";
WaveletMatrixPlot::iply = WaveletImagePlot::iply = "Pyramid layout cannot be constructed using inverse coefficients of `1`.";
WaveletImagePlot::bstyle="Specified color `1` is not one of RGBColor, CMYKColor, Hue, or GrayLevel.";
WaveletImagePlot::dch = "Specified data channel `1` should be one of All or a positive machine integer greater than 0 and less than or equal to `2`.";
WaveletMatrixPlot::maxr=WaveletImagePlot::maxr="Specified refinement level `1` must be Automatic or a positive machine integer.";
WaveletListPlot::ncmplx=WaveletMatrixPlot::ncmplx="Noncomplex numerical wavelet coefficients are expected.";
WaveletListPlot::mref="Multiple data objects `1` should have equal refinement levels.";
WaveletListPlot::rank=WaveletMatrixPlot::rank="DiscreteWaveletData was computed using data of rank `1`; data of rank `2` is expected.";
WaveletMatrixPlot::dwrap="DiscreteWaveletData was not computed using a Matrix input.";
WaveletImagePlot::dwrap="DiscreteWaveletData was not computed using an Image input.";
WaveletScalogram::wd = "First argument `1` to `2` should be a DiscreteWaveletData or ContinuousWaveletData object.";
WaveletScalogram::invfunc = "`1` is an invalid scaling function.";
WaveletScalogram::cmplx="Scaling function `1` when applied to the coefficient matrix should generate a real-valued matrix.";
WignerD::list3="List of length 3 is expected at position `2` in `1`.";
General::invsys = "`1` is not a valid TransferFunctionModel, StateSpaceModel, AffineStateSpaceModel, or NonlinearStateSpaceModel."
General::invsys1 = "`1` is not a valid `2`."
General::invsys2 = "`1` is not a valid `2`, or `3`."
General::invsys3 = "`1` is not a valid `2`, `3`, or `4`."
General::invsys4 = "`1` is not a valid `2`, `3`, `4`, or `5`."
General::invss = "`1` is not a valid StateSpaceModel object."
General::invtf = "`1` is not a valid TransferFunctionModel object."
General::noins = "`1` does not have input(s) `2`."
General::noouts = "`1` does not have output(s) `2`."
General::nosts = "`1` does not have state(s) `2`."
StateSpaceModel::tpst = TransferFunctionModel::tpst = "`1` cannot be interpreted as a control object."
StateSpaceModel::tcont = TransferFunctionModel::tcont = "`1` cannot be interpreted as a part of a control object."
StateSpaceModel::tnsq = "Row and column separators in `1` do not yield a square matrix."
StateSpaceModel::nveq = "In attempting to linearize a system of state-space equations, the number of vector components `1` in `2` did not match the number of {variable, value} pairs `3` in `4`."
StateSpaceModel::nsts = "The number of states `1` is less than the number of equations `2`."
StateSpaceModel::mnames = TransferFunctionModel::mnames = "Value of option SystemsModelLabels -> `1` is not None or a vector of names."
StateSpaceModel::shmn = TransferFunctionModel::shmn = "Value of option ShowSystemsModelLabels -> `1` is not True, False, Automatic, or a proper list these values."
StateSpaceModel::farg = "`1` is not a valid systems model or a list of state-space matrices in the form {a, b, ...}."
StateSpaceModel::farglin = "If StateSpaceModel is called with 3 arguments, the first argument `1` is expected to represent the right-hand side(s) of state-space equation(s); it must be a scalar, a vector, or a list of such elements."
StateSpaceModel::farglinm = "If StateSpaceModel is called with 3 arguments, the first argument `1` is expected to represent the right-hand side(s) of state-space equation(s); it must be a scalar, a vector, or a list of such elements. State-space matrices must be supplied as a list {a, b, c}."
StateSpaceModel::fargleq = "If StateSpaceModel is called with 5 or 6 arguments, the first argument `1` is expected to represent state-space equation(s); it must be an equation or a system of equations."
StateSpaceModel::bop = "If StateSpaceModel is called with 3 or more arguments, the argument `1` in position `2` represents a variable, a list of variables, or the operating point for linearization. In the latter case, it must be a list of pairs {{variable, value}, ...}."
StateSpaceModel::bopm = "If StateSpaceModel is called with 3 or more arguments, the argument `1` in position `2` represents a variable, a list of variables, or the operating point for linearization. In the latter case, it must be a list of pairs {{variable, value}, ...}. State-space matrices must be supplied as a list {a, b, c}."
StateSpaceModel::eqarg = "To create a state-space object from equations, StateSpaceModel must be called with at least 5 arguments."
StateSpaceModel::fourargm = "StateSpaceModel called with 4 arguments; a list of state-space matrices {a, b, c, d} is expected."
StateSpaceModel::fourarg = "StateSpaceModel called with 4 arguments; fewer arguments are expected unless the first argument is an equation or a system of equations."
StateSpaceModel::twoarg = "StateSpaceModel called with 2 arguments; 1, 3, or more arguments are expected."
StateSpaceModel::twoargm = "StateSpaceModel called with 2 arguments; 1, 3, or more arguments are expected. State-space matrices must be supplied as a list {a, b}."
StateSpaceModel::rlt = "The target realization type `1` is not \"Controllable\", \"ControllableCompanion\", \"Observable\", \"ObservableCompanion\", or Automatic."
StateSpaceModel::rltg = "The target realization type cannot be specified for pure-gain systems. The requested type `1` will be ignored."
StateSpaceModel::rlte = "Value of option StateSpaceRealization -> `1` is ignored when constructing state-space models from objects other than TransferFunctionModel or ZeroPoleGainModel."
StateSpaceModel::indep = "Linearization has produced zero-valued matrices."
StateSpaceModel::nosol = "Linearized equations `1` do not appear to have solution for `2`. Try supplying variables to eliminate."
StateSpaceModel::nosolelim = "Linearized equations `1` do not appear to have solution for `2` after eliminating variables `3`."
StateSpaceModel::impr = "Improper transfer function `1` cannot be converted to a standard state-space object."
StateSpaceModel::ctcf = "Unable to extract polynomial coefficient list."
StateSpaceModel::nioss = "Cannot create a state-space model for a system `1` with no inputs and outputs."
StateSpaceModel::type = "`1` is already a state-space model. You can use StateSpaceTransform to find another realization."
TransferFunctionModel::resf = "The highest power term `1` in the resolvent matrix expansion is not a zero matrix. The result may be inaccurate."
TransferFunctionModel::mvr = "`1` is not a transfer-function model in one variable."
TransferFunctionModel::method = "Value of option Method -> `1` is not Automatic, \"DeterminantExpansion\", \"ResolventIdentities\", \"Inverse\", or Generic."
TransferFunctionModel::farg = "`1` is not a valid systems model; a scalar; a vector; a matrix; a triplet {z, p, g} that represents zeros, poles, and gains of the transfer matrix; or a list of the form {num, den}, where num is a matrix of numerators and den is either a scalar or a matrix of denominators."
TransferFunctionModel::fargs = "The first argument `1` cannot be interpreted as a polynomial matrix in `2`."
ZeroPoleGainModel::delay="ZeroPoleGainModel does not support time delays."
General::nddim = "Numerator and denominator matrices of `1` do not have the same dimensions."
General::npnum = "Expression `1` at position `2` in `3` is not a matrix of polynomials in `4`."
General::npden = "Expression `1` at position `2` in `3` is neither a polynomial nor a matrix of polynomials in `4`."
General::irregss = "A solution could not be found for the irregular state-space model with a characteristic equation of zero."
General::nlinss = "The state-space model `1` is nonlinear."
TransferFunctionModel::npnd = "Unable to automatically separate polynomial numerators and denominators in `1`. Try simplifying the object."
Control`ZeroPoleGainModel::farg = "`1` is not a valid TransferFunctionModel or StateSpaceModel object or list of the form {z, p, g}."
SystemsModelDimensions::inco = SystemsModelOrder::inco = ToDiscreteTimeModel::inco = ToContinuousTimeModel::inco = "The object `1` is inconsistent."
SystemsModelOrder::nspt = "SystemsModelOrder does not currently support `1` objects."
SystemsModelOrder::fracdel = "SystemsModelOrder does not support fractional time-delay systems."
StateSpaceModel::ivard = "`1` do not appear to be functions in the independent variable `2`."
StateSpaceModel::ivars = "`1` is not a list of valid variable(s)."
StateSpaceModel::svars = "Unable to find solutions for all the requested variables `1`."
StateSpaceModel::bsol = "The created state-space matrices may not be correct. Try supplying vector(s) of right-hand sides of the state-space equations."
StateSpaceModel::imerr = "A state-space realization could not be found for the improper transfer function."
StateSpaceModel::nolindel = "The time delays could not be separated into linear delays of the inputs, outputs, states, and state derivatives."
StateSpaceModel::nolindel = "The time delays could not be separated into linear delays of the inputs, outputs, states, and state derivatives."
TransferFunctionModel::dvar = "`1` is interpreted as a transfer-function matrix in the variable `2`."
StateResponse::incinit = "A consistent initial condition could not be found for the given system and input."
StateResponse::acausal = "A solution could not be found because the system is acausal."
StateResponse::nsymb = OutputResponse::nsymb = Control`OutputResponsePlot::nsymb = "`1` must be a symbol."
StateResponse::symbs = OutputResponse::symbs = Control`OutputResponsePlot::symbs = "Cannot simulate response of system `1` that contains symbolic parameter(s)."
StateResponse::symbu = OutputResponse::symbu = Control`OutputResponsePlot::symbu = "Cannot simulate response to input `1` that contains symbolic parameter(s)."
OutputResponse::stresp = Control`OutputResponsePlot::stresp = "Cannot simulate output response because the computed state response `1` is not a list of proper dimensions."
StateResponse::symbt = OutputResponse::symbt = Control`OutputResponsePlot::symbt = DiscreteLQRegulatorGains::symbt = DiscreteLQEstimatorGains::symbt = "Sampling period `1` does not have a numeric value."
StateResponse::symbi = OutputResponse::symbi = Control`OutputResponsePlot::symbi = "Initial conditions `1` include non-numerical value(s)."
StateResponse::cntd = OutputResponse::cntd = Control`OutputResponsePlot::cntd = "Cannot compute the response of a continuous-time system `1` to a discrete input sequence `2`. Either discretize the system or construct a continuous signal."
StateResponse::dscc = OutputResponse::dscc = Control`OutputResponsePlot::dscc = "Cannot compute the response of a discrete-time system `1` to a continuous input signal `2`. Either approximate the system by a continuous-time model or discretize the input signal."
StateResponse::binit = OutputResponse::binit = Control`OutputResponsePlot::binit = "The initial condition specification in `1` must be a vector or a scalar."
StateResponse::tfinc = OutputResponse::tfinc = Control`OutputResponsePlot::tfinc = "For TransferFunctionModel objects, the initial conditions are assumed to be zero. The value `1` will be ignored."
Control`OutputResponsePlot::ndlim = "Range specification `1` is not of the form {t, tmax} or {t, tmin, tmax}."
StateResponse::method = OutputResponse::method = Control`OutputResponsePlot::method = "The method `1` is not Automatic, DSolve, or Integrate."
StateResponse::dmethod = OutputResponse::dmethod = Control`OutputResponsePlot::dmethod = "The method `1` is not Automatic, RSolve, or Sum."
StateResponse::nuniq = "`1` has not produced a unique solution."
StateResponse::timev = OutputResponse::timev = "Matrix `1` in `2` depends on time variable `3`. Computation of state responses for the time-varying case is not currently implemented."
StateResponse::symb = "Computing exact or symbolic state response by iteration may require substantial resources."
StateResponse::binit2="The initial condition `1` is invalid."
StateResponse::inithist="The model contains a time delay of `1`, but the initial condition only has `2` time-steps of history. Earlier history is assumed to be `3`."
StateResponse::delays = "The system `1` contains time delays. An exact simulation is not possible; try simulating over a time span."
OutputResponse::delays = "The system `1` contains time delays. An exact simulation is not possible; try simulating over a time span."
StateResponse::negdel = "The system with negative time delay `1` may not give a solution."
OutputResponse::negdel = "The system with negative time delay `1` may not give a solution."
StateResponse::negdelayss = "The system `1` contains negative time delays that cannot be simulated."
OutputResponse::negdelayss = "The system `1` contains negative time delays that cannot be simulated."
StateResponse::ddinc="The initial condition given for the descriptor system is inconsistent; a consistent value will be used instead."
StateResponse::initcn2="The number of states `1` does not match the number of initial conditions in `2`."
StateResponse::delaysm="The system contains time delays. An exact simulation is not possible; try simulating over a time span."
StateResponse::method2="The method `1` is not a known method."
StateResponse::nldelays="Delays are not supported in `1` simulations; try using a StateSpaceModel."
StateResponse::singmeth="The method `1` does not support systems with descriptor matrices. Try another method."
StateResponse::delayrec="The RecurrenceTable method does not support time delays; try using the Iterate method instead."
StateResponse::singdif="The input signal `1` is not continuously differentiable enough times for the singular system."
StateResponse::tempdt0="The start time in the input signal, `1`, is after the start time of the simulation, `2`."
StateResponse::tempdtf="The end time in the input signal, `1`, is before the end time of the simulation, `2`."
StateResponse::methodtd="The method `1` cannot be used for TemporalData inputs."
StateResponse::tdsamp="The time values in the TemporalData input are not equally spaced, so the discrete-time system cannot use them."
StateResponse::tdsamp2="The sampling rate of the TemporalData input is different than the SamplingPeriod of the system. The TemporalData time values will not be used."
StateResponse::daeinit="Some initial conditions were inconsistent for the given descriptor system and inputs. Consistent values will be used instead."
StateResponse::symbs2="Cannot simulate response of the `1` and initial conditions that contain symbolic parameter(s) `2`."
StateResponse::incinit2="The given initial conditions are not consistent with the input; consistent values will be used instead."
OutputResponse::incinit2="The given initial conditions are not consistent with the input; consistent values will be used instead."
OutputResponse::ddinc="The initial condition given for the descriptor system is inconsistent; a consistent value will be used instead."
OutputResponse::initcn2="The number of states `1` does not match the number of initial conditions in `2`."
OutputResponse::delaysm="The system contains time delays. An exact simulation is not possible; try simulating over a time span."
OutputResponse::method2="The method `1` is not a known method."
OutputResponse::nldelays="Delays are not supported in `1` simulations; try using a StateSpaceModel."
OutputResponse::singmeth="The method `1` does not support systems with descriptor matrices. Try another method."
OutputResponse::delayrec="The RecurrenceTable method does not support time delays; try using the Iterate method instead."
OutputResponse::singdif="The input signal `1` is not continuously differentiable enough times for the singular system."
OutputResponse::tempdt0="The start time in the input signal, `1`, is after the start time of the simulation, `2`."
OutputResponse::tempdtf="The end time in the input signal, `1`, is before the end time of the simulation, `2`."
OutputResponse::methodtd="The method `1` cannot be used for TemporalData inputs."
OutputResponse::tdsamp="The time values in the TemporalData input are not equally spaced, so the discrete-time system cannot use them."
OutputResponse::tdsamp2="The sampling rate of the TemporalData input is different than the SamplingPeriod of the system. The TemporalData time values will not be used."
OutputResponse::daeinit="Some initial conditions were inconsistent for the given descriptor system and inputs. Consistent values will be used instead."
OutputResponse::symbs2="Cannot simulate response of the `1` and initial conditions that contain symbolic parameter(s) `2`."
ControllableDecomposition::espc = "Controllable subspace in `1` is empty."
ObservableDecomposition::espc = "Observable subspace in `1` is empty."
ControllableDecomposition::dfail = ObservableDecomposition::dfail = "Unable to find the Kalman decomposition using method `1`."
ControllableDecomposition::tsm = ObservableDecomposition::sm = "`1` element(s) that are smaller than the tolerance `2` were encountered after computing `3`."
ControllableDecomposition::method = ObservableDecomposition::method = "The method `1` is not \"Kalman\" or Automatic."
ControllableDecomposition::kmtd = ObservableDecomposition::kmtd = "The method `1` is not \"SingularValues\", \"RowReduce\", \"NullSpace\", or Automatic."
InternallyBalancedDecomposition::method = "The method `1` is not \"Eigensystem\", \"SingularValues\", or Automatic."
TransferFunctionCancel::nzpm = "No common pole-zero pairs found in `1`."
TransferFunctionCancel::delays="TransferFunctionCancel could not find the pole and zero locations in the time-delay system `1`."
TransferFunctionFactor::delay="The system `1` contains time delays. TransferFunctionFactor will not provide the poles and zeros."
TransferFunctionFactor::delayd="The delays in the discrete-time system `1` will be converted to poles."
TransferFunctionFactor::delayd2="The discrete-time system `1` with non-integer delays cannot be factored."
TransferFunctionPoles::delay="The poles of the time-delay system could not be found in the given region."
TransferFunctionZeros::delay="The zeros of the time-delay system could not be found in the given region."
MinimalStateSpaceModel::nsc = "No states deleted in `1`."
InternallyBalancedDecomposition::nobs = "The system `1` is not observable."
InternallyBalancedDecomposition::delays="InternallyBalancedDecomposition does not support time-delay systems."
Internal`PoleAssignment::nctrl = InternallyBalancedDecomposition::nctrl = "The system `1` is not controllable."
Internal`PoleAssignment::nctrl1 = "The system `1` is likely uncontrollable or nearly uncontrollable."
InternallyBalancedDecomposition::bcnd = "Cannot compute the internally balanced decomposition of `1` because an ill-conditioned or singular matrix was encountered."
ControllableModelQ::moptx = ObservableModelQ::moptx = "Method option `1` is not \"Matrix\", \"Gramian\", \"PBH\", \"Distribution\", or a list of such values."
ControllableModelQ::mbool = ObservableModelQ::mbool = "Method function `1` returned `2`, which is not True or False."
ControllableModelQ::uns = "The controllability Gramian is not defined because `1` is unstable."
ObservableModelQ::uns = "The controllability Gramian is not defined because `1` is unstable."
ControllabilityGramian::uns = "The controllability Gramian is not defined because `1` is unstable."
ControllabilityGramian::nosvd = "The controllability Gramian cannot be computed within the tolerance `` because the singular value list of `` is empty."
ObservabilityGramian::uns = "The observability Gramian is not defined because `1` is unstable."
SystemsModelSeriesConnect::nolbl = SystemsModelParallelConnect::nolbl = SystemsModelFeedbackConnect::nolbl = SystemsModelStateFeedbackConnect::nolbl = Control`SystemsModelConnect::nolbl = SystemsModelExtract::nolbl = SystemsModelDelete::nolbl = "The label `1` is not one of `2`."
SystemsModelSeriesConnect::lblspec = SystemsModelParallelConnect::lblspec = SystemsModelFeedbackConnect::lblspec = SystemsModelStateFeedbackConnect::lblspec = Control`SystemsModelConnect::lblspec = SystemsModelExtract::lblspec = SystemsModelDelete::lblspec = "Unknown label `1` encountered."
SystemsModelFeedbackConnect::dimout = "The system `1` has only `2` of required `3` outputs."
SystemsModelFeedbackConnect::dimin = "The system `1` has only `2` of required `3` inputs."
SystemsModelFeedbackConnect::iomm1 = "The number of inputs and outputs do not match."
SystemsModelSeriesConnect::iomm = SystemsModelFeedbackConnect::iomm = "The number of inputs in `1` does not match the number of outputs in `2`."
SystemsModelParallelConnect::iomm = "The systems `1` and `2` do not match."
StateResponse::initcn = "The number of states in `1` does not match the number of initial conditions in `2`."
SystemsModelSeriesConnect::nsdom = SystemsModelParallelConnect::nsdom = SystemsModelFeedbackConnect::nsdom = Control`SystemsModelConnect::nsdom = Control`SystemsModelMerge::nsdom = "Systems `1` do not appear to be in the same domain."
SystemsModelSeriesConnect::dupinp = "Cannot connect multiple outputs to the same input `1`."
SystemsModelParallelConnect::dupinp = "Cannot connect input `1` to multiple inputs."
SystemsModelParallelConnect::dupout = "Cannot connect output `1` to multiple outputs."
SystemsModelStateFeedbackConnect::reseteq="The system was transformed to move the equilibrium points of the connected inputs to zero."
SystemsModelFeedbackConnect::reseteq="The system was transformed to move the equilibrium points of the connected inputs to zero."
SystemsModelParallelConnect::reseteq="The systems were transformed to match the equilibrium points of the connected inputs."
SystemsModelSeriesConnect::reseteq="The second system was transformed to move the equilibrium points of the connected inputs to zero."
LQGRegulator::cdim = EstimatorRegulator::cdim = "The number of control inputs `1` does not match the number of rows in `2`."
EstimatorRegulator::mdim = StateOutputEstimator::mdim = KalmanEstimator::mdim = LQGRegulator::mdim = "The number of measured outputs `1` does not match the number of columns in `2`."
ToDiscreteTimeModel::dtsys = DiscreteLQRegulatorGains::dtsys = DiscreteLQEstimatorGains::dtsys = "`1` is a discrete-time system. A continuous-time system is expected."
ToContinuousTimeModel::ctsys = "`1` is a continuous-time system. A discrete-time system is expected."
ToContinuousTimeModel::mlogc = "Possible poor conversion in computing `1`."
ToContinuousTimeModel::ctfld = "Unable to find a continuous-time approximation of `1` using the method `2`."
ToContinuousTimeModel::trfld = "Cannot compute `1` with assumptions `2`."
ToContinuousTimeModel::delays="The method `1` does not support time-delay systems."
ToDiscreteTimeModel::delays="The method `1` does not support time-delay systems."
ToDiscreteTimeModel::sposprm = "Parameter `1` at position `2` in `3` is expected to be positive or symbolic."
ToDiscreteTimeModel::method = ToContinuousTimeModel::method = "The method `1` is not \"ZeroOrderHold\", \"FirstOrderHold\", \"ForwardRectangularRule\", \"BackwardRectangularRule\", \"BilinearTransform\", \"ZeroPoleMapping\", or Automatic."
ToDiscreteTimeModel::ssni = ToContinuousTimeModel::ssni = "A state-space conversion is not implemented for method `1`. Use \"StateSpaceConversion\" -> False or \"StateSpaceConversion\" -> Automatic."
ToDiscreteTimeModel::ssc = ToContinuousTimeModel::ssc = "A conversion to a state-space object is not needed for `1`. The setting \"StateSpaceConversion\" -> `2` is ignored."
ToDiscreteTimeModel::aff = "Unable to automatically choose the critical frequency for Method -> `1`. Try specifying the value for \"CriticalFrequency\" or choose a different method."
ToDiscreteTimeModel::cfv = "Value of option \"CriticalFrequency\" -> `1` is not Automatic, None, or a valid expression."
ToDiscreteTimeModel::npdelay = "Unable to ascertain `1` >= 0"
ToDiscreteTimeModel::dtrdelay = "Unable to handle the system `1` with nonzero delay and nonzero direct transmission term."
ToDiscreteTimeModel::npsp = "Sampling period `1` must be a positive number or a variable that represents such a number."
ToDiscreteTimeModel::tfdel=ToContinuousTimeModel::tfdelc="The option \"StateSpaceConversion\"->`1` is not supported for time-delay TransferFunctionModels."
ToDiscreteTimeModel::zpmdel=ToContinuousTimeModel::zpmdel="The option Method->`1` is not supported for time-delay systems."
General::samplp = "Sampling period `1` must be None, a positive number, or a variable that represents such a number."
ToDiscreteTimeModel::bfr = "Cannot match gains at frequency `1`. The response at the critical frequency cannot be zero."
Internal`PoleAssignment::method = StateFeedbackGains::method = "The method `1` is not \"Ackermann\", \"KNVD\", or Automatic."
Internal`PoleAssignment::bcnd = StateFeedbackGains::bcnd = "A badly conditioned matrix was encountered. The \"KNVD\" method failed."
Internal`PoleAssignment::ncl = StateFeedbackGains::ncl = "The set `1` does not appear to be closed under complex conjugation."
Internal`PoleAssignment::infp = StateFeedbackGains::infp = "Unable to apply the \"KNVD\" method to an infinite precision system `1` and exact poles `2`."
Internal`PoleAssignment::cnvp = StateFeedbackGains::cnvp = "Unable to verify the location of poles."
Internal`PoleAssignment::bpl = StateFeedbackGains::bpl = "A pole location may deviate from the required one by more than `1`%."
Internal`PoleAssignment::nctsi = StateFeedbackGains::nctsi = "Cannot find a feedback gain matrix for controlling `1` from any single input."
StateFeedbackGains::delays=EstimatorGains::delays="Time-delay systems are not supported by pole placement functions"
StateFeedbackGains::idime2 = "The system does not have `1` controllable states."
StateFeedbackGains::idime = "The number of specified poles `1` does not match the rank of the descriptor matrix `2` or the slow subsystem `3`."
EstimatorGains::idime2 = "The system does not have `1` observable states."
EstimatorGains::idime = "The number of specified poles `1` does not match the rank of the descriptor matrix `2` or the slow subsystem `3`."
Internal`PoleAssignment::tmmp = StateFeedbackGains::tmmp = "The multiplicity of poles `1` exceeds the number of inputs `2`."
LQRegulatorGains::invarg1 = LQOutputRegulatorGains::invarg1 =LQEstimatorGains::invarg1 = KalmanEstimator::invarg1 = "`1` and `2` are not a valid pair of StateSpaceModel object and weighting matrices."
LQRegulatorGains::invarg2 = LQOutputRegulatorGains::invarg2 = LQEstimatorGains::invarg2 = KalmanEstimator::invarg2 = "`1`, `2`, and `3` are not a valid triad of StateSpaceModel object, weighting matrices, and `` indices."
LQEstimatorGains::zpn = DiscreteLQEstimatorGains::zpn = KalmanEstimator::zpn = LQGRegulator::zpn = "Deterministic input(s) All or `` expected with process noise covariance matrix {{}}."
LQEstimatorGains::zpn1=KalmanEstimator::zpn1=DiscreteLQEstimatorGains::zpn1=LQGRegulator::zpn1="Process noise covariance matrix {{}} expected with deterministic input(s) All or `` ."
LQRegulatorGains::delays=LQOutputRegulatorGains::delays=LQEstimatorGains::delays=KalmanEstimator::delays=DiscreteLQRegulatorGains::delays=DiscreteLQEstimatorGains::delays=LQGRegulator::delays="Time-delay systems are not supported in optimal control functions."
StateOutputEstimator::invarg1 = "`1` and `2` are not a valid pair of StateSpaceModel object and estimator gain matrix."
StateOutputEstimator::invarg2 = "`1`, `2`, and `3` are not a valid triad of StateSpaceModel object, estimator gain matrix, and sensor indices."
StateOutputEstimator::invarg3 = "`1`, `2`, `3`, and `4` are not a valid set of StateSpaceModel object, estimator gain matrix, sensor, and deterministic input indices."
DiscreteLQRegulatorGains::invarg1 =DiscreteLQEstimatorGains::invarg1 = "`1`, `2`, and `` are not a valid set of StateSpaceModel object, numerical sampling period, and weighting matrices."
DiscreteLQRegulatorGains::invarg2 =DiscreteLQEstimatorGains::invarg2 = "`1`, `2`, `3`, and `4` are not a valid set of StateSpaceModel object, numerical sampling period, weighting matrices, and `5` indices."
DiscreteLQRegulatorGains::invarg3 = DiscreteLQEstimatorGains::invarg3 = "`1`, `2`, `3`, `4`, and `5` are not a valid set of StateSpaceModel object, numerical sampling period, weighting matrices, and `6` indices."
LQOutputRegulatorGains::invarg3 = "`1`, `2`, `3`, and `4` are not a valid set of StateSpaceModel object, weighting matrices, sensor, and feedback input indices."
LQEstimatorGains::invarg3 = KalmanEstimator::invarg3 = "`1`, `2`, `3`, and `4` are not a valid set of StateSpaceModel object, weighting matrices, sensor, and deterministic input indices."
LQRegulatorGains::dupin=LQOutputRegulatorGains::dupin=DiscreteLQRegulatorGains::dupin= LQEstimatorGains::dupin= DiscreteLQEstimatorGains::dupin= LQGRegulator::dupin= EstimatorRegulator::dupin= StateOutputEstimator::dupin=KalmanEstimator::dupin= "`` contains duplicate indices."
LQEstimatorGains::corr = KalmanEstimator::corr = LQGRegulator::corr ="Cross-covariance matrix can be specified only for systems without direct transmission of process noise to measured outputs."
LQEstimatorGains::nomeasr = DiscreteLQEstimatorGains::nomeasr = KalmanEstimator::nomeasr = StateOutputEstimator::nomeasr = LQGRegulator::nomeasr = LQOutputRegulatorGains::nomeasr = EstimatorRegulator::nomeasr = EstimatorGains::nomeasr = "At least one sensor must be specified."
LQRegulatorGains::nofinp = LQOutputRegulatorGains::nofinp = DiscreteLQRegulatorGains::nofinp = LQGRegulator::nofinp = EstimatorRegulator::nofinp = StateFeedbackGains::nofinp = "At least one feedback input must be specified."
StateSpaceModel::bdsys = AffineStateSpaceModel::bdsys = NonlinearStateSpaceModel::bdsys = "Unable to determine if the model is that of a continuous-time or discrete-time system."
StateSpaceModel::invrlzn = "Cannot construct a state-space realization for the system of equations `1` with variables `2`, inputs `3`, and outputs `4`."
StateSpaceModel::sing = AffineStateSpaceModel::sing = NonlinearStateSpaceModel::sing = "The descriptor matrix `1` is singular."
StateSpaceModel::noarg = "`1` is not of the form `1`[`2`]."
StateSpaceModel::bdvar = "`1` is an incorrect specification for a dependent variable."
RootLocusPlot::dkts = "The plot of the root loci has a discontinuity at `1`==`2`."
RootLocusPlot::bdmtd = "The value of the option Method -> `1` is not Automatic, \"GenericSolve\", or \"NDSolve\"."
RootLocusPlot::invpzm = "`1` is an invalid specification for the PoleZeroMarkers option."
RootLocusPlot::delays = "RootLocusPlot does not support systems with delays in the closed-loop characteristic equation."
NyquistPlot::nsingf = "No singular frequencies found for `1`."
NyquistPlot::scinf = "The semicircles at infinity could not be plotted for `1`. Try changing the PlotPoints or PlotRange value."
NyquistPlot::circtn = "The conditions to apply the circle criterion do not hold with FeedbackType -> `1` and FeedbackSector -> `2`."
BodePlot::llplim = SingularValuePlot::llplim = "Range specification `1` is not of the form {fmin, fmax} with fmin and fmax positive."
BodePlot::invfreq = SingularValuePlot::invfreq = NicholsPlot::invfreq = NyquistPlot::invfreq = "`1` is an invalid frequency range."
GainPhaseMargins::tolnn = GainMargins::tolnn = PhaseMargins::tolnn = Control`GainCrossoverFrequency::tolnn = Control`PhaseCrossoverFrequency::tolnn = "Tolerance specification `1` must be a non-negative number."
LQRegulatorGains::invwts=LQOutputRegulatorGains::invwts=DiscreteLQRegulatorGains::invwts = LQGRegulator::invwts = "Argument `1` at position `2` cannot be interpreted as a list of valid weighting matrices."
LQEstimatorGains::invcov=KalmanEstimator::invcov=DiscreteLQEstimatorGains::invcov= LQGRegulator::invcov= "Argument `1` at position `2` cannot be interpreted as a list of valid noise covariance matrices."
LQRegulatorGains::invin= LQOutputRegulatorGains::invin=DiscreteLQRegulatorGains::invin=LQEstimatorGains::invin=KalmanEstimator::invin= StateOutputEstimator::invin=EstimatorRegulator::invin= DiscreteLQEstimatorGains::invin= LQGRegulator::invin="`1` in argument `2` cannot be interpreted as a valid index or indices."
StateOutputEstimator::invgn= "Argument `1` at position `2` cannot be interpreted as a valid `3` gain matrix."
EstimatorRegulator::invgn= "Argument `1` at position `2` cannot be interpreted as valid `3` gain matrices."
LQGRegulator::invgn= "Cannot compute estimator and feedback gains from the supplied covariance and weighting matrices."
LQGRegulator::invargs= "Cannot construct an optimal regulator from the supplied arguments."
MinimalStateSpaceModel::delays="MinimalStateSpaceModel does not support time-delay systems."
JordanModelDecomposition::delays="JordanModelDecomposition does not support time-delay systems."
JordanModelDecomposition::singe="JordanModelDecomposition does not support singular systems; try KroneckerModelDecomposition."
KroneckerModelDecomposition::jord ="Unable to find the Jordan decomposition of the matrix with the given precision."
KroneckerModelDecomposition::ssmodel="A StateSpaceModel was expected instead of `1`."
SystemsModelDelaysApproximate::meth = "The option Method->`1` is invalid for continuous-time systems."
SystemsModelDelaysApproximate::methd = "The option Method->`1` is invalid for discrete-time systems."
SystemsModelDelaysApproximate::symbdel = "Symbolic delays will not be approximated; try specifying an approximation order."
Control`SystemsModelConnect::invcon1 = "The connection specification `1` is invalid."
Control`SystemsModelConnect::invind="`1` `2` is not valid."
Control`SystemsModelConnect::invin="Input `1` does not exist."
Control`SystemsModelConnect::invcon="The specified connections are invalid."
Control`SystemsModelConnect::invout="Output `1` does not exist."
Control`SystemsModelConnect::dupname="The connections are ambiguous due to the multiply-defined label `1`."
Control`SystemsModelConnect::dupvar="The connections are ambiguous due to the multiply-defined variable `1`."
Control`SystemsModelConnect::inputdef = "The input `1` is defined more than once."
Control`SystemsModelConnect::ioind = "The system `1` does not have the specified input or output `2`."
Control`SystemsModelMerge::dupvar="The merge is ambiguous due to the multiply-defined variable `1`."
General::icdims = "`1` has incompatible dimensions."
General::varslen = "The variables specification `1` is not of length `2`."
General::invvarsp = "`1` is an invalid specification. Possible variable specifications are var, {var, var0}, var->var0."
General::smdims = "Could not determine the `1` dimensions."
General::autovar = "Automatic generation of variables failed."
General::badtrans = "Unable to compute the inverse of the transformation `1`."
General::invtrans = "The transformation `1` does not have a correct inverse."
General::jtrans = "The Jacobian of the transformation does not have full rank."
General::ptrans = "Only a partial transformation `1` could be computed."
General::smelem = "The element `1` of the systems model is invalid."
General::ssmconv = "Conversion of `1` failed."
General::inplin = "`1` is not an input-linear system."
General::drtrz = "The direct transmission matrix `1` is not a zero matrix."
General::drtrc = "The direct transmission matrix `1` is not a constant matrix."
AffineStateSpaceModel::farg = "`1` is not a valid systems model or a list of the form {a, b, ...}."
NonlinearStateSpaceModel::farg = "`1` is not a valid systems model or a list of the form {f, ...}."
StateSpaceModel::delvar = AffineStateSpaceModel::delvar = NonlinearStateSpaceModel::delvar = "A state, input, output, or temporal variable can use the systems model delay variable `1`."
StateSpaceModel::desopt = AffineStateSpaceModel::desopt = "The value of option DescriptorStateSpace -> `1` must be Automatic, True, or False."
CarlemanLinearize::bdarg1 = "The first argument `1` is not a valid specification of an affine state-space model or an analytic function."
FeedbackLinearize::newvars = "The new state and feedback variables `1` is not specified as a list {new state variables, new feedback variables}."
FeedbackLinearize::bdmtd = "The value of option Method -> `1` is neither Automatic, \"Burnovsky\", or \"Identity\"."
FeedbackLinearize::idmtd = StateTransformationLinearize::idmtd ="The \"Identity\" method is not appropriate for the nonlinear model `1`."
FeedbackLinearize::bnky = "Unable to assemble the Burnovsky form using `1` and `2`."
FeedbackLinearize::invvro = "The vector relative order computation failed."
FeedbackLinearize::gvro = "The total of the vector relative order `1` is greater than `2`."
FeedbackLinearize::sbid = "The suboption \"InputDecoupled\" can only take values True, False, or Automatic."
StateTransformationLinearize::nclin = "The model was not completely `1` linearizable."
FeedbackLinearize::iters = AsymptoticOutputTracker::iters = SystemsModelVectorRelativeOrders::iters = Control`VectorRelativeOrderCompensator::iters = "The value of option MaxIterations -> `1` should be a positive machine integer or Automatic."
SystemsModelVectorRelativeOrders::dmatrk = "The decoupling matrix `1` has rank `2`, but the number of outputs is `3`."
SystemsModelVectorRelativeOrders::dmatnz = "Unable to find a nonzero row in the decoupling matrix for output `1`."
FeedbackLinearize::dmat1 = AsymptoticOutputTracker::dmat1 = Control`VectorRelativeOrderCompensator::dmat1 = "The decoupling matrix `1` has rank 0, and hence the extension algorithm fails."
FeedbackLinearize::dmat2 = AsymptoticOutputTracker::dmat2 = Control`VectorRelativeOrderCompensator::dmat2 = "The decoupling matrix `1` has no columns with two or more nonzero elements, and hence the extension algorithm fails."
FullInformationOutputRegulator::ao = Control`CenterManifoldStateSpaceModel::ao = "The Taylor approximation order `1` must be a non-negative integer or Automatic."
FullInformationOutputRegulator::lgains = "The second argument `1` to compute the linear gains must be a list of poles, a list of weighting matrices, or the explicit gains."
FullInformationOutputRegulator::csm = "Unable to determine the composite center manifold."
AsymptoticOutputTracker::dmatf = "Unable to compute the feedback using the decoupling matrix `1`."
AsymptoticOutputTracker::drvro = "The dimensions of the decay rates `1` are inconsistent with the vector relative order `2`."
AsymptoticOutputTracker::rinvro = "The number of reference inputs `1` is not equal to the vector relative order length `2`."
StateSpaceTransform::trans = "The second argument `1` is not a valid transformation specification."
StateSpaceTransform::rtlen = "The two elements `1` of the rule-based transformation must be of length `2`."
StateSpaceTransform::istvar = "The variable `1` in the transformation is not a state variable."
ControllableModelQ::dvf = Control`ControllableSpace::dvf = "The value `1` of the suboption \"DriftVectorField\" must be True, False, or Automatic."
ControllableDecomposition::kalmat = ObservableDecomposition::kalmat = Control`TriangularControllabilityDecomposition::kalmat = Control`TriangularObservabilityDecomposition::kalmat = "The transformation matrix `1` returned by Kalman transformation is not valid."
ResetStateSpaceModelVariables::rvspec = "The reset variable specification `1` is not valid."
SystemsConnectionsModel::farg = "`1` is not a valid systems model."
Language`ExtendedDefinition::ndi = "Symbol `1` is not defined in `2`."
General::irule = "`1` is an invalid rule."
General::ideflist = "`1` is an invalid DefinitionList."
General::intpoint = "`1` is expected to contain a list of lists of integers.";
General::pospoint = "`1` contains integers that are not positive.";
General::reppoint = "`1` contains repeated integers.";
General::lowlen="Required length `1` is smaller than maximum `2` of support of `3`.";
General::permlist="Invalid permutation list `1`.";
PermutationList::bigint="`1` cannot be converted into a permutation list because it moves integers that are not machine-sized."
FindPermutation::norel="Expressions `1` and `2` cannot be related by a permutation.";
Permute::atom="First argument of Permute is not an expression with elements.";
Permute::larlen="Maximum `1` of support of `2` is larger than number `3` of elements of expression `4`.";
General::paexpr="`1` is not a valid expression for permutation action.";
General::galist="`1` is not a valid list of expressions for group action.";
General::grp="`1` is not a valid group.";
General::perm="`1` is not a valid permutation.";
General::acbase = "`1` is not a valid group action base.";
General::noin="Permutation `1` does not belong to group.";
GroupElements::lrank="Rank `1` is incompatible with group of order `2`.";
GroupElements::zerank="Zero rank is not defined."
GroupElementFromWord::word = "Group element word `1` is not a list of nonzero machine-sized integers."
GroupElementFromWord::zero = "Group element word `1` cannot contain zero."
GroupElementFromWord::ngens = "Group element word `1` is inconsistent with a list of `2` generators."
General::cstr = "Invalid collection of disjoint cycles `1`.";
General::ord32 = "Operation not supported because it requires listing the elements of a group of order `1`, exceeding 2147483647."
General::ord64 = "Operation not supported because it requires listing the elements of a group of order `1`, exceeding 9223372036854775807."
FiniteGroupData::count = "Unknown number of groups of order `1`. Group enumeration may be incomplete.";
General::symmgen = "Invalid symmetry generator `1`.";
General::noconf = "Invalid tensor configuration `1`.";
General::root1 = "`1` is not a root of unity.";
General::symmgen0 = "Permutation order of symmetry generator `1` is inconsistent with its phase.";
General::symmgenl = "`1` is not a valid list of symmetry generators.";
General::symm = "Invalid symmetry specification `1`.";
General::symm0 = "Symmetry specification `1` is only compatible with the zero tensor.";
General::symmdims = "Symmetry specification `1` is incompatible with dimensions `2`.";
General::symmcomp = "Symmetry specification `1` is incompatible with expression `2`.";
General::symmp = "Invalid symmetry specification `1` in product symmetry.";
General::indsinfo = "Inconsistent tensor index information provided.";
General::slotdispl = "Cannot displace slots `1`.";
General::pdims = "The dimensions `1` are not given as a list of positive machine integers.";
General::pmdim = "Basis dimension `1` is not a positive machine integer.";
General::contrs = "`1` is not a valid list of contractions.";
General::contr = "Invalid contraction `1`.";
General::contrl = "`1` is not a contraction of `2` levels.";
General::pcontr = "Contraction level `1` must be positive.";
General::nncontr = "Level `1` in multiple contraction cannot be negative.";
General::erank ="`1` is not a valid effective rank.";
General::eranks = "`1` is not a valid specification of effective ranks.";
General::lvrank = "Cannot contract level `1` because rank is `2`.";
General::lverank = "Cannot contract level `1` because effective rank is `2`.";
General::lerank = "Effective rank `1` cannot be larger than rank `2`.";
General::lvrep = "Contraction `1` contains repeated levels.";
General::lvreps = "Contractions `1` contain repeated levels.";
General::ctdims = "Contraction levels `1` have different dimensions `2`.";
General::nclen = "Length `1` of contractions does not agree with number `2` of arrays.";
General::erlen = "Number of effective ranks `1` does not agree with number `2` of arrays.";
General::intmat = "Contractions `1` do not form a rectangular matrix of non-negative integers.";
General::frees = "Invalid specification of free indices `1`.";
General::dumets = "Invalid metric sign `1` for dummy indices specification.";
General::dummies = "Invalid specification of dummy indices `1`.";
General::dummyl = "Invalid list of specifications of dummy indices `1`.";
General::repes = "Invalid specification of repeated indices `1`.";
General::repel = "Invalid list of specifications of repeated indices `1`.";
General::symmrank = "Symmetry specification moves index `1` beyond tensor rank `2`.";
General::tencomp = "`1` is not a tensor component or list of components.";
General::comprank = "Component `1` is incompatible with rank `2`.";
General::pmints = "Expected a list of positive machine-sized integers instead of `1`.";
General::nnmints = "Expected a list of non-negative machine-sized integers instead of `1`.";
General::nodim = "Invalid dimension specification `1`.";
General::skewa = "Cannot antisymmetrize array `1` because its dimensions `2` do not all coincide."
General::skewt = "Tensor `1` cannot be antisymmetrized."
General::wedgea = "Cannot take wedge product of arrays with different dimensions `1`, respectively."
TensorSymmetry::slrank = "Second argument, `1`, should be a list of different integers not greater than the tensor rank `2`."
HodgeDual::hodgerank = "Cannot take Hodge dual in slots `1` of a tensor of rank `2`.";
HodgeDual::hodgedim = "Cannot take Hodge dual in `1` slots in dimension `2`.";
HodgeDual::hodgerep = "Hodge dualization slots `1` contain repeated integers."
HodgeDual::dualdim = "Cannot determine dualization dimension."
General::mattrn = "Number of transformation matrices provided, `1`, does not coincide with rank of transformed array, `2`."
General::mattrd = "Dimensions `1` of transformation matrix do not coincide with dimension `2` of level `3` of array."
SymmetrizedArray::rule = "`1` is not a valid replacement rule."
SymmetrizedArray::rule1 = "The rule `1` is not of the form indices -> value."
SymmetrizedArray::pind = "The indices in `1` are not all positive."
SymmetrizedArray::symmval0 = "Value of rule `1` must be zero by symmetry.";
SymmetrizedArray::exdims = "Dimensions of array cannot be determined from `1`."
SymmetrizedArray::idims = "The requested dimensions, `1`, are incompatible with the first argument of `2`."
SymmetrizedArray::drnk = "The requested dimensions, `1`, have length inconsistent with the tensor rank (`2`) of the input."
SymmetrizedArray::pat = "Cannot construct position rules from `1`."
SymmetrizedArray::rect = "Rectangular array or list of rules of homogeneous rank expected instead of `1`."
SymbolicTensors`DiagonalSymmetrizedArray::offset = SymbolicTensors`SymmetrizedArrayDiagonal::offset = "Diagonal offset `1` must be an integer or a list of integers of length rank-1."
SymbolicTensors`TransformedBasis::mat = "Array at position `1` of `2` is not a matrix."
SymbolicTensors`TransformedBasis::matdim = "Expression `1` does not represent a basis of consistent dimension."
SymbolicTensors`BasisTransformationMatrix::btrsf = "Basis `2` cannot be converted into basis `1` with a transformation matrix."
Arrays::dimsl = Matrices::dimsl = Vectors::dimsl = "First argument `1` of `2` should be a list of positive dimensions.";
Matrices::rankl = Vectors::rankl = "The list `1` of dimensions for a `2` must have length `3`."
SymbolicTensors`Tensors::basl = "First argument `1` of `2` should be a list of bases.";
SymbolicTensors`Tensor::rank = "Array rank, `1`, is incompatible with the number of bases, `2`, in `3`."
SymbolicTensors`Tensor::adims = "First argument of `1` must be an array or a symbolic array with bases of numeric type."
SymbolicTensors`Tensor::bdims = "Array dimensions, `1`, are incompatible with the bases' dimensions, `2`, in `3`."
SymbolicTensors`Tensor::baslr = "Second argument `1` of `2` should be a list of `3` bases.";
SymbolicTensors`DualBasis::mdual = "Cannot take dual basis of `1`.";
General::nodom = "Invalid domain specification `1`."
General::fscl = "Nonscalar expression `1` encountered as an argument of numeric function `2`."
General::inhom = "Inhomogeneous `1` in sum `2`."
General::ttimes = "Product of nonscalar expressions encountered in `1`."
General::scdot = "Expression `1` contains the scalar subexpression `2`."
General::dotdim = "Dot contraction of `1` and `2` is invalid because dimensions `3` and `4` are incompatible."
TensorContract::nondual = "Found nondual bases `1` and `2`."
TensorContract::incom = "Cannot contract array levels of different dimensions `1` and `2`."
TensorTranspose::symmperm = "Invalid permutation or symmetry generator `1`."
TensorTranspose::ttrank = "Permutation `1` moves slots beyond tensor rank `2`."
TensorExpand::incdim = "Found inconsistent dimensions `1` and `2`."
ImageTransformation::imgrsasp = "Value of option AspectRatio -> `1` should be a positive number or a pair of positive numbers."
ImageForwardTransformation::imgrsasp = "Value of option AspectRatio -> `1` should be a positive number or a pair of positive numbers."
ImageForwardTransformation::nmthd = "Value of option Method -> `1` should be Automatic or None."
ImagePerspectiveTransformation::imgrsasp = "Value of option AspectRatio -> `1` should be a positive number or a pair of positive numbers."
ImageForwardTransformation::imgrsm = "Option value `1` for \"Interpolated\" should be either True or False."
ImageTransformation::imgtrnsuv = "Value of DataRange -> `1` is not Automatic, Full, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImageForwardTransformation::imgtrnsuv = "Value of DataRange -> `1` is not Automatic, Full, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImagePerspectiveTransformation::imgtrnsuv = "Value of DataRange -> `1` is not Automatic, Full, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImageTransformation::imgtrnsxy = "Value of option PlotRange -> `1` is not Automatic or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImageForwardTransformation::imgtrnsxy = "Value of option PlotRange -> `1` is not Automatic or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImagePerspectiveTransformation::imgtrnsxy = "Value of option PlotRange -> `1` is not All, Automatic, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
ImageTransformation::imgtrnsize ="The size `1` is not a valid image size specification."
ImageForwardTransformation::imgtrnsize ="The size `1` is not a valid image size specification."
ImagePerspectiveTransformation::imgtrnsize ="The size `1` is not a valid image size specification."
ImageTransformation::imgtrnsfun ="The function `1` should map a pixel position of form {x, y} to {x', y'}."
ImageTransformation::imgtrnsfun3d ="The function `1` should map a pixel position of form {x, y, z} to {x', y', z'}."
ImageForwardTransformation::imgtrnsfun ="The function `1` should map a pixel position of form {x, y} to {x', y'}."
ImagePerspectiveTransformation::imgtrnsfun ="The `1` should be either a transformation function, a 2 x 2 or 3 x 3 matrix, or a list of matrices."
ImagePerspectiveTransformation::imgtrnsfun3d ="The `1` should be either a transformation function, a 3 x 3 or 4 x 4 matrix, or a list of matrices."
ImagePerspectiveTransformation::infinity ="The transformation will map some of the points into infinity; only a truncated version is displayed."
ImageTransformation::imgtrnsinv = ImagePerspectiveTransformation::imgtrnsinv ="The transformation in `1` is not invertible."
Image3DProjection::nvol = "Expecting a 3D image instead of `1`.";
Image3DProjection::vert = "Vertical verctor `2` and projection verctor `1` must not be parallel. ";
Image3DProjection::ndir = "Projection direction `1` not supported.";
Image3DProjection::nmode = "Projection mode `1` not supported.";
Image3DProjection::nres = "No result generated.";
ImageDepthMap::nimg="Expecting a 2D or 3D image instead of `1`.";
ImageDepthMap::nside="The side specification `2` is not supported.";
ImageDepthMap::nthresh="The threshold `1` is not a real value.";
ImageDepthMap::nres="No result generated.";
Image3DProjection::nintens = "The reference volumen for the maximum intensity projection does not correspond in size to the input volume.";
ChanVeseBinarize::imginv = "Expecting an image instead of `1`.";
ChanVeseBinarize::mkinv = "Expecting a color, a pair of colors, an image, or graphics with dimensions `2` or a list of positions to specify markers instead of `1`."
ChanVeseBinarize::arg3 = "Expecting a real-valued vector of length between 1 and 4 instead of `1`.";
ChanVeseBinarize::iters = "The value of option \"MaxIterations\" -> `1` should be a positive integer.";
ChanVeseBinarize::area = "The value of area penalty should be a real number or Automatic instead of `1`."
ChanVeseBinarize::length = "The value of length penalty should be a non-negative real number or Automatic instead of `1`."
ChanVeseBinarize::inlevel = "The value of inside level penalty should be a non-negative real number or Automatic instead of `1`."
ChanVeseBinarize::outlevel = "The value of outside level penalty should be a non-negative real number or Automatic instead of `1`."
ChanVeseBinarize::level = "The value of \"LevelPenalty\" option should be a non-negative real number or list of two such numbers instead of `1`."
ChanVeseBinarize::color = "The value of \"TargetColor\" option should be a color or a list of two colors instead of `1`.";
Inpaint::imginv = "Expecting an image instead of `1`.";
Inpaint::domain = "Expecting an image, a graphics object, or a matrix of the size `1` instead of `2`."
Inpaint::mtd = "The value of option Method -> `1` should be one of \"TextureSynthesis\", \"Diffusion\", \"FastMarching\", \"NavierStokes\", or \"TotalVariation\".";
Inpaint::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
Inpaint::reg = "The value of option \"Regularization\" -> `1` should be a non-negative real number, a vector of such numbers (for multi-channel images), or Automatic."
Inpaint::noise = "The value of option \"NoiseModel\" -> `1` should be one of \"Gaussian\", \"Laplacian\", or \"Poisson\".";
Inpaint::nbrs = "The value of option \"NeighborCount\" -> `1` should be a positive integer number or Automatic."
Inpaint::smpls = "The value of option \"MaxSamples\" -> `1` should be a positive integer number or Automatic."
RegionBinarize::imginv = "Expecting an image instead of `1`.";
RegionBinarize::dist = "The value `1` of the distance parameter should be a non-negative real number."
RegionBinarize::thresh = "Expecting either an image, graphics with dimensions `2`, or a vector of length 2 instead of `1`."
RegionBinarize::invthr = "The threshold value `1` should be larger or lower than all seeds points."
RegionBinarize::mkinv2 = "The underlying pixel ranges in markers `1` and `2` overlap."
RegionBinarize::mtd = "The value of option Method ->`1` should be either \"MeanEuclidean\" or \"Mahalanobis\"."
RegionBinarize::iters = "The number of iterations should be a positive integer.";
TotalVariationFilter::arg1 = "Expecting an image or a non-empty real numeric array instead of `1`.";
TotalVariationFilter::arg2 = "Expecting a non-negative real number, a vector of such numbers (for multi-channel images), or Automatic instead of `1`.";
TotalVariationFilter::mtd = "The value of option Method -> `1` should be one of \"Gaussian\", \"Laplacian\", or \"Poisson\".";
TotalVariationFilter::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
TotalVariationFilter::lowpr = "TotalVariationFilter cannot be evaluated because of insufficient precision of the input."
WienerFilter::imginv = "Expecting an image or a non-empty real numeric array instead of `1`.";
WienerFilter::radinv = "Expecting a real number or a list of real numbers of length `2` instead of `1`.";
WienerFilter::nsinv = "Expecting a non-negative real number or Automatic instead of `1`.";
WienerFilter::padimg = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", GrayLevel[level], or c, where c is any numerical constant.";
WienerFilter::paddata = "The value of option Padding -> `1` should be one of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number.";
WienerFilter::resinv = "Applying specified arguments does not yield a correct image.";
WienerFilter::lowpr = "WienerFilter cannot be evaluated because of insufficient precision of the input."
LQEstimatorGains::zinp="Deterministic input(s) None or {} expected with input matrix {{}}."
LQEstimatorGains::noinp = DiscreteLQEstimatorGains::noinp = "Process noise covariance matrix {{}} expected with input matrix {{}}."
ImageTrim::bdpts = "`1` should be a list of points."
ImageTrim::bdroi = "`1` is not a valid region of interest. Provide a single point or a list of points, an image, a constant region, or any function that generates such a region once applied to the image."
ImageTrim::bdpadding = " The padding argument in `1` should be either a number or a list of two numbers"
ImageTrim::bddatarange="Value of DataRange -> `1` is not Automatic, Full, or a list of the form {{xmin, xmax}, {ymin, ymax}}."
LQEstimatorGains::invssys=DiscreteLQEstimatorGains::invssys = "Could not construct a stochastic linear system from the supplied arguments."
FindThreshold::arg1 = "The specified argument `1` should be either an image or an array of machine-sized numbers."
EigenvectorCentrality::nocen = KatzCentrality::nocen = HITSCentrality::nocen = PageRankCentrality::nocen = "Unable to determine centrality of a graph with no regular edges."
PageRankCentrality::maxit = HITSCentrality::maxit = "The maximum number of iterations, `1`, has been reached without convergence to a solution within a given tolerance of `2`. The currently computed solution has been returned."
PeronaMalikFilter::bdk = "The conductance parameter `1` should be either a positive number or Automatic."
PeronaMalikFilter::bds = "The regularization parameter `1` should be either a positive number or zero."
FindGeometricTransform::inputinv= "Invalid first argument `1`."
FindGeometricTransform::input= "`1` and `2` should be images, polygons, lines, points, BSplineCurves, BezierCurves, or commensurate point sets of at least dimension 2."
FindGeometricTransform::imgs = ImageAlign::imgs = "Input images should be either 2D or 3D."
FindGeometricTransform::nocp ="Images `1` and `2` do not share any corresponding points."
FindGeometricTransform::bdmethod = "The value of option Method -> `1` should be \"RANSAC\", \"Linear\", \"FindFit\", \"ImageAlign\", or {\"ImageAlign\", mtd} where mtd is a Method option value of ImageAlign."
FindGeometricTransform::mtdnoimg = "The value of option Method -> `1` can only be used with images."
FindGeometricTransform::mtdnoimg3D = "The value of option Method -> `1` can only be used with 2D images."
FindGeometricTransform::insufficientPts= "Need at least `1` non-degenerate pairs of points when estimating transformation class `2`."
FindGeometricTransform::bdtrnsf = ImageCorrespondingPoints::bdtrnsf = "Invalid geometric transformation class `1`."
FindGeometricTransform::converge="FindFit failed to converge; try other methods."
FindGeometricTransform::bdpts = "No `1` transformation can be found for given point sets."
ImageCorrespondingPoints::bdmethod = "The value of option Method -> `1` should be \"AKAZE\", \"BRISK\", \"KAZE\", \"ORB\", \"SURF\", or a list of such names."
PageRankCentrality::div = HITSCentrality::div = "Divergence has been detected. At iteration step `1`, the norm is greater than a predefined divergence tolerance of `2`."
KatzCentrality::nosol = PageRankCentrality::nosol = StatusCentrality::nosol = "Linear equation encountered that has no solution."
ImageAlign::pts="The number `1` of correspondences found is not enough to align the images."
ImageAlign::bdtrnsf = "The specified geometric transformation class `1` is invalid for this method."
ImageAlign::mtd3d = "The alignment method is not available with 3D images."
ImageAlign::bdmethod = "The value of option Method -> `1` should be Automatic, \"Keypoints\", \"MeanSquareGradientDescent\", \"Fourier\", or \"FourierBlurInvariant\"."
ImageAlign::size = "Both input images should be larger than 4 in every dimension."
FindGeometricTransform::size = "Both input images should be larger than 4 in every dimension with the method \"ImageAlign\"."
DerivativeFilter::arg1 = "Expecting an image or a non-empty numeric array instead of `1`."
DerivativeFilter::drv = "Derivative orders `1` should be a list of non-negative machine integers."
DerivativeFilter::drvord = "Derivative orders `1` higher than 8 are not supported by DerivativeFilter."
DerivativeFilter::rank = "Number of derivative orders `1` exceeds the rank of `2`."
DerivativeFilter::intord = "Value of InterpolationOrder -> `1` should be Automatic or a positive integer less than or equal to 9."
DerivativeFilter::intordl = "Value of InterpolationOrder -> `1` should be a list of Automatic or positive integers less than or equal to 9."
DerivativeFilter::padding = "Value of Padding -> `1` should be \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number."
DerivativeFilter::padlist = "Value of Padding -> `1` should be a list of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number."
DerivativeFilter::drvint = "InterpolationOrder -> `1` needs to be larger than the requested derivative order `2`."
DerivativeFilter::bdsigma = "The scale specification `1` must be a real, non-negative number."
DerivativeFilter::bigsigma = "The scale value `1` exceeds appropriate bounds."
RidgeFilter::arg1 = "Expecting an image or a non-empty real numeric array instead of `1`."
RidgeFilter::dim23 = "Expecting a numeric array of rank 2 or 3 instead of `1`."
RidgeFilter::dim2 = "Expecting a numeric array of rank 2 instead of `1`."
RidgeFilter::intord = "Value of InterpolationOrder -> `1` should be Automatic or an integer larger than 2 and less than or equal to 9."
RidgeFilter::intordl = "Value of InterpolationOrder -> `1` should be a list of Automatic or an integer larger than 2 and less than or equal to 9."
RidgeFilter::padding = "Value of Padding -> `1` should be \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number."
RidgeFilter::padlist = "Value of Padding -> `1` should be a list of \"Fixed\", \"Periodic\", \"Reversed\", \"Reflected\", or c, where c is any machine-size number."
RidgeFilter::drvint = "InterpolationOrder -> `1` needs to be larger than the requested derivative order `2`."
RidgeFilter::bdsigma = "The scale specification `1` must be a real, non-negative number."
PeakDetect::arg = "The argument `1` at position 1 is not a consistent list of real values."
PeakDetect::scale = "The scale `1` at position 2 should be a non-negative real number."
PeakDetect::scaleqnty = "The scale `1` has to be dimensionless."
PeakDetect::shrpn = "The sharpness parameter `1` at position 3 should be a non-negative real number or a list of a non-negative real number and a scale."
PeakDetect::shrpnqnty = "The sharpness parameter `1` does not have a compatible unit."
PeakDetect::shrpnscale = "The sharpness scale `1` has to be smaller than or equal to the first scale parameter `2`."
PeakDetect::shrpnscaleqnty = "The sharpness scale `1` has to be dimensionless."
PeakDetect::thrsh = "The threshold parameter `1` at position 4 should be a real number or a list of a real number and a non-negative scale."
PeakDetect::thrshqnty = "The threshold parameter `1` does not have a compatible unit."
PeakDetect::thrshscale = "The threshold scale `1` has to be smaller than or equal to the first scale parameter `2`."
PeakDetect::thrshscaleqnty = "The threshold scale `1` has to be dimensionless."
PeakDetect::nopad = "The padding option `1` is not supported."
PeakDetect::noord = "The interpolation order `1` is not supported. The maximal interpolation order is 3."
FindPeaks::arg = "The argument `1` at position 1 is not a consistent list of real values."
FindPeaks::scale = "The scale `1` at position 2 should be a non-negative real number."
FindPeaks::scaleqnty = "The scale `1` has to be dimensionless."
FindPeaks::shrpn = "The sharpness parameter `1` at position 3 should be a non-negative real number or a list of a non-negative real number and a scale."
FindPeaks::shrpnqnty = "The sharpness parameter `1` does not have a compatible unit."
FindPeaks::shrpnscale = "The sharpness scale `1` has to be smaller than or equal to the first scale parameter `2`."
FindPeaks::shrpnscaleqnty = "The sharpness scale `1` has to be dimensionless."
FindPeaks::thrsh = "The threshold parameter `1` at position 4 should be a real number or a list of a real number and a non-negative scale."
FindPeaks::thrshqnty = "The threshold parameter `1` does not have a compatible unit."
FindPeaks::thrshscale = "The threshold scale `1` has to be smaller than or equal to the first scale parameter `2`."
FindPeaks::thrshscaleqnty = "The threshold scale `1` has to be dimensionless."
FindPeaks::nopad = "The padding option `1` is not supported."
FindPeaks::noord = "The interpolation order `1` is not supported. The maximal interpolation order is 3."
ResamplingAlgorithmData::nmethod = "The first argument `1` is not a valid specification for a resampling method."
ResamplingAlgorithmData::ndef = "ResamplingAlgorithmData has no value associated with `1`."
ArrayResample::noarr = "`1` is not a regular array."
ArrayResample::nodim = "Invalid dimension specification `1`."
ArrayResample::dimslen = "The number of `1` resampling dimensions exceeds the array rank."
ArrayResample::noschm = "Expecting a \"Point\" or \"Bin\"-scheme specification instead of `1`."
ArrayResample::schmslen = "The number of `1` resampling schemes exceeds the array rank or number of specified output dimensions."
ArrayResample::nobnd = "Invalid resampling subrange specification `1`."
ArrayResample::bndslen = "The number of `1` subranges exceeds the array rank or number of specified output dimensions."
ArrayResample::nopad = "Unsupported Padding option value `1`."
ArrayResample::padslen = "The number of `1` Padding options exceeds the array rank or number of specified output dimensions."
ArrayResample::norsmpl = "Unsupported Resampling option value `1`."
ArrayResample::rsmplslen = "The number of `1` Resampling options exceeds the array rank or number of specified output dimensions."
ArrayResample::nodrng = "Unsupported DataRange option value `1`."
ArrayResample::drngslen = "The number of `1` DataRange options exceeds the array rank or number of specified output dimensions."
ArrayResample::noalias = "Unsupported Antialiasing option value `1`."
ArrayResample::aliaslen = "The number of `1` Antialiasing options exceeds the array rank or number of specified output dimensions."
ArrayResample::minpts = "The \"Point\"-scheme requires at least two samples per dimension."
ArrayResample::sympad = "Padding `1` is not an appropriate boundary for the `2`-scheme."
ArrayResample::infprec = "Infinite precision for resampling method `1` not supported. Proceeding with machine precision."
ArrayResample::padprec = "Unable to provide a precision of `1` digits for padding `2`. Proceeding with machine precision."
General::supp = "Mixed graphs and multigraphs are not supported."
General::graph = "A graph object is expected at position `2` in `1`."
General::inv = "The argument `2` in `1` is not a valid `3`."
KochCurve::inv = MengerMesh::inv = CantorMesh::inv = SierpinskiMesh::inv = "The argument `2` in `1` is not a valid parameter."
SierpinskiMesh::intp = MengerMesh::intp = "Dimension 2 or 3 expected at position `2` in `1`."
CantorMesh::intp = "Dimension 1, 2 or 3 expected at position `2` in `1`."
General::nadj = "The null graph does not have an adjacency matrix."
General::ninc = "Empty graphs do not have incidence matrices."
General::args = "`1` called with invalid parameters."
RandomGraph::dist = "A graph distribution is expected at position `2` in `1`."
VertexReplace::reps = "`1` is not a list of replacement rules."
VertexAdd::exist = "The vertex `2` already exists in `1`."
EdgeAdd::exist = "The edge `2` already exists in `1`."
FindHamiltonianCycle::impl = HamiltonianGraphQ::impl = "The method currently implemented for `1` only accepts undirected graphs."
PlanarGraph::nplanar = "`1` is not a planar graph."
FindShortestTour::nopt = "Unable to find the exact optimal tour. Returning tour computed using heuristic methods."
General::imgrsm = "Invalid resampling method `1`"
General::sfunc = "`1` is not a valid scaling function."
LinearAlgebra`Private`FEASTEigensystem::dval = LinearAlgebra`Private`FEASTEigenvalues::dval = LinearAlgebra`Private`FEASTEigenvectors::dval = "The value `1` must be a machine-precision number."
LinearAlgebra`Private`FEASTEigensystem::dvalcnv = LinearAlgebra`Private`FEASTEigenvalues::dvalcnv = LinearAlgebra`Private`FEASTEigenvectors::dvalcnv = "Cannot convert the value `1` or `2` to a machine-precision number."
LinearAlgebra`Private`FEASTEigensystem::ival = LinearAlgebra`Private`FEASTEigenvalues::ival = LinearAlgebra`Private`FEASTEigenvectors::ival = "The value `1` must be a positive machine integer."
Eigensystem::mconly = Eigenvalues::mconly = Eigenvectors::mconly = LinearAlgebra`Private`FEASTEigensystem::mconly = LinearAlgebra`Private`FEASTEigenvalues::mconly = LinearAlgebra`Private`FEASTEigenvectors::mconly = "The FEAST method works only with machine-number matrices."
LinearAlgebra`Private`FEASTEigensystem::iopt = LinearAlgebra`Private`FEASTEigenvalues::iopt = LinearAlgebra`Private`FEASTEigenvectors::iopt = "Value of option `1` -> `2` should be a machine integer."
LinearAlgebra`Private`FEASTEigensystem::tol = LinearAlgebra`Private`FEASTEigenvalues::tol = LinearAlgebra`Private`FEASTEigenvectors::tol = "The value of option Tolerance -> `1` should be zero or a positive integer."
LinearAlgebra`Private`FEASTEigensystem::maxit = LinearAlgebra`Private`FEASTEigenvalues::maxit = LinearAlgebra`Private`FEASTEigenvectors::maxit = "The value of option MaxIterations -> `1` should be a positive integer."
LinearAlgebra`Private`FEASTEigensystem::cntpts = LinearAlgebra`Private`FEASTEigenvalues::cntpts = LinearAlgebra`Private`FEASTEigenvectors::cntpts = "The value of option ContourPoints -> `1` should be one of {3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 40, 48}. The default value is 8."
LinearAlgebra`Private`FEASTEigensystem::bandsol = LinearAlgebra`Private`FEASTEigenvalues::bandsol = LinearAlgebra`Private`FEASTEigenvectors::bandsol = "The value of option UseBandedSolver -> `1` should be either True or False."
LinearAlgebra`Private`FEASTEigensystem::restrt = LinearAlgebra`Private`FEASTEigenvalues::restrt = LinearAlgebra`Private`FEASTEigenvectors::restrt = "The value of option NumberOfRestarts -> `1` should be zero or a positive integer."
Eigensystem::noeig = Eigenvalues::noeig = Eigenvectors::noeig = LinearAlgebra`Private`FEASTEigensystem::noeig = LinearAlgebra`Private`FEASTEigenvalues::noeig = LinearAlgebra`Private`FEASTEigenvectors::noeig = "No eigenvalues are found in the given search interval."
Eigensystem::subsmll = Eigenvalues::subsmll = Eigenvectors::subsmll = "Warning: Subspace dimension is too small for the FEAST method. Increase the option \"SubspaceSize\"."
LinearAlgebra`Private`FEASTEigensystem::subsmll = LinearAlgebra`Private`FEASTEigenvalues::subsmll = LinearAlgebra`Private`FEASTEigenvectors::subsmll = "Warning: Subspace dimension is too small for the FEAST method. Increase the fourth argument."
Eigensystem::linfail = Eigenvalues::linfail = Eigenvectors::linfail = LinearAlgebra`Private`FEASTEigensystem::linfail = LinearAlgebra`Private`FEASTEigenvalues::linfail = LinearAlgebra`Private`FEASTEigenvectors::linfail = "Internal error occurred in the inner linear system solver."
Eigensystem::eigfail = Eigenvalues::eigfail = Eigenvectors::eigfail = LinearAlgebra`Private`FEASTEigensystem::eigfail = LinearAlgebra`Private`FEASTEigenvalues::eigfail = LinearAlgebra`Private`FEASTEigenvectors::eigfail = "Internal error occurred in the reduced eigensystem solver."
Eigensystem::intpar = Eigenvalues::intpar = Eigenvectors::intpar = LinearAlgebra`Private`FEASTEigensystem::intpar = LinearAlgebra`Private`FEASTEigenvalues::intpar = LinearAlgebra`Private`FEASTEigenvectors::intpar = "A wrong value of an internal parameter (error `1`)."
Eigensystem::nosymh = Eigenvalues::nosymh = Eigenvectors::nosymh = LinearAlgebra`Private`FEASTEigensystem::nosymh = LinearAlgebra`Private`FEASTEigenvalues::nosymh = LinearAlgebra`Private`FEASTEigenvectors::nosymh = "The input matrix `1` should be real symmetric or complex Hermitian."
Eigensystem::nochol = Eigenvalues::nochol = Eigenvectors::nochol = LinearAlgebra`Private`FEASTEigensystem::nochol = LinearAlgebra`Private`FEASTEigenvalues::nochol = LinearAlgebra`Private`FEASTEigenvectors::nochol = "The input matrix `1` is not positive definite."
Eigensystem::nofeast = Eigenvalues::nofeast = Eigenvectors::nofeast = LinearAlgebra`Private`FEASTEigensystem::nofeast = LinearAlgebra`Private`FEASTEigenvalues::nofeast = LinearAlgebra`Private`FEASTEigenvectors::nofeast = "The library for the method FEAST is missing, so `1` is unable to compute the solution."
LinearAlgebra`Private`FEASTEigenvalues::wrarch = LinearAlgebra`Private`FEASTEigenvectors::wrarch = LinearAlgebra`Private`FEASTEigensystem::wrarch = "A wrong platform or a wrong MKL library."
Eigenvalues::wcfail = Eigenvectors::wcfail = Eigensystem::wcfail = LinearAlgebra`Private`FEASTEigenvalues::wcfail = LinearAlgebra`Private`FEASTEigenvectors::wcfail = LinearAlgebra`Private`FEASTEigensystem::wcfail = "Warning: Algorithm failed to converge."
LinearAlgebra`Private`FEASTEigenvalues::dbginfo = LinearAlgebra`Private`FEASTEigenvectors::dbginfo = LinearAlgebra`Private`FEASTEigensystem::dbginfo = "The value of the option PrintDebugInfo can be only True or False."
EigenvectorCentrality::arfail = "Arnoldi failed to find the maximum eigenvector."
FinancialDerivative::unrec = "Unrecognized set of arguments to function FinancialDerivative[].";
FinancialDerivative::compspec = "Each mixed-strategy component must be a list.";
FinancialDerivative::checkc = "The contract specification `1` does not match any available pattern.";
FinancialDerivative::checkcp = "Contract parameter specification `1` does not match that of the contract `2`.";
FinancialDerivative::checkap = "Ambient parameter specification `1` does not match that of the contract `2`.";
FinancialDerivative::checkequity = "Equity specification `1` is not proper.";
FinancialDerivative::checkcurrency = "Currency `1` is not properly specified.";
FinancialDerivative::checkretparam = "Check return parameters: `1`.";
FinancialDerivative::basketmismatch = "The number of basket entities must be `1`: `2`.";
FinancialDerivative::checknumeric = "Parameters `1` cannot have `2` values.";
FinancialDerivative::discon = "The partial derivative cannot be found across a barrier.";
FinancialDerivative::infcrit = "The critical value is infinite for the parameters specified.";
FinancialDerivative::corr = "Ambiguous correlation matrix specification: `1`.";
FinancialDerivative::datemism = "Mismatched date object specification: `1`.";
FinancialDerivative::bodprob = "Date object specification is invalid: `1`.";
FinancialDerivative::valueforiv = "Must specify option value to compute implied volatility.";
FinancialDerivative::singulariv = "Implied volatility cannot be computed for the value specified.";
FinancialDerivative::ivprob = "Implied volatility calculation accessible only for vanilla options.";
FinancialDerivative::novalg = "The values for Greeks are not accessible for this contract type.";
FinancialDerivative::novalc = "The critical value is not accessible for this contract type.";
FinancialDerivative::plen = "The \"`1`\" parameter has an invalid length."
FinancialDerivative::culdlst = "The input `1` could not be loaded into CUDA memory."
FinancialDerivative::cuallocr = "CUDA was not able to allocate memory for the result."
FinancialDerivative::cuopt = "Contract type `1` is not a supported by CUDA."
FinancialDerivative::cudevn = "The specified CUDA device number `1` is invalid."
FinancialDerivative::nodbl = "Double precision library is not available on this machine."
FinancialDerivative::cupres = "The specified CUDA precision `1` is invalid, \"Single\" or \"Double\" expected."
FinancialDerivative::cudafunld = "Failed loading CUDA function `1`."
FinancialDerivative::cudarespk = "Please reload valid CUDA paclet. "
FinancialDerivative::noculib = "The CUDA library file `1` doesn't exist. "
FinancialDerivative::invcorr = "Invalid correlation matrix `1`. "
FinancialDerivative::cuimemlen = "CUDA input memory length `1` is invalid."
FinancialDerivative::cumemlen = "CUDA output memory length `1` is invalid."
FinancialDerivative::cuargi = "Invalid argument `1`, check input."
FinancialDerivative::numer = "Numerical error occurred while computing the option. This is likely due to invalid input causing an overflow or underflow during the computation."
FinancialDerivative::pklt = "CUDAResources version `1` is not valid. This is likely due to an old paclet installation. Run CUDAResourcesInstall[Update->True] to update the paclet."
FinancialDerivative::unsprt = "\"RuntimeTarget\"->\"CUDA\" is not supported in `1`. Support for CUDA enhanced computations is provided by Wolfram Finance Platform"
FinancialDerivative::cnfgr = "\"RuntimeTarget\"->\"CUDA\"  is not supported in this configuration."
FinancialDerivative::barrier = "The contract price has reached the barrier level; the contract is `1`.";
LinearAlgebra`Private`SchurEigenvalues::nschrf1 = "The matrix `1` is not in the standard Schur form."
LinearAlgebra`Private`SchurEigenvalues::nschrf2 = "The matrix pair `1` is not in the generalized Schur form."
MatrixPower::negev = MatrixLog::negev = LinearAlgebra`Private`MatrixLog::negev= LinearAlgebra`Private`MatrixSqrt::negev = "The matrix `1` has a negative eigenvalue."
MatrixPower::exiter = MatrixLog::exiter = LinearAlgebra`Private`MatrixLog::exiter = "Too many iterative steps are taken. At least one eigenvalue is too close to zero."
MatrixPower::zegev = MatrixLog::zegev = LinearAlgebra`Private`MatrixLog::zegev = "The matrix `1` has a zero eigenvalue."
MatrixLog::nosol = LinearAlgebra`Private`MatrixLog::nosol = "Cannot compute the matrix logarithm."
MatrixPower::nosol = LinearAlgebra`Private`MatrixFractionalPower::nosol = LinearAlgebra`Private`MatrixSqrt::nosol = "Cannot compute the matrix square root."
MatrixPower::fnanc = LinearAlgebra`Private`MatrixFractionalPower::fnanc = LinearAlgebra`Private`MatrixSqrt::fnanc = MatrixLog::fnanc = LinearAlgebra`Private`MatrixLog::fnanc = MatrixFunction::fnanc = LinearAlgebra`Private`MatrixFunction::fnanc = "The function `1` is not analytic at `2`."
MatrixPower::fnand = LinearAlgebra`Private`MatrixFractionalPower::fnand = LinearAlgebra`Private`MatrixSqrt::fnand = MatrixLog::fnand = LinearAlgebra`Private`MatrixLog::fnand = MatrixFunction::fnand = LinearAlgebra`Private`MatrixFunction::fnand = "The function `1` is not analytic or defined at `2`."
MatrixFunction::nunipf = LinearAlgebra`Private`MatrixFunction::nunipf = "`1` is not a univariate pure function."
MatrixFunction::nosol = LinearAlgebra`Private`MatrixFunction::nosol = "Cannot compute the matrix function for the function `1`."
MatrixFunction::nnumf = LinearAlgebra`Private`MatrixFunction::nnumf = "Unable to compute the result for non-numeric function and non-exact-precision matrix."
MatrixFunction::nsdlt = LinearAlgebra`Private`MatrixFunction::nsdlt = "Value of option BlockSeparationDelta -> `1` is not a positive real number or Automatic."
MatrixFunction::nderv = LinearAlgebra`Private`MatrixFunction::nderv = "Unable to compute the derivative for the function `1`."
MatrixFunction::drvtcmpx = LinearAlgebra`Private`MatrixFunction::drvtcmpx = "The derivatives of the function `1` become more and more complex in each step of the Taylor series function evaluation. Decreasing the BlockSeparationDelta value may help in computing this matrix function."
MatrixFunction::drvnnum = LinearAlgebra`Private`MatrixFunction::drvnnum = "Unable to compute the matrix function because the subsequent derivative of the function `1` at a numeric value is not numeric."
MatrixFunction::nconv = LinearAlgebra`Private`MatrixFunction::nconv = "Warning: the matrix function does not converge within the specified tolerance `1`. Decreasing the BlockSeparationDelta value and/or increasing the Tolerance value may help."
MatrixPower::fnnum = LinearAlgebra`Private`MatrixFractionalPower::fnnum = MatrixFunction::fnnum = LinearAlgebra`Private`MatrixFunction::fnnum = "Unable to compute the matrix function because the function `1` at a numeric value is not numeric."
MatrixFunction::schexm = LinearAlgebra`Private`MatrixFunction::schexm = MatrixLog::schexm = LinearAlgebra`Private`MatrixLog::schexm = LinearAlgebra`Private`MatrixSqrt::schexm = "The Schur method cannot work with exact or symbolic matrices."
MatrixFunction::valtlrg = LinearAlgebra`Private`MatrixFunction::valtlrg = "Warning: at least one value returned by the function or one of its derivatives is significantly larger than its argument. The resulting matrix function may be inaccurate or may not exist."
MatrixFunction::trslclev = LinearAlgebra`Private`MatrixFunction::trslclev = "Warning: diagonal blocks have common or close eigenvalues. The resulting matrix may be inaccurate."
MatrixPower::lrgmexp = LinearAlgebra`Private`MatrixPower::lrgmexp = MatrixFunction::lrgmexp = LinearAlgebra`Private`MatrixFunction::lrgmexp = "The matrix exponent is too large."
MatrixPower::cpmlxexp = LinearAlgebra`Private`MatrixPower::cmplxexp = MatrixFunction::cmplxexp = LinearAlgebra`Private`MatrixFunction::cmplxexp = "The matrix exponent is a complex number."
(* SymbolicTensors messages*)
General::bdmtrc = "`1` does not define a metric in `2` dimensions.";
General::ndimt = "`1` has dimensions `2` and is therefore not a tensor in `3`-dimensional space."; (* N-DIMensional Tensor *)
General::ndimv = "`1` has length `2` and is therefore not a vector in `3`-dimensional space."; (* N-DIMensional Vector *)
Grad::ndimv = "There is no `3`-dimensional gradient for the `2`-dimensional vector `1`."; (* N-DIMensional Vector *)
Div::ndimv = "There is no `3`-dimensional divergence for the `2`-dimensional vector `1`."; (* N-DIMensional Vector *)
Curl::ndimv = "There is no `3`-dimensional curl for the `2`-dimensional vector `1`."; (* N-DIMensional Vector *)
Laplacian::ndimv = "There is no `3`-dimensional Laplacian for the `2`-dimensional vector `1`."; (* N-DIMensional Vector *)
Laplacian::zdim = "`1` with inner dimension 0 does not have a Laplacian.";
General::nocoord = "`1` is not a non-empty list of valid variables.";
General::nopch = "Computing `1` of `2` requires a geometric patch in the third argument.";
Curl::hrank = "Tensor expression `1` does not have a curl because its rank, `2`, is greater than or equal to the dimension `2`.";
Div::sclr = "The scalar expression `1` does not have a divergence.";
Div::ndiml = "There is no `3`-dimensional divergence for the array `1` because its innermost dimension is `2`."; (* N-DIMensional Last slot *)
General::twmtrc = "`1` and `2` define coordinate charts for different metrics and therefore have no associated coordinate mapping.";
General::bdchrt = "`1` does not define a known coordinate chart in `2` dimensions.";
General::bdmap = "`1` does not define a coordinate mapping in `2` dimensions.";
General::nmpctd = "No coordinate mapping is available between `1` and `2`."; (* No MaP in CoordinateTransformData *)
General::bdpt = "Evaluation point `1` is incompatible with the coordinate assumptions of the specified coordinate chart.";
CoordinateTransformData::dimb = CoordinateChartData::dimb = "Dimension specification `1` should be a positive integer."; (* DIMension Bad *)
CoordinateChartData::dimm = "Coordinate system `2` of metric `1` requires a dimension specification or an evaluation point."; (* DIMension Missing *)
CoordinateTransformData::dimm = "A map between `1` and `2` requires a dimension specification or an evaluation point."; (* DIMension Missing *)
CoordinateChartData::dima = "Cannot specify evaluation point `1` in addition to dimension specification All."; (* DIMension versus All *)
CoordinateTransformData::dimp = CoordinateChartData::dimp = "Evaluation point `1` has dimension `2`, which does not match dimension specification `3`."; (* DIMension versus Point *)
CoordinateChartData::cspec = "`1` is expected to be a string, a pair of the form {_String, _}, or the symbol All."; (* Chart SPEC *)
CoordinateTransformData::cspec = "`1` is expected to be a string or a pair of the form {_String, _}."; (* Chart SPEC *)
CoordinateTransformData::unkmtrc = CoordinateChartData::unkmtrc = "`1` is not a known metric.";
CoordinateTransformData::mtrcdim = CoordinateChartData::mtrcdim = "Metric `2` is not known in dimension `1`.";
CoordinateTransformData::mtrcpx = CoordinateChartData::mtrcpx = "Metric `1` in dimension `2` takes 1 parameter.";
CoordinateTransformData::mtrcprx = CoordinateChartData::mtrcprx = "Metric `1` in dimension `2` takes `3` parameters.";
CoordinateTransformData::unkcsys = CoordinateChartData::unkcsys = "`1` is not a known coordinate system for metric `2`.";
CoordinateTransformData::csysdim = CoordinateChartData::csysdim = "Coordinate system `2` of metric `3` is not known in dimension `1`.";
CoordinateTransformData::csyspx = CoordinateChartData::csyspx = "Coordinate system `1` of metric `2` in dimension `3` takes 1 parameter.";
CoordinateTransformData::csysprx = CoordinateChartData::csysprx = "Coordinate system `1` of metric `2` in dimension `3` takes `4` parameters.";
CoordinateTransformData::bdpar = CoordinateChartData::bdpar = "Parameter value `1` is incompatible with the parameter assumptions of the specified coordinate chart.";
CoordinateTransformData::bdpars = CoordinateChartData::bdpars = "Parameter values `1` are incompatible with the parameter assumptions of the specified coordinate chart.";
CoordinateTransformData::rename = "Warning: Default parameter name `1` was renamed `2` to preserve generality. Manually specify parameters to restrict to special cases.";
CoordinateTransformData::renames = "Warning: Default parameter renamings `1` were performed to preserve generality. Manually specify parameters to restrict to special cases.";
CoordinateTransformData::cas = "Coordinate transform `1` produces contradictory assumptions `2`.";
CoordinateTransform::bdmap1 = "`1` does not appear to be a valid coordinate mapping"; (* For the special case of empty arrays and non-syntactically valid mapping*)
FromPolarCoordinates::bdmap = ToPolarCoordinates::bdmap = "Polar and hyperspherical coordinates are only defined in dimension 2 and greater.";
FromSphericalCoordinates::bdmap = ToSphericalCoordinates::bdmap = "Spherical coordinates are only defined in dimension 3.";
FromPolarCoordinates::bdpt = "Evaluation point `1` is not a valid set of polar or hyperspherical coordinates.";
FromSphericalCoordinates::bdpt = "Evaluation point `1` is not a valid set of spherical coordinates.";
ToSphericalCoordinates::bdpt = ToPolarCoordinates::bdpt = "Evaluation point `1` is not a valid set of Cartesian coordinates.";
RegionMeasure::varslst = "Argument `1` in position 2 of `2` is expected to be a list of integration specifications of the form \!\({{t\_1,a\_1, b\_1}...}\)."
Perimeter::vars = ArcLength::vars = Area::vars = Volume::vars = RegionMeasure::vars = "Integration range specification `1` is not of the form \!\({t, t\_\(min\), t\_\(max\)}\)."
Perimeter::nlim = ArcLength::nlim = Area::nlim = Volume::nlim = RegionMeasure::nlim = "`1` = `2` is not a valid limit of integration."
ArcLength::nlim1 = Area::nlim1 = Volume::nlim1 = RegionMeasure::nlim1 = "Non-numeric limit `1` = `2` is incompatible with numeric method `3`."
ArcLength::ncrve = "Parametric curve `1` contains symbolic parameters and is therefore incompatible with numeric method \"`2`\"."
Area::ncrve = "Parametric surface `1` contains symbolic parameters and is therefore incompatible with numeric method \"`2`\"."
Volume::ncrve = "Parametric volume `1` contains symbolic parameters and is therefore incompatible with numeric method \"`2`\"."
RegionMeasure::ncrve = "Parametric expression `1` contains symbolic parameters and is therefore incompatible with numeric method \"`2`\"."
ArcLength::nchrt = Area::nchrt = Volume::nchrt = RegionMeasure::nchrt = "Coordinate chart `1` contains symbolic parameters and is therefore incompatible with numeric method \"`2`\"."
Perimeter::bdmtd = ArcLength::bdmtd = Area::bdmtd = Volume::bdmtd = RegionMeasure::bdmtd = "Method value `1` should be Automatic, \"Integrate\", \"NIntegrate\", or a list containing a method name and options."
Perimeter::creg = ArcLength::creg = Area::creg = Volume::creg = RegionMeasure::creg = "`1` is not a constant region and is therefore incompatible with numeric method \"`2`\"";
Perimeter::inpf = "`1` is not a parametric expression embedded in dimension 2."
ArcCurvature::inpf = ArcLength::inpf = FrenetSerretSystem::inpf = "`1` is neither a parametric curve nor a scalar expression."
Area::inpf = "`1` is neither a parametric surface nor a scalar expression."
Volume::inpf = "`1` is neither a parametric solid nor a scalar expression."
RegionMeasure::inpf = "`1` is neither a valid region, scalar function, nor parametric expression."
ArcCurvature::sing = FrenetSerretSystem::sing = "Input curve `1` is singular."
General::grphch = "Scalar input `1` is incompatible with a coordinate chart specification."
General::repvars = "Domain variables `1` and target variables `2` cannot have common names.";
General::mpvrs = "`1` should be a rule of the form oldvars -> newvars, where oldvars and newvars are non-empty lists of valid variables.";
(*AugmentedData messages*)
General::ivldmtdt = "The function `1` does not support the given metadata.";
General::cnsmsg = "The argument `1` is not a valid censoring specification.";
General::trmsg = "The argument `1` is not a valid truncation specification.";
General::wtmsg = "The argument `1` is not a valid weight specification.";
General::espec = "The argument `1` is not a valid event specification.";
General::dblinf = "The argument `1` contains unbounded intervals.";
WeightedData::wtfn = "The weight function `1` cannot be used to generate non-negative weights from the data.";
WeightedData::rectn = "A vector or matrix of real numbers is expected at position `2` in `1`."
(*SurvivalAnalysis messages*)
LogRankTest::wtmthd = "The weight specification `1` at position `2` is expected to be one of \"AndersenPeto\", \"Equal\", \"Gehan\", \"Peto\", \"TaroneWare\", a non-negative integer, or pair of non-negative integers.";
LogRankTest::trncr = "LogRankTest is not implemented for the combination `1` truncation and `2` censoring.";
LogRankTest::wfncmp = "Unable to compute valid weights using weight specification `1`.";
General::sclvrng = "The confidence range `1` does not contain any values in the data.";
General::ftdfnc = "The specification `1` should be one of \"SF\", \"CHF\", or \"CDF\".";
General::cnflvl = "The confidence level specification `1` should be a real number between 0 and 1.";
General::cnfrng = "The confidence range specification `1` should be one of All, Full, All, Automatic, a real number, or a list of two such numbers {t1,t2} where t1<t2."
General::cnftr = "The confidence transform specification `1` should be one of \"ArcSinSqrt\", \"Linear\", \"Log\", \"Logit\", \"LogLog\", or a pure function.";
General::estpts = "The estimation points specification `1` should be a vector of real numbers.";
General::tlmdl = "The tail model specification `1` should be one of Automatic, None, \"Censored\", \"Continuous\", \"Indeterminate\", \"Exponential\", \"Weibull\", \"Gamma\", \"Normal\", \"LogNormal\", \"GompertzMakeham\", \"InverseGaussian\", or \"LogLogistic\".";
General::smthopts = "Invalid smoothing options `1`."
General::intpts = "The InterpolationPoints option value `1` must be an integer or list of integers of length equal to the dimension of the data, with each integer greater than 1.";
General::mxkrn = "The MaxMixtureKernels option value `1` should be an integer greater than 1, All, a list of real values, or a list of such specifications with length equal to the dimension of the data.";
General::perfg = "Invalid performance goal specification `1`. The performance goal should be set to \"Speed\" or \"Quality\"."
General::semthd = "An invalid standard error method `1` was given; the default method `2` will be used.";
General::seflr = "Failed to estimate standard errors with the method `1`; the default method `2` will be used.";
General::rpttms = "The argument `1` is expected to be a list of real numbers.";
CoxModelFit::ntrdm = "The basis functions `1` produced a nonreal design matrix.";
CoxModelFit::cnlrnk = "A full rank design matrix could not be produced.";
CoxModelFit::nmxlhd = "Failed to maximize the partial likelihood with the given method settings.";
CoxModelFit::ntincpt = "Constant values are not allowed in the basis functions. Constant basis functions `1` were encountered at position `2`.";
CoxModel::bdcntr = "The contrast matrix `1` is not a matrix of full rank.";
CoxModel::strtpk = "Unable to determine the intended stratum based on the covariate level specification `1`.";
CoxModelFit::xmtrx = "The input data `1` is not a vector or matrix.";
CoxModelFit::badvars = "The variable list `1` contains numeric values.";
CoxModelFit::xtrvrs = "The basis functions `1` contain variables not present in the variable list `2`.";
CoxModelFit::nomimpc = "CoxModelFit is not implemented for `1` censoring.";
CoxModelFit::nomimptr = "CoxModelFit is not implemented for `1` truncation.";
CoxModelFit::strnm = "The variable `1` was specified in both NominalVariables and StrataVariables.";
CoxModelFit::dpbss = "Duplicate basis functions were encountered and will be dropped.";
CoxModelFit::strbs = "Strata variables `1` were found in the basis functions `2` and will be dropped from the basis functions.";
CoxModelFit::nsnmvr = "The input data matrix `1` contains non-numeric values not identified with NominalVariables or StrataVariables.";
CoxModelFit::mthd = "The option value `1` is not a valid method. Method should be one of \"Breslow\", \"Efron\", \"Exact\", or Automatic.";
CoxModel::ntfrvr = "All variables in `1` are free. At least one of the variables should be fixed.";
FindFaces::size = "`1` is not a valid size specification for faces.";
FindFaces::sys = "FindFaces is not yet available on `1`.";
FindFaces::invprop = "`1` is not a known property or a list of known properties."
FindFaces::oldsize = "The syntax FindFaces[image, {min, max}] is obsolete and will not be supported in future versions of the Wolfram Language."
FindFaces::trainfile = "Training file specification is only supported with the \"LocalBinaryPatterns\" and \"HaarCascade\" methods.";
TransferFunctionTransform::invtfm = "`1` is not a valid TransferFunctionModel object."
TransferFunctionTransform::invf = "Applying function `1` does not yield a valid TransferFunctionModel."
BiquadraticFilterModel::spec = BesselFilterModel::spec = ButterworthFilterModel::spec = Chebyshev1FilterModel::spec = Chebyshev2FilterModel::spec = EllipticFilterModel::spec = "`1` is not a valid filter specification.";
BesselFilterModel::symb = ButterworthFilterModel::symb = Chebyshev1FilterModel::symb = Chebyshev2FilterModel::symb = EllipticFilterModel::symb = "Symbolic frequency or attenuation values are not supported in full filter specification.";
BiquadraticFilterModel::ivar = BesselFilterModel::ivar = ButterworthFilterModel::ivar = Chebyshev1FilterModel::ivar = Chebyshev2FilterModel::ivar = EllipticFilterModel::ivar = "`1` is not a valid variable.";
BiquadraticFilterModel::center = "Center frequency in `1` must be a symbol or a positive number."
BiquadraticFilterModel::quality = "Quality factor in `1` must be a symbol or a positive number."
BiquadraticFilterModel::type = "Unknown filter type encountered in `1`."
BiquadraticFilterModel::type2 = "Filter type in `1` must be one of \"Bandpass\" or \"Bandstop\"."
BiquadraticFilterModel::equ = "Filter type in `1` must be one of \"Peaking\", \"LowShelf\", or \"HighShelf\"."
BiquadraticFilterModel::freq = "Frequency in `1` must be a symbol or a positive number."
BiquadraticFilterModel::ascend = "Frequencies in `1` must be in ascending order."
BiquadraticFilterModel::gain = "Gain value in `1` must be a symbol or a positive number."
EquirippleFilterKernel::deviation = "A deviation error has occurred. Increase filter length or width of transition bands or WorkingPrecision and try again."
EquirippleFilterKernel::type = "Unknown filter type `1` encountered. Supported filter types are: \"bandpass\", \"differentiator\", and \"Hilbert\"."
EquirippleFilterKernel::wts = "Expecting a vector of positive numbers instead of `1`."
EquirippleFilterKernel::ampl = "Neighboring bands cannot have the same amplitudes."
EquirippleFilterKernel::length = "The length of the transition regions in `1` should be greater than zero."
EquirippleFilterKernel::err = "A convergence error has occurred. Try increasing the precision of the filter specification and the value of the WorkingPrecision option."
EquirippleFilterKernel::spec = LeastSquaresFilterKernel::spec = FrequencySamplingFilterKernel::spec = "`1` is not a valid filter specification."
EquirippleFilterKernel::iters = "The value of option MaxIterations -> `1` should be a positive machine integer or Automatic."
EquirippleFilterKernel::grid = "The value of option GridDensity -> `1` should be a positive machine integer or Automatic."
LeastSquaresFilterKernel::arg2 = FrequencySamplingFilterKernel::arg2 = "`1` is not a positive machine integer."
EquirippleFilterKernel::arg2 = "`1` is not a machine integer greater than 1."
FrequencySamplingFilterKernel::length = "Incompatible number of frequency samples. `1` samples expected."
LeastSquaresFilterKernel::prec = FrequencySamplingFilterKernel::prec = "Value of option WorkingPrecision -> `1` is not a positive machine-sized real or integer."
FrequencySamplingFilterKernel::type = "The type `1` should be 1, 2, 3, or 4."
FrequencySamplingFilterKernel::shift = "Value of option \"Shifted\" -> `1` is not a Boolean value."
RecurrenceFilter::init = "Expecting a real number instead of `1`."
RecurrenceFilter::coeff = "Expecting a pair of non-empty vectors with the first element of the first vector being nonzero or a discrete TransferFunctionModel object instead of `1`."
BandpassFilter::invpad = BandstopFilter::invpad = DifferentiatorFilter::invpad = HilbertFilter::invpad = LowpassFilter::invpad = HighpassFilter::invpad = RecurrenceFilter::invpad = "`1` is not a valid padding specification."
Upsample::data=Downsample::data=BandpassFilter::data = BandstopFilter::data = DifferentiatorFilter::data = HilbertFilter::data = LowpassFilter::data = HighpassFilter::data = RecurrenceFilter::data = "Expecting an image, a sound, an audio or a non-empty array instead of `1`."
BandpassFilter::empty = BandstopFilter::empty = DifferentiatorFilter::empty = HilbertFilter::empty = LowpassFilter::empty = HighpassFilter::empty = "Computations resulted with an empty object."
Periodogram::sndinv = PeriodogramArray::sndinv = Spectrogram::sndinv = SpectrogramArray::sndinv = BandpassFilter::sndinv = BandstopFilter::sndinv = DifferentiatorFilter::sndinv = HilbertFilter::sndinv = LowpassFilter::sndinv = HighpassFilter::sndinv = RecurrenceFilter::sndinv = "SoundNote objects are not supported."
DifferentiatorFilter::freq = HilbertFilter::freq = LowpassFilter::freq = HighpassFilter::freq = "`1` should be a non-negative real number or a vector of such numbers."
BandpassFilter::freq = BandstopFilter::freq = "`1` should be a vector of two non-negative, ordered real numbers or a list of such vectors."
BandpassFilter::length = BandstopFilter::length = DifferentiatorFilter::length = HilbertFilter::length = LowpassFilter::length = HighpassFilter::length = "`1` should be a positive integer."
BandpassFilter::winsize = BandstopFilter::winsize = DifferentiatorFilter::winsize = HilbertFilter::winsize = LowpassFilter::winsize = HighpassFilter::winsize = "The window size `1` and filter length `2` do not match."
BandpassFilter::win = BandstopFilter::win = DifferentiatorFilter::win = HilbertFilter::win = LowpassFilter::win = HighpassFilter::win = "Invalid window type `1`."
BandpassFilter::quality = BandstopFilter::quality = "Quality factor in `1` must be a positive number."
DiscreteHadamardTransform::data = "`1` is not a numerical array."
HadamardMatrix::mtdinv = DiscreteHadamardTransform::mtdinv = "The value of option Method->`1` should be \"Sequency\" or \"BitComplement\"."
DiscreteChirpZTransform::data = "`1` is not a numerical array."
DiscreteHadamardTransform::seq = "`1` is not a Boolean value."
DiscreteChirpZTransform::length = "`1` is not a non-negative machine integer or a vector of such numbers of length `2`."
DiscreteChirpZTransform::ratio = DiscreteChirpZTransform::start = "`1` is not a nonzero number or a vector of such numbers of length `2`."
HadamardMatrix::size = "Matrix dimensions must be a power of 2."
HadamardMatrix::seq = "The value of SequencyOrdered option should be either True or False."
HadamardMatrix::arg1 = FourierDCTMatrix::arg1 = FourierMatrix::arg1 = FourierDSTMatrix::arg1 = "`1` is not a positive machine integer."
FourierMatrix::fpopt = ListFourierSequenceTransform::fpopt = "The value of the option FourierParameters -> `1` should be a vector of length 2."
ListZTransform::arg1 = ListFourierSequenceTransform::arg1 = "Expected a numeric array instead of `1`."
ListZTransform::arg3 = ListFourierSequenceTransform::arg3 = "Expected an integer or a vector of integers instead of `1`."
FourierDCTMatrix::fttype = FourierDSTMatrix::fttype = "The transform type `1` should be 1, 2, 3, or 4."
Downsample::downnull = "Downsampling specification corresponds to an empty image."
Upsample::data = Downsample::data = "Expecting a full array with positive dimensions or an image instead of `1`."
Upsample::factor = Downsample::factor = "`1` is not a positive machine integer or a vector of such numbers of length `2`."
Upsample::phase = Downsample::phase = "`1` is not a positive machine integer not larger than a corresponding factor or a vector of such numbers of length `2`."
Upsample::valarr = "`1` is not a machine-sized real number."
Upsample::valarrq = "`1` is not a machine-sized real number or a quantity."
Upsample::valimg = "`1` is not a machine-sized real number, a vector of such numbers of length `2` or a color directive."
Upsample::valimga = "`1` is not a machine-sized real number, or a vector of such numbers of length `2`."
Upsample::valaudio = "`1` is not a machine-sized real number, a vector of such numbers of length `2`."
Upsample::compatu = Downsample::compatu = "Incompatible units `1` in the input array."
SpectrogramArray::data = Spectrogram::data = ShortTimeFourier::data = "`1` is not a real-valued vector."
Spectrogram::cfun = "`1` is not a valid color function."
PeriodogramArray::data = "`1` is not a numeric array."
ImagePeriodogram::length = PeriodogramArray::length = "`1` is not a positive integer or a vector of positive integers."
ImagePeriodogram::ovlp = PeriodogramArray::ovlp = "`1` is not a positive integer or a vector of positive integers."
AudioMeasurements::fpopt = Periodogram::fpopt = ImagePeriodogram::fpopt = PeriodogramArray::fpopt = SpectrogramArray::fpopt = CepstrumArray::fpopt = ShortTimeFourier::fpopt= InverseShortTimeFourier::fpopt= CepstrogramArray::fpopt = Cepstrogram::fpopt = InverseSpectrogram::fpopt = AudioBlockMap::fpopt = "The value of the option FourierParameters -> `1` should be a real vector of length 2."
SpectrogramArray::winsize = Spectrogram::winsize = Periodogram::winsize = ImagePeriodogram::winsize = PeriodogramArray::winsize = "The window size `1` and partition size `2` do not match."
SpectrogramArray::win = Spectrogram::win = Periodogram::win = ImagePeriodogram::win = PeriodogramArray::win = "Invalid window type `1`."
ImagePeriodogram::pad = PeriodogramArray::pad = "Expecting a positive machine-integer number or a vector of such numbers instead of `1`."
Periodogram::pad = "Expecting a positive machine integer instead of `1`."
ImagePeriodogram::imginv = "Expecting an image or graphics instead of `1`.";
ImagePeriodogram::align = "`1` is not a valid alignment specification."
Periodogram::data = "Expecting a SampledSoundList, a numeric vector, or a numeric matrix instead of `1`."
SpectrogramArray::length = Spectrogram::length = Periodogram::length = "`1` is not a positive integer."
SpectrogramArray::ovlp = Spectrogram::ovlp = Periodogram::ovlp = "`1` is not a positive integer."
Periodogram::sfinv = "The value of the option ScalingFunctions -> `1` should be \"dB\" or \"Absolute\"."
Periodogram::sfinv2 = "A value of option ScalingFunctions -> `1` is not valid."
HighlightImage::bdmtd = ImageDisplacements::bdmtd = "The value of the option Method -> `1` is not valid."
ImageDisplacements::tvl1 = "Unable to find an optical flow with the method \"TotalVariation\". Using the method \"Farneback\" instead."
ImageDisplacements::npyr = "The specified number of pyramid levels `1` should be a positive integer."
ImageDisplacements::pyrf = "The specified pyramid scale factor `1` should be a positive number less than 1."
ImageDisplacements::mrad = "The specified averaging radius `1` should be a positive integer."
ImageDisplacements::mf = "The specified averaging filter `1` should be either \"Standard\" or \"Gaussian\"."
ImageDisplacements::drad = "The specified derivative radius `1` should be a positive integer."
ImageDisplacements::ival = "The value of option \"IndeterminateValue\" -> `1` should be a real number."
ImageDisplacements::npyr = "The specified number of warps `1` should be a positive integer."
ImageDisplacements::regu = "The specified regularization parameter `1` should be positive."
ImageDisplacements::relax = "The specified relaxation parameter `1` should be positive."
ImageDisplacements::timestep = "The specified time step parameter `1` should be positive."
ColorReplace::imginv = "Expecting an image or graphics instead of `1`.";
ColorReplace::color = "Expecting a nonzero binary image of size `1`, a color, or a color replacement rule instead of `2`.";
ColorReplace::thr = "The threshold argument has to be a non-negative real number or Automatic.";
ColorReplace::alpha = ImageRecolor::alpha = "The value of option \"AlphaBlending\" -> `1` should be either True or False.";
ImageRecolor::color = "Expecting a valid recolor specification instead of `2`. Possible settings are binary mask images or marker images of size `1`, colors or color neighborhoods."
DominantColors::invprop = "`1` is not a known property or a list of known properties. Supported properties are \"Color\", \"Count\", \"Coverage\", \"CoverageImage\", \"LABColor\", and \"MaskCoverage\".";
DominantColors::invnum = "`1` is not a valid number of clusters. Please specify a positive integer or Automatic.";
DominantColors::clcvrg = "Value of option ColorCoverage -> `1`\ is not Automatic or a positive machine number between 0 and 1.";
DominantColors::mindist = "Value of option MinColorDistance -> `1`\ is not Automatic or a positive machine number.";
DominantColors::level = "Expecting a positive machine integer value instead of `1`."
DominantColors::color = "Expecting a color specification instead of `1`."
DominantColors::failed = "An error occurred."
EntityList::listres = "List expected as the result of `1`.";
EntityList::entlistres = "List of entities expected as the result of `1`.";
EntityRegister::invstore = "`1` is not a valid entity store.";
EntityRegister::shadow = "Types `2` in `1` already exist. The existing ones will be shadowed.";
EntityStore::invent = "Some entries are invalid.";
EntityStore::nocanon = "The entity type \"`1`\" doesn't have a CanonicalName, because the corresponding database table doesn't have a primary key constraint. Single entities will not work."
EntityValue::tname = "`1` is not a known entity type.";
EntityValue::ename = "`1` is not a known entity of type `2`.";
EntityValue::ecname = "`1` is not a known entity class of type `2`.";
EntityValue::pname = "`1` is not a known property for entity type `2`.";
EntityValue::pcname = "`1` is not a known property class for entity type `2`.";
EntityValue::qname = "`1` is not a known qualifier of `3` property `2`.";
EntityValue::val="Variables `1` already have a value and could affect the result.";
EntityValue::batmis="Failed to download entities `1` through `2`.";
EntityValue::nodat = "Unable to download data. Some or all results may be missing.";
EntityValue::dbexcp = "A database exception occurred.";
EntityValue::ctimeout = "A computation timed out.";
EntityValue::annf = "Invalid annotations `1`.";
EntityValue::update = "Unable to contact Knowledgebase servers; cached data may be out-of-date.";
EntityValue::outdcache = "Using potentially outdated cached values.";
EntityTypeName::noent = CommonName::noent = CanonicalName::noent = EntityList::noent = EntityClassList::noent = "`1` is not an entity.";
EntityClassList::noent = "`1` is not an entity type.";
EntityProperty::pname="`1` is not a known property for entity type `2`.";
EntityProperty::qname = "`1` is not a known qualifier of `3` property `2`.";
ToEntity::noent = "No entity representation available for expression `1`.";
ToEntity::noentp = "No entity representation of type `2` available for expression `1`.";
FromEntity::norep = "No Wolfram Language representation available for `1`.";
FromEntity::notent = "Argument `1` is not an entity expression.";
RandomEntity::ntype = "`1` is not a valid type of Entity or EntityClass.";
RandomEntity::nent = "No random entities available for `1`.";
RandomEntity::insfct = "Requested `1` Entity objects, but only `2` are available.";
Transliterate::notrr = "No transliteration rules available between `1` and `2`.";
Transliterate::notrans = "Unable to transliterate between `1` and `2` for `3`.";
Transliterate::sname = "`1` is not a recognized transliteration script.";
SpellingCorrectionList::norec = "Unable to locate resource files for SpellingCorrectionList.";
DictionaryWordQ::nodict = SpellingCorrectionList::nodict = "Spelling dictionaries for `1` are not available.";
DictionaryWordQ::sstr = SpellingCorrectionList::sstr = "Argument `1` is not a string.";
DictionaryWordQ::denc = SpellingCorrectionList::denc = "Dictionary character encoding `2` for `1` is not available.";
Quantity::mradix = "Use of MixedRadix in Quantity expressions has been superseded by MixedUnit and MixedMagnitude.";
Quantity::compat = "`1` and `2` are incompatible units";
Quantity::compatu = "Incompatible units.";
Quantity::temp = "Cannot add temperature units `1` and `2`.";
Quantity::pcompat = "Cannot add units `1` and `2`.";
Quantity::invld = "Invalid unit.";
QuantityForm::form = "`1` is not a valid form specification.";
QuantityForm::notunit = "The first argument is not a Quantity or recognized unit.";
CurrencyConvert::ncdat = "Unable to retrieve historical currency conversion data.";
CurrencyConvert::dspec = "`1`' is not a recognized date specification.";
CurrencyConvert::ncur = "`1` is not a currency specification.";
UnitConvert::conopen = "Could not establish a connection to the data source.";
UnitConvert::nodat = "Could not retrieve conversion information from the data source.";
UnitConvert::mxrad = "MixedRadix unit conversion is not supported.";
UnitConvert::arrdpt = "Incompatible array depths.";
UnitSimplify::udim = "UnityDimensions specification `1` should be a list of unit dimensions or Automatic.";
IndependentUnit::invd = "`1` is an invalid unit specification.";
UnitConvert::cursys = "`1` has no standard currency in `2`.";
QuantityMagnitude::tsq = "Unable to determine QuantityMagnitude of `1`.";
QuantityUnit::tsq = "Unable to determine QuantityUnit of `1`.";
UnitSimplify::tsq = "Unable to compute UnitSimplify of `1`.";
CommonUnits::tsq = "Unable to compute CommonUnits of `1`.";
UnitDimensions::tsq = "Unable to compute UnitDimensions of `1`.";
UnitConvert::tsq = "Unable to convert units in `1` to `2`.";
General::unkunit = "Unable to interpret unit specification `1`.";
General::datedunit = "Unable to evaluate using DatedUnit. Please use InflationAdjust before evaluating `1`.";
General::mixlen = "Found MixedMagnitude list of length `1` paired with MixedUnit list of different length `2`.";
InflationAdjust::notarg = "InflationAdjust did not receive correct arguments.";
InflationAdjust::datenc = "`1` unit can only be converted from `2` to `3`.";
InflationAdjust::curnc = "InflationAdjust is not available for `1`.";
InflationAdjust::notcur = "`1` cannot be interpreted as a currency unit.";
InflationAdjust::insffd = "Date(s) specified is out of the range of coverage.";
InflationAdjust::insfferd = "Cannot fetch exchange rate conversion data for `1` to `2` for `3`.";
InflationAdjust::badcpi = "InflationMethod cannot be interpreted as a time series.";
InflationAdjust::conopen = FormulaLookup::conopen = "Could not establish a connection to the data source.";
FormulaLookup::pqlst="The value of option `1` -> `2` should be a list of strings.";
FormulaData::pq="The input for `1` has incorrect units for `2`.";
FormulaData::npq="The input for `1` is not a quantity.";
FormulaData::mnpq="The inputs for `1` are not quantities.";
FormulaData::nvfn="`1` is not a valid formula name. Use FormulaLookup[`1`] to get a list of formula names.";
FormulaData::indet="Unable to distinguish specific quantity variable for `1`";
FormulaData::nosol = "no real solution found for input parameters.";
FormulaData::overdet = "There are fewer dependent variables than equations, so the system is overdetermined.";
PlanckRadiationLaw::unit = "`1` uses incorrect units.";
PlanckRadiationLaw::notemp = "`1` is not a recognized temperature specification.";
PlanckRadiationLaw::wlfrq = "`1` is not a recognized frequency or wavelength specification.";
TideData::invdate = "Unable to interpret date.";
TideData::notent = "`1` is not a known entity, class, or tag for TideData.";
TideData::pq = "The input for `1` has the incorrect units for `2`.";
TideData::pqr = "The input for `1` is not a real-valued quantity.";
TideData::phamp = "The input for `1` has the wrong format for a phase and amplitude.";
TideData::noex = "No `1` found.";
PsychrometricPropertyData::notassoc = "Parameter value specification `1` is not an Association."
PsychrometricPropertyData::units="`1` has the incorrect units for `2`.";
PsychrometricPropertyData::tgrtr="`1` should be greater than or equal to `2`.";
PsychrometricPropertyData::pq = "The input for `1` has incorrect units for `2`."
PsychrometricPropertyData::pqr = "The input for `1` should have real values."
PsychrometricPropertyData::insuff="Insufficient independant parameters to determine result.";
PsychrometricPropertyData::pqrange="`1` should be between `2` and `3`.";
PsychrometricPropertyData::tdry="Dry bulb temperature not properly specified.";
PsychrometricPropertyData::nvhr="Humidity specified exceeds physical limits.";
PsychrometricPropertyData::overdet="Too many input parameters included, using \"DryBulbTemperature\" and \"`1`\"";
PsychrometricPropertyData::pqtype="The input for `1` should be a quantity.";
PsychrometricPropertyData::unit="`1` is an unrecognized unit system.";
SpectralLineData::usage="SpectralLineData returns the value of a specified property for a spectral line or atomic energy level.";
SpectralLineData::notent="`1` is not a known entity, class, or tag for SpectralLineData.";
SpectralLineData::notion="`1` is not a known ion for SpectralLineData. Use SpectralLineData[\"Ions\"] for a full list of ions.";
SpectralLineData::il="ionization level `1` should be a nonnegative integer less than the atomic number of the ion.";
SpectralLineData::timeout="SpectralLineData timout.";
SpectralLineData::msmtch = "Entities include a mix of atomic lines and atomic levels.";
SpectralLineData::near = "`1` is neither a non-negative integer.";
SpectralLineData::rangeunits = "The inputs `1` and `2` have the wrong units for energy, frequency, or wavelength.";
SpectralLineData::allunit = "The input `1` has the wrong units for energy, frequency, or wavelength.";
SpectralLineData::wvunit = "The input `1` has the wrong units for frequency or wavelength.";
SpectralLineData::wrtype = "The quantity specified has the wrong units for `1`.";
SpectralLineData::wrtypes = "The quantities specified have the wrong units for `1`.";
SpectralLineData::insufsrch ="\"`1`\" unspecified, insufficient information for a search.";
SpectralLineData::nreal ="Specified value for \"`1`\" isn't a real value.";
SpectralLineData::nint = "Specified value for \"`1`\" isn't a positive integer.";
SpectralLineData::irng = "Specified value for \"`1`\" isn't an integer between `2` and `3`.";
QuantityVariable::unkpq = "Unknown physical quantity specification `1`.";
DimensionalCombinations::dim="Physical quantity `1` is dimensionless and will be omitted.";
NondimensionalizationTransform::nmtch="Original variables and replacement variables have different lengths.";
NondimensionalizationTransform::invpq1="Original variables supplied include unrecognized physical quantities.";
NondimensionalizationTransform::invpq2="Equation includes physical quantities as functions other than the variables `1`.";
NondimensionalizationTransform::invequ="Equation is missing one or more variables `1`.";
NondimensionalizationTransform::unbal="Equation is dimensionally unbalanced.";
NondimensionalizationTransform::ninert="`1` is not inert when applied to other variables. NondimensionalizationTransform cannot use `1` to construct a solution.";
NondimensionalizationTransform::ngc="`1` is an invalid setting for GeneratedQuantityMagnitudes.";
NondimensionalizationTransform::nsol="No solution found.";
NondimensionalizationTransform::qv="Replacement variables include elements with physical dimensions.";
NondimensionalizationTransform::bdmtd="Value of option `1` is not Automatic, \"PlanckUnits\", \"StonyUnits\", \"DeSitterUnits\", \"HartreeAtomicUnits\", \"RydbergAtomicUnits\", \"LorentzHeavisideQuantumChromodynamicsUnits\", \"GaussianQuantumChromodynamicsUnits\", \"LorentzHeavisideNaturalUnits\", or \"GaussianNaturalUnits\".";
General::qvprm = "Argument `1` at position `2` is expected to be a quantity variable.";
ThermodynamicData::notent = "`1` is not a known entity, class, or tag for ThermodynamicData. Use ThermodynamicData[] for a list of entities.";
ThermodynamicData::notprop = "`1` is not a known property for ThermodynamicData. Use ThermodynamicData[\"Properties\"] for a list of entities.";
ThermodynamicData::bndry = "No temperature or pressure specified for `1`.";
ThermodynamicData::spec = "Both Pressure and Temperature given, using Temperature.";
ThermodynamicData::para = "Parameter list includes parameters other than Pressure and Temperature.";
ThermodynamicData::quant = "`1` is not a real number.";
ThermodynamicData::quants = "List `1` does not consist of real numbers.";
ThermodynamicData::unit = "`1` uses incorrect units.";
ThermodynamicData::time = Sunrise::time = Sunset::time = SunPosition::time = MoonPosition::time = MoonPhase::time = SolarEclipse::time = LunarEclipse::time = SiderealTime::time = DaylightQ::time = "Calculation exceeded time limit.";
AirPressureData::unit="`1` is an unrecognized unit system.";
AirPressureData::arg="Argument `1` cannot be interpreted as a date or time input.";
AirPressureData::incr="Argument `1` is not a time increment.";
AirPressureData::dorder="Date specification `1` occurs after `2`.";
AirTemperatureData::unit="`1` is an unrecognized unit system.";
AirTemperatureData::arg="Argument `1` cannot be interpreted as a date or time input.";
AirTemperatureData::incr="Argument `1` is not a time increment.";
AirTemperatureData::dorder="Date specification `1` occurs after `2`.";
WindSpeedData::unit="`1` is an unrecognized unit system.";
WindSpeedData::arg="Argument `1` cannot be interpreted as a date or time input.";
WindSpeedData::incr="Argument `1` is not a time increment.";
WindSpeedData::dorder="Date specification `1` occurs after `2`.";
WindDirectionData::arg="Argument `1` cannot be interpreted as a date or time input.";
WindDirectionData::incr="Argument `1` is not a time increment.";
WindDirectionData::dorder="Date specification `1` occurs after `2`.";
WindDirectionData::unit="`1` is an unrecognized unit system.";
WindVectorData::arg="Argument `1` cannot be interpreted as a date or time input.";
WindVectorData::incr="Argument `1` is not a time increment.";
WindVectorData::dorder="Date specification `1` occurs after `2`.";
WindVectorData::unit="`1` is an unrecognized unit system.";
AirPressureData::extended="Extended values in both location and date are not supported.";
AirTemperatureData::extended="Extended values in both location and date are not supported.";
WindSpeedData::extended="Extended values in both location and date are not supported.";
WindDirectionData::extended="Extended values in both location and date are not supported.";
WindVectorData::extended="Extended values in both location and date are not supported.";
WeatherData::notentity="`1` is not a valid entity for `2`.";
WeatherData::interval="Invalid value `1` for option IntervalValue.";
WeatherData::extr= "`1` represents an extended geographic region; using `2` for calculations.";
StandardAtmosphereData::qdim="`1` is not a unit of length.";
StandardAtmosphereData::qrange="The altitude `1` falls outside of the supported range from `2` to `3` Meters.";
StandardAtmosphereData::nsupport="`1` is not supported for `2`.";
EarthquakeData::compat1 = "`1` is not compatible with distance.";
EarthquakeData::compat2 = "`1` is not compatible with angular degrees.";
EarthquakeData::notentity = "`1` is not a valid entity for EarthquakeData.";
EarthquakeData::notmag = "Magnitude `1` should be a number between -1 and 10.";
EarthquakeData::notmags = "Magnitudes `1` should be minimum and maximum values in the range -1 to 10.";
EarthquakeData::datespec = "Date `1` is incorrectly formatted.";
EarthquakeData::datespec2 = "Date `1` should be earlier than `2`.";
EarthquakeData::dupdate = "Earthquakes returned with duplicate dates, values may be combined.";
EarthquakeData::notprop = "`1` is not a known property or list of properties for EarthquakeData. Use EarthquakeData[\"Properties\"] to find a list of available properties.";
EarthquakeData::notsup = "Time series output for `1` is not supported.";
UniverseModelData::qdim="`1` is not a positive unit of `2`.";
UniverseModelData::time="Model only supports times larger than `1` after the Big Bang.";
UniverseModelData::nsupport="`1` is not supported for `2`.";
UniverseModelData::model="`1` is not a known model.";
UniverseModelData::usum="Total of universe components is greater than 1.";
UniverseModelData::udim="`1` is not a positive percentage or number.";
UniverseModelData::unbal="Total of universe components do not balance with supplied curvature.";
UniverseModelData::notspec = "`1` is not a valid specification for `2`.";
WeatherForecastData::nloc="`1` is not a valid location or region.";
WeatherForecastData::invdate="Invalid date specification.";
WeatherForecastData::invdates="Invalid specification of dates.";
WeatherForecastData::dorder="Date specification `1` occurs after `2`.";
WeatherForecastData::incr="Argument `1` is not a time increment.";
WeatherForecastData::notent = "`1` is not a known entity, class, or tag for WeatherForecastData.";
GeoDisk::badformat = "Improperly formatted GeoDisk specification.";
GeoDisk::coord = "`1` exceeds the value possible on a globe.";
DateObject::str = "String `1` cannot be interpreted as a date.";
TimeObject::str = "String `1` cannot be interpreted as a time.";
DateObject::tzstr = "String `1` cannot be interpreted as a time zone.";
DateObject::nodate = "Unable to interpret date specification `1`.";
DateObject::ambig = "Warning: the interpretation of the string `1` as a date is ambiguous.";
DateObject::notgran = "`1` is not a valid granularity specification for calendar `2`.";
TimeObject::notgran = "`1` is not a valid time object granularity specification.";
DateObject::carg = "`1` is not a recognized date specification for calendar `2`.";
General::ngran = "`1` is not a recognized date granularity specification.";
PreviousDate::arg = CurrentDate::arg = NextDate::arg = "Argument `1` cannot be interpreted as a date or time input.";
PreviousDate::ncday = CurrentDate::ncday = NextDate::ncday = "Reference date `1` does not match the specified day type `2`.";
TimeZoneConvert::dobj = CalendarConvert::dobj = "`1` is not a valid DateObject specification.";
General::nodobj = "First argument `2` in `1` is not a DateObject.";
General::tzett = "Unable to determine TimeZone for `1`.";
TimeZoneConvert::notz = "Argument `1` in TimeZoneConvert is not a valid TimeZone specification.";
CalendarConvert::nocal = "Argument `1` in CalendarConvert is not a known CalendarType specification.";
General::nocal = "`1` is not a recognized CalendarType specification.";
General::nodcc = "`1` is not a recognized DayCountConvention specification.";
General::holc = "`1` is not a recognized HolidayCalendar specification.";
General::inc = "`2` is not a recognized calendar increment specification for `1`.";
DayRange::endpts = "IncludeEndPoints specification `1` should be a Boolean or a pair of Boolean values."
CalendarConvert::dgran = "Date `1` with granularity `2` cannot be converted to calendar type `3`.";
DateObject::zone = "Argument `1` in DateObject is not a recognized TimeZone specification.";
DateObject::nocal = "Argument `1` in DateObject is not a known CalendarType specification.";
DateObject::form = "Argument `1` in DateObject cannot be interpreted as a date string format";
DateFormat::notvalid = "Argument `1` is not a valid date format.";
DateBounds::arg = "Argument `1` is not a list of date specifications or a recognized data structure with dates.";
DateBounds::ndate = "`1` is not a recognized date specification.";
DateBounds::dbnots = "Databin `1` does not specify date bounds.";
ImageMeasurements::invprop = "`1` is not a known image measurements property."
ImageMeasurements::imginv = "Expecting an image or a graphic instead of `1`."
ImageFileFilter::bdmtd = ImageFileScan::bdmtd = ImageFileApply::bdmtd = "Expecting a list of suboptions \"ImageList\" and \"MaxBlockSize\" instead of `1`."
ImageFileFilter::input = ImageFileScan::input = ImageFileApply::input = "Expecting a file name instead of `1`."
ImageFileFilter::output = ImageFileScan::output = ImageFileApply::output = "Expecting a file name instead of `1`."
ImageFileFilter::fnexst = ImageFileScan::fnexst = ImageFileApply::fnexst = "File `1` does not exist."
ImageFileFilter::ftype = ImageFileScan::ftype = ImageFileApply::ftype = "File format `1` is not supported."
ImageFileFilter::fsame = ImageFileScan::fsame = ImageFileApply::fsame = "The output file must be different than the input file."
ImageFileFilter::frame = ImageFileScan::frame = ImageFileApply::frame = "Expecting an integer number or a list of integers from 1 to `1` instead of `2`."
ImageFileFilter::err = ImageFileScan::err = ImageFileApply::err = "Error occurred during computations."
ImageFileFilter::maxblk = ImageFileScan::maxblk = ImageFileApply::maxblk = "The value of option MaxBlockSize->`1` should be a positive machine integer."
ImageFileFilter::bdf = ImageFileApply::bdf = "Applying `1` to the input image does not yield a number or list of numbers."
ImageFileFilter::bdfr = ImageFileApply::bdfr = "Applying `1` to the input image does not yield a number."
ImageFileFilter::bdn = "`1` is not a valid neighborhood specification."
Image3DSlices::arg1 = "Expecting Image or Image3D instead of `1`."
Image3DSlices::slices = "Expecting All, an integer value, or a vector of integer values between 1 and `2` instead of `1`."
Image3DSlices::dims = "Expecting an integer value between 1 and 3 instead of `1`."
Indexed::itv = "`1` is not a list or valid tensor variable."
Indexed::scal = "`1` is not a tensor."
Indexed::ind = "The index `1` is not a nonzero integer."
General::itdim = "The dimensionality of variable `1` is not well specified."
General::realc = "`1` should be a non-empty list of real-valued quantities."
General::realn = "`1` should be a length `2` list of real-valued quantities."
General::realnl = "`1` should be a real-valued point or list of points in dimension `2`."
General::elemc = "Unable to resolve the domain or region membership condition `1`."
General::vecin = "Unable to resolve vector inequalities `1`."
AngularGauge::scerr=ClockGauge::scerr=HorizontalGauge::scerr=VerticalGauge::scerr=BulletGauge::scerr=ThermometerGauge::scerr="Gauge range is not valid with provided scaling function."
AngularGauge::poserr=ClockGauge::poserr=HorizontalGauge::poserr=VerticalGauge::poserr=BulletGauge::poserr=ThermometerGauge::poserr="The endpoints for the scale cannot be the same."
AngularGauge::scalespec=ClockGauge::scalespec=HorizontalGauge::scalespec=VerticalGauge::scalespec=BulletGauge::scalespec=ThermometerGauge::scalespec="`1` is an invalid specification for the scale origin."
AngularGauge::padspec=ClockGauge::padspec=HorizontalGauge::padspec=VerticalGauge::padspec=BulletGauge::padspec=ThermometerGauge::padspec="`1` is an invalid specification for the scale padding."
AngularGauge::framespec=ClockGauge::framespec=HorizontalGauge::framespec=VerticalGauge::framespec=BulletGauge::framespec=ThermometerGauge::framespec="Frame width must be a positive number."
AngularGauge::divspec=ClockGauge::divspec=HorizontalGauge::divspec=VerticalGauge::divspec=BulletGauge::divspec=ThermometerGauge::divspec="`1` is not a positive integer or list of two positive integers."
AngularGauge::scalerangespec=ClockGauge::scalerangespec=HorizontalGauge::scalerangespec=VerticalGauge::scalerangespec=BulletGauge::scalerangespec=ThermometerGauge::scalerangespec="Value of option ScaleRangeSize -> `1` is not a number or list of numbers."
AngularGauge::gfacespec=ClockGauge::gfacespec=HorizontalGauge::gfacespec=VerticalGauge::gfacespec=BulletGauge::gfacespec=ThermometerGauge::gfacespec="Value of option GaugeFaceElementFunction -> `1` is not a valid face element function or an appropriate ChartElementData entity."
AngularGauge::gframespec=ClockGauge::gframespec=HorizontalGauge::gframespec=VerticalGauge::gframespec=BulletGauge::gframespec=ThermometerGauge::gframespec="Value of option GaugeFrameElementFunction -> `1` is not a valid frame element function or an appropriate ChartElementData entity."
AngularGauge::fszspec=ClockGauge::fszspec=HorizontalGauge::fszspec=VerticalGauge::fszspec=BulletGauge::fszspec=ThermometerGauge::fszspec="`1` is not a valid specification for the frame size.";
AngularGauge::gaugesty=ClockGauge::gaugesty=HorizontalGauge::gaugesty=VerticalGauge::gaugesty=BulletGauge::gaugesty=ThermometerGauge::gaugesty="Value of option `1` -> `2` is not a style or group of styles."
AngularGauge::invrange=ClockGauge::invrange=HorizontalGauge::invrange=VerticalGauge::invrange=BulletGauge::invrange=ThermometerGauge::invrange="`1` is not a valid specification for the range of the gauge."
ClockGauge::badarg="`1` is not a valid specification for the time."
ReplacePixelValue::imginv = ReplaceImageValue::imginv = "Expecting an image or a graphics instead of `1`."
ReplacePixelValue::reps = ReplaceImageValue::reps = "`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing."
ReplacePixelValue::imgdtype = ReplaceImageValue::imgdtype = "`1` is not a valid type."
ImageValue::bddatarange = ReplaceImageValue::bddatarange = "Value of DataRange -> `1` is not Automatic, Full, or a list of the form `2`."
ImageValuePositions::imginv = PixelValuePositions::imginv = "Expecting an image or a graphics instead of `1`."
ImageValuePositions::vals = PixelValuePositions::vals = "`1` is not a valid color specification or list of channel values."
ImageValuePositions::thr = PixelValuePositions::thr = "`1` is not a valid threshold value."
ImageValuePositions::chan = PixelValuePositions::chan = "The number of image channels `1` does not match the length of values `2`."
ImageValuePositions::csmis = PixelValuePositions::csmis = "The color space `1` and the color specification `2` are not compatible."
ImageDistance::imgicmp = "The number of channels of the two images are not compatible."
ImageDistance::mask = "Masking -> `1` is not a valid mask specification."
ImageDistance::bdfun = "DistanceFunction -> `1` is not a valid distance function."
ImageDistance::nbins = "The specified number of bins `1` should be an integer greater than 1."
ImageValue::imgrng = PixelValue::imgrng = "The specified argument `1` should be an image, a graphics object, or a list of coordinates."
ImageData::imgdargs = ConstantImage::bdtype ="The specified data type `1` should be \"Bit\", \"Byte\", \"Bit16\", \"Real32\", \"Real64\", or Automatic."
QueueProperties::nque = "The first argument `1` is not a valid specification for a queueing process or data."
QueueProperties::ndes = "`1` is not a valid specification for the third argument."
QueueProperties::ndef = "QueueProperties has no value associated with `1`."
QueueProperties::netni = "The node specification `1` is not a positive integer less than `2`."
QueueProperties::qsimt = "Values of performance measures are based on simulation data for the queueing process."
QueueProperties::qsimp = "Value of performance measure is based on simulation data for the queueing process."
TemporalData::emptpths = "Each path is expected to be non-empty."
TemporalData::emptpth = TimeSeries::emptpth = EventSeries::emptpth = "Path is expected to be non-empty."
TimeSeries::mltpth = EventSeries::mltpth = "`1` paths were provided. A single path is expected."
TemporalData::ntprs = TimeSeries::ntprs = EventSeries::ntprs = "The argument `1` at position 1 is expected to be a list of time\[Hyphen]value pairs or a list of states with equal dimensionality."
TemporalData::stspcln = "The number of paths implied by the states `1` and time stamps `2` do not match."
TemporalData::invstrct = TimeSeries::invstrct = EventSeries::invstrct = "The data `1` is not a structurally valid TemporalData object."
TemporalData::bdslc = TimeSeries::bdslc = EventSeries::bdslc = "The input `1` cannot be interpreted as a time point or list of time points."
TemporalData::symbsts = "The empirical slice distribution is not implemented for non\[Hyphen]numeric states."
TemporalData::noimp = "Joint empirical slice distributions are not implemented for TemporalData with multivariate state space."
TemporalData::prtrng = "No data was found for times specified by `1`."
TemporalData::prtspc = TimeSeries::prtspc = EventSeries::prtspc = "Unable to determine the times intended by `1`."
TemporalData::dpcts = "Duplicate time stamps were found. Time stamps should be unique."
TemporalData::badarg = TimeSeries::badarg = EventSeries::badarg = "The lengths implied by the states `1` and time stamps `2` do not match."
TemporalData::vldmns = TimeSeries::vldmns = EventSeries::vldmns = "The value dimension `1` is expected to be Automatic, a positive integer, or a list of positive integers."
TemporalData::dmmtch = TimeSeries::dmmtch = EventSeries::dmmtch = "The dimensions of the elements of `1` should match."
TemporalData::dmnsns = TimeSeries::dmnsns = EventSeries::dmnsns = "The dimensionality implied by the states in `1` is mixed. A single-state dimensionality is expected."
TemporalData::dmmtch2 = TimeSeries::dmmtch2 = EventSeries::dmmtch2 = "The dimensionality of the time series values `1` is inconsistent with ValueDimensions->`2`."
TemporalData::pthspc = "The path specification `1` is expected to be one of All, a positive integer less than or equal to the number of paths, a list of such integers, or a span corresponding to such a list."
TemporalData::cmpntspc = "The component specification `1` is expected to be one of All, a positive integer less than or equal to the value dimensions, a list of such integers, or a span corresponding to such a list."
TemporalData::tpspc = TimeSeries::tpspc = EventSeries::tpspc = "The time specification `1` should be one of Automatic, a time range, a list containing a list of explicit times, or a list containing one such specification for each path in the data."
TemporalData::msngmthd = TimeSeries::msngmthd = EventSeries::msngmthd = "The missing data method is not valid."
TemporalData::ntsmdm = TimeSeries::ntsmdm = EventSeries::ntsmdm = "The dimensionality of values in time series `1` is expected to be the same."
TemporalData::pfnmthd = "Path function failed to be created with the current setting of ResamplingMethod option."
TemporalData::zohfrm = "Path function continuity option \"HoldFrom\"->`1` is expected to have value of Left, Right, or Automatic."
TemporalData::novrlp = TimeSeries::novrlp = EventSeries::novrlp = "Time domains of arguments are expected to overlap."
TemporalData::msngv = "Time series is expected to have some non-missing values."
General::ntrlpth = "The data `1` is expected to contain real\[Hyphen]valued states."
General::bdsinc = "Coercing input to regularly sampled time series with step `1` failed."
General::tmpln = "Uniformly spaced sampling expected in `1`."
General::nimptnsr = "Not currently implemented for tensors of dimensions `1`."
General::invldd = "The input data `1` should be a vector or a matrix of real numbers or a valid TemporalData object."
General::invldgd = "The input data `1` should be a vector or a matrix or a valid TemporalData object."
General::bdlag = "The lag specification `1` should be a symbol, an integer with magnitude less than the length of the data, or a range specification indicating such integers."
General::unisp = "Uniformly sampled data expected at position `1` in `2`."
TimeSeriesResample::cmnt = "The set of time points common to all paths of `1` is expected to be non-empty."
TimeSeriesResample::negdt = "The sampling increment `1` must be positive."
TimeSeriesResample::emptpth = "No data was found for the resampling specification `1` for at least one path."
TimeSeriesThread::tspcs = TimeSeriesInsert::tspcs = "Time series arguments with an equal number of paths are expected."
TimeSeriesInsert::bdtmt = "The argument `1` is expected to be a valid time stamp."
TimeSeriesThread::nots = "The second argument `1` must be an non-empty list of time series or a multi-path TemporalData."
TimeSeriesMapThread::eqlen = "The argument `1` must be a list of lists whose lengths are equal to lengths of each data sequence `2`."
MovingMap::bdwndwspc = TimeSeriesAggregate::bdwndwspc = "The window specification `1` is invalid."
MovingMap::ewpad = "Use of event-based window size implies `2` padding, padding specification `1` is being ignored.";
MovingMap::ewcl = "Use of event-based window size implies closed-closed windows, specification `1` is being ignored.";
TimeSeriesShift::kspec = "The shift specification `1` is invalid."
TimeSeriesWindow::bdtmn = "The left point of the window specification `1` is expected to be a valid date or a numeric expression."
TimeSeriesWindow::bdtmx = "The right point of the window specification `1` is expected to be a valid date or a numeric expression."
TimeSeriesWindow::bdinf = "The window specification `1` is incompatible with the time stamps."
TimeSeriesWindow::bdiep = "The IncludeWindowTimes option value of `1` is expected to be True, False, or a list of two such values."
TimeSeriesWindow::tswndt = "The window `1` contains no values."
PartialCorrelationFunction::bdlag = "The lag specification `1` should be a symbol, a nonzero integer with magnitude less than the length of the data, or a range specification indicating such integers."
PartialCorrelationFunction::nonwkst = "The process is not weakly stationary."
PartialCorrelationFunction::farg = "{} is not a valid process or data input."
AbsoluteCorrelationFunction::nonwkst = "The process is not weakly stationary."
AbsoluteCorrelationFunction::farg = "{} is not a valid process or data input."
CorrelationFunction::nonwkst = "The process is not weakly stationary."
CorrelationFunction::farg = "{} is not a valid process or data input."
CovarianceFunction::nonwkst = "The process is not weakly stationary."
CovarianceFunction::farg = "{} is not a valid process or data input."
PowerSpectralDensity::cutoff = "The cutoff value `1` should be a positive integer less than the length of the data or Automatic."
PowerSpectralDensity::wfnctn = "The window function `1` should be Automatic, a real vector with values between -1 and 1, or a function."
PowerSpectralDensity::farg = "{} is not a valid process or data input."
RandomFunction::unsproc = "The specification `1` is not a random process recognized by the system."
RandomFunction::err = "Process path generation resulted in an error."
RandomFunction::tspec = "The time specification `1` is not valid for simulating `2`."
MorphologicalComponents::mtd3d = "`1` method does not work with Image3D objects and arrays of rank 3."
EstimatedProcess::invprc = "The argument `1` at position 2 must be a valid random process or process template."
FindProcessParameters::invprc = "The argument `1` at position 2 must be a valid random process."
EstimatedProcess::strtv = FindProcessParameters::strtv = "The argument `1` at position 3 should be Automatic, an instantiated random process, or a list of parameter\[Hyphen]value pairs corresponding to the unspecified parameters in `2`."
EstimatedProcess::ntsprt = FindProcessParameters::ntsprt = "One or more data points are not in the support of the process `1`."
EstimatedProcess::mlnimp = FindProcessParameters::mlnimp = "Estimation is not currently supported for the parameters in process `1`."
EstimatedProcess::noseas = FindProcessParameters::noseas = "Estimation with unspecified seasonality is currently not supported."
EstimatedProcess::tlrgd = FindProcessParameters::tlrgd = "There is insufficient data to support the integration order `1`."
EstimatedProcess::nosol = FindProcessParameters::nosol = "The moment equation(s) yielded no admissible solution."
EstimatedProcess::itrtvmthd = FindProcessParameters::itrtvmthd = "The method `1` requires all estimated parameters to be distinct."
UnitRootTest::spsvd = "The temporal data object `1` should contain a single, uniformly spaced path with scalar\[Hyphen]valued states."
UnitRootTest::invldpzr = "The model value `1` is expected to be one of Automatic, \"Constant\", \"Drift\", or an integer less than `2`."
UnitRootTest::urtnlv = "The order specified by the model value `1` is greater than 1. Tests in `2` are restricted to first order testing."
ItoProcess::vdr = StratonovichProcess::vdr = "The requested simulation method is specific to process with one-dimensional driving noise. Method StochasticRungeKutta will be used instead."
General::simflr = "Simulation of process `1` failed."
DiscreteMarkovProcess::dmnorm = "The transition matrix had some row sums that were not 1, so those rows have been adjusted by dividing by the row sum or by setting the diagonal element to 1."
ContinuousMarkovProcess::cmnorm = "The transition rate matrix had some row sums that were not 0, so the diagonal element for those rows has been set to the negative sum of the remaining row elements."
DiscreteMarkovProcess::hmnorm = ContinuousMarkovProcess::hmnorm = HiddenMarkovProcess::hmnorm = "The initial state vector, transition matrix, and/or emission matrix have been normalized such that rows sum to 1."
ARProcess::nonwkst = ARMAProcess::nonwkst = SARMAProcess::nonwkst = "The process is not weakly stationary."
ARProcess::invld = MAProcess::invld = ARMAProcess::invld = ARIMAProcess::invld = SARMAProcess::invld = SARIMAProcess::invld = "Parameters of the process `1` have unexpected structure."
ARIMAProcess::nonwkst = FARIMAProcess::nonwkst = SARIMAProcess::nonwkst = "The appropriate difference of the process is not weakly stationary."
General::arprm = "The value `1` at position `2` in `3` is expected to be an array of real numbers."
ARCHProcess::nonwkst = GARCHProcess::nonwkst = "The process is not weakly stationary."
TimeSeriesForecast::covmthd = "Covariance method is not supported since the process is not weakly stationary."
TimeSeriesForecast::nonwkst = "The process `1` is not weakly stationary."
TimeSeriesForecast::noniwkst = KalmanFilter::noniwkst = "The appropriate difference of the process `1` is not weakly stationary."
TimeSeriesForecast::klmnnmrc = "The parameters of `1` are expected to be numeric."
TimeSeriesForecast::noninv = "Failed to find the invertible representation for the given process. Forecast may be not reliable. Use different method for a reliable result."
TimeSeriesForecast::badlag = "The lag specification `1` should be an integer with magnitude less than the length of the data or a range specification indicating such integers."
KalmanFilter::klmnnmrc = "The parameters of `1` are expected to be numeric."
KalmanFilter::klmnest = "KalmanEstimator failed for the given time series process."
ToInvertibleTimeSeries::inv = "Invertible representation does not exist for this time series."
ToInvertibleTimeSeries::nmrcma = "ToInvertibleTimeSeries requires all moving-average coefficients to be numeric."
RenewalProcess::posdom = "Position 1 of `1` must be a distribution with a positive domain."
RenewalProcess::mconv = "The mean approximation algorithm failed to converge."
TransformedProcess::prmth = "The processes in `1` should be all continuous-time or all discrete-time."
CompoundRenewalProcess::posdom = "Position 1 of `1` must be a distribution with a positive domain."
Dilation::knlinv = Erosion::knlinv = Opening::knlinv = Closing::knlinv = TopHatTransform::knlinv = BottomHatTransform::knlinv = "The dimensions of the input and the kernel do not match."
ColorProfileData::iccinv = "Invalid ColorProfileData object `1`."
General::insffdt = "There is insufficient data to proceed with the computation. The data must contain at least `1` elements."
General::insffnt = "There is insufficient data to proceed with the computation."
General::i3dnsup = "Image3D is not supported yet."
SymmetricMatrixQ::nbivpf = HermitianMatrixQ::nbivpf = AntisymmetricMatrixQ::nbivpf = AntihermitianMatrixQ::nbivpf = "`1` is not a two-argument pure Boolean function.";
AutocorrelationTest::badlag = "The lag specification `1` should be Automatic or a positive integer less than the length of the data."
AutocorrelationTest::mvtsni = "The data `1` should contain scalar\[Hyphen]valued states."
AutocorrelationTest::wrnddrp = "The data contains `1` paths. Only the first path will be considered in the test."
AutocorrelationTest::acttsdt = "The data `1` cannot be interpreted as a list of time\[Hyphen]value pairs."
TimeSeriesModelFit::mvtsni = "The data `1` is not scalar\[Hyphen]valued. Multivariate support is not currently implemented."
TimeSeriesModelFit::wrnddrp = "Only the first path in `1` will be used in the analysis. Multi\[Hyphen]path support is not currently implemented."
TimeSeriesModelFit::tsmfdt = "The data `1` cannot be interpreted as real\[Hyphen]valued temporal data."
TimeSeriesModelFit::fslct = "The model family specification `1` is not valid."
TimeSeriesModelFit::prslct = "The model family parameterization in `1` is not valid."
TimeSeriesModelFit::nmdlft = "None of the candidate models could be successfully fitted to the data. Try a different model family or set of candidate models."
TimeSeriesModelFit::noimp = "Unable to fit the model family `1` to the data. Estimation for the `1` family is not currently implemented."
TimeSeriesModelFit::tlrgd = "There is insufficient data to support the integration order `1`."
TimeSeriesModelFit::tlrgcmbd = "There is insufficient data to support the combined seasonal in non\[Hyphen]seasonal integration orders `2` and `1`."
TimeSeriesModelFit::frmicb = "The setting for IncludeConstantBasis `1` should be False or Automatic for fractionally integrated models."
TimeSeriesModelFit::grchicb = "The setting for IncludeConstantBasis `1` should be True or Automatic for conditionally heteroscedastic models."
TimeSeriesModelFit::armaftmthd = "The ARMA fitting method setting `1` is not valid."
TimeSeriesModelFit::insfdt = "There is insufficient data to estimate the model `1`."
TimeSeriesModelFit::ctinvt = "Unable to find an invertible representation of the model."
TimeSeriesModel::bdtmslc = "The specification `1` is not a valid time. Give a number or valid date."
TimeSeriesModel::noimp = "Backward forecasts are not yet implemented for time series models."
TimeSeriesModelFit::bdslmthd = "The selection method `1` is not valid. Use one of Automatic, \"Stepwise\", or \"GridSearch\"."
TimeSeriesModelFit::slcrt = "The selection criterion `1` is not valid. Use one of Automatic, \"AIC\", \"AICc\", \"BIC\", or \"SBC\"."
TimeSeriesModelFit::marlag = "The maximum autoregressive order specification `1` should be a non-negative integer or Infinity."
TimeSeriesModelFit::mmalag = "The maximum moving-average order specification `1` should be a non-negative integer or Infinity."
TimeSeriesModelFit::maxstep = "The maximum stepwise step size `1` should be a positive integer."
TimeSeriesModelFit::tsmfmc = "The maximum number of candidates to retain `1` should be a positive integer or Infinity."
TimeSeriesModel::bdlgmx = "The maximum lag specification `1` should be a positive integer."
TimeSeriesRescale::trng = "The argument `1` is not a valid pair of strictly increasing time points."
General::rsmplng = "The data is not uniformly spaced and will be automatically resampled to the resolution of the minimum time increment."
NExpectation::nrsmpls = "Unable to generate the necessary samples from `1`."
NProbability::nrsmpls = "Unable to generate the necessary samples from `1`."

(* The following messages are copied from Finance//*.m files *)
TimeValue::rtpers="Not enough rates have been specified for a valuation over all periods."
TimeValue::datac="All dates given must be specified to the same degree of accuracy."
TimeValue::rtzero="0 is not a period. The period ranging from time point 0 to -1 is defined to be period -1."
TimeValue::rtpers="Not enough rates have been specified for a valuation over all periods."
TimeValue::rtpers2="Not enough rates have been specified for a valuation over all periods. Cash flow periods and rate periods must coincide."
TimeValue::whicherr="Default value of True was encountered in a Which statement indicating possible code exception. Please notify Wolfram Research, Inc."
TimeValue::indet="Convergence of amount is ambiguous with a non-numeric rate."
TimeValue::noclos="No closed-form representation can be found. Attempting an open-form solution."
TimeValue::pmterr="Warning: the initial payment specified does not match the payment implied by the growth function. Using the growth function payment."
FinancialBond::invday="Invalid day count specification."
FinancialBond::invint="Coupon interval must be numeric when dates are used."
FinancialBond::bndval="The value period given is outside the range of the bond's existence."
FinancialBond::rtpers="Not enough rates have been specified for a valuation over all periods."
FinancialBond::incons="The maturity and settlement are inconsistent data types."
FinancialBond::zerocoup="A zero coupon interval specifies continuous coupon payment and must be used with a coupon function."
FinancialBond::zerort="A zero coupon interval cannot be used with a list of rates."
FinancialBond::nummat="When a rate schedule is used, the maturity, the settlement, and the coupon interval must be numeric."
FinancialBond::faczer="A face value is necessary when specifying the coupon as a rate."
DSolveValue::dsvb = "There are multiple solution branches for the equations, but DSolveValue will return only one. Use DSolve to get all of the solution branches."
RSolveValue::rsvb = "There are multiple solution branches for the equations, but RSolveValue will return only one. Use RSolve to get all of the solution branches."
ColorNegate::imginv = "`1` should be a valid image, a color directive, or a list of such objects."
LunarEclipse::arg = MoonPhase::arg = MoonPosition::arg = SolarEclipse::arg = SunPosition::arg = Sunrise::arg = Sunset::arg = SiderealTime::arg = DaylightQ::arg = "`1` is an invalid argument."
MoonPosition::locfun = SunPosition::locfun = Sunrise::locfun = Sunset::locfun = SiderealTime::locfun = "The location function `1` should be Automatic, Max, Min, Mean, or Interval."
MoonPosition::coord = SunPosition::coord = "The coordinate system `1` should be \"Equatorial\" or \"Horizon\". \"Horizon\" will be used instead."
MoonPosition::altm = SunPosition::altm = "The altitude method `1` should be \"TrueAltitude\" or \"ApparentAltitude\". \"TrueAltitude\" will be used instead."
LunarEclipse::evincr = SolarEclipse::evincr = Sunrise::evincr = Sunset::evincr = "`1` is expected to be 1 or -1. 1 will be used instead."
SolarEclipse::ectype="`1` is expected to be one of Automatic, \"Annular\", \"Hybrid\",\"Partial\", or \"Total\". Automatic will be used instead."
LunarEclipse::ectype="`1` is expected to be one of Automatic,\"Partial\",or \"Total\". Automatic will be used instead."
MoonPosition::locdate= SunPosition::locdate= Sunrise::locdate= Sunset::locdate= SiderealTime::locdate = DaylightQ::locdate = "`1` is not a valid location or date specification."
MoonPosition::loc= SunPosition::loc= Sunrise::loc= Sunset::loc= SiderealTime::loc = LocalTime::loc = LocalTimeZone::loc = DaylightQ::loc = "`1` is not a valid location specification."
LunarEclipse::dtspec= MoonPhase::dtspec= MoonPosition::dtspec= SolarEclipse::dtspec= SunPosition::dtspec= Sunrise::dtspec= Sunset::dtspec= LocalTime::dtspec = LocalTimeZone::dtspec = DaylightQ::dtspec = SiderealTime::dtspec = "`1` is not a valid date specification."
MoonPosition::dtoba= SunPosition::dtoba= Sunrise::dtoba= Sunset::dtoba="`1` is not Automatic, DateObject, or TimeObject. Automatic will be used instead."
DaylightQ::angtst = "`1` is an invalid angle test argument.";
DaylightQ::incspec = "`1` is not \"Everywhere\", \"Somewhere\", or \"Nowhere\".";
AnatomyPlot3D::missmod = "Unable to obtain a 3D model for `1`.";
LocalTime::geofun = LocalTimeZone::geofun = "`1` is not a valid function for extended regions.";
LocalTime::nores = LocalTimeZone::nores = "Unable to get `1` for `2` on `3`.";
LocalTime::servm = LocalTimeZone::servm = "`1` failed with an unknown server message.";
DateOverlapsQ::arg = DateWithinQ::arg = "Argument `1` is not a valid date object expression.";
DateValue::noelem = "`1` is not a recognized element specification.";
DateValue::arg = "Argument `1` cannot be interpreted as a date or time input";
DateValue::elemis = "`1` is not an extractable element for `2`.";
DateValue::etype = "`1` is not a valid type specification for `2`.";
UnixTime::arg = JulianDate::arg = "Argument `1` cannot be interpreted as a date or time input.";
UnixTime::tzdif = JulianDate::tzdif = "Specified timezone `1` conflicts with timezone `2` in `3`; using timezone `2`.";
JulianDate::jdtp = FromJulianDate::jdtp = "Argument `1` is not a recognized Julian date variant.";
FromUnixTime::arg = "Argument `1` cannot be interpreted as a Unix time input.";
FromJulianDate::arg = "Argument `1` cannot be interpreted as a Julian date input.";
FromAbsoluteTime::arg = "Argument `1` cannot be interpreted as an absolute time input.";
PreviousDate::nocal = CurrentDate::nocal = NextDate::nocal = "`1` is not a known CalendarType specification.";
BarcodeImage::err = "Unknown error occurred.";
BarcodeImage::data = "Expecting a string instead of `1`.";
BarcodeImage::format = "Expecting \"Aztec\", \"Codabar\", \"Code39\", \"Code128\", \"DataMatrix\", \"EAN8\", \"EAN13\", \"ITF\", \"PDF417\", \"QR\", or \"UPC\" instead of `1`.";
BarcodeImage::imgsize = "Expecting a pair of positive machine integer values instead of `1`.";
BarcodeImage::upca = "Expecting a string of 11 or 12 digits instead of `1`.";
BarcodeImage::upcacs = "Invalid UPC checksum `1`. The correct value `2` will be used.";
BarcodeImage::ean13 = "Expecting a string of 12 or 13 digits instead of `1`.";
BarcodeImage::ean13cs = "Invalid EAN13 checksum `1`. The correct value `2` will be used.";
BarcodeImage::ean8 = "Expecting a string of 7 or 8 digits instead of `1`.";
BarcodeImage::ean8cs = "Invalid EAN8 checksum `1`. The correct value `2` will be used.";
BarcodeImage::code39 = "Expecting a string of length 80 or less containing uppercase letters, numeric digits, or special characters (-, ., $, /, +, %, and space) instead of `1`.";
BarcodeImage::code128 = "Expecting a string of length 80 or less containing printable ASCII characters instead of `1`.";
BarcodeImage::qr = "Expecting a string of characters defined in ISO/IEC 8859-1 of length up to `2`, a string of alphanumeric characters of length `3`, or a string of digits of length up to `4` instead of `1`.";
BarcodeImage::dmatrix = "Expecting a string of characters defined in ISO/IEC 8859-1 of length up to 2335 or a string of digits of length up to 3116 instead of `1`.";
BarcodeImage::aztec = "Expecting a string of characters defined in ISO/IEC 8859-1 of length up to 3000 or a string of digits of length up to 3748 instead of `1`.";
BarcodeImage::pdf417 = "Expecting a string of characters defined in ISO/IEC 8859-1 of length between 2 and 1781 or a string of digits of length between 2 and 2610 instead of `1`.";
BarcodeImage::pdflev = "Level `1` is currently not supported.";
BarcodeImage::itf = "`1` should be a string containing only digits, and whose length is even and no greater than 80.";
BarcodeImage::codabar = "Expecting a string containing digits or special characters (-, $, :, /, +, .) instead of `1`.";
BarcodeRecognize::err = "Unknown error occurred.";
BarcodeRecognize::format = "Expecting \"Aztec\", \"Codabar\", \"Code39\", \"Code93\", \"Code128\", \"DataMatrix\", \"EAN8\", \"EAN13\", \"ExpandedGS1\", \"GS1\", \"ITF\" , \"MaxiCode\", \"PDF417\", \"QR\", \"UPC\", \"UPCE\", or a list of these formats instead of `1`.";
BarcodeRecognize::props = "Expecting \"BoundingBox\", \"Data\", \"Format\", \"Orientation\", or a list of these properties instead of `1`."
General::noclass = "A driver for `1` was not found on your local computer or currently available paclet sites. If you can locate the driver, add the driver directory to $Path or load the driver directly with Get. If you cannot locate the driver, contact the device manufacturer or create a driver using the Wolfram Device Framework. See http://devices.wolfram.com for more information."
General::noop = "`1` not supported for `2`."
General::nsupm = "The method `1` is not supported for `2`."
General::ncdev = "`1` is not open."
General::dargx = "`1` called with `2` arguments; no more than 2 arguments are expected."
General::ncdevx = "Unable to automatically open a device in the `1` class to perform this operation. Try opening a device first."
General::ncdevc = "There are no open devices in the `1` class to perform this operation. Try opening a device first."
General::nvdev = "`1` is not a valid device."
General::nvdevc = "`1` is not a valid device or class."
General::nopni = "Unable to open `1`. One or more driver components are missing or not functioning properly."
DeviceObject::nodev = "Device `1` with ID `2` is not available."
DeviceObject::notype = "Unknown type `1` in `2`."
DeviceObject::noprop = "Unknown property or type `1` in `2`."
DeviceObject::nopropd = "`1` does not have a property `2`."
DeviceObject::nopropdx = "`1` does not have properties `2`."
DeviceObject::nonpropdx = "`1` does not have one or more native properties `2`."
DeviceObject::ronly = "Property `1` in `2` is read-only."
DeviceObject::setmemb = "Cannot assign `1` on `2`."
DeviceObject::setmprop = "Cannot set standardized properties `1` together with native properties `2`. Please assign them separately."
DeviceObject::nostype = "Unknown subtype `1` of type `2` in `3`."
DeviceOpen::nopn = "Unable to open the default device in the `1` class. Please verify that the device is connected and ready to use."
DeviceOpen::nopnx = "Unable to open `1` with parameters `2`."
DeviceOpen::drf = "Device `1` cannot be opened because `2` returned an illegal value `3`."
DeviceObject::naccess = "Access to `1` not defined for subtype `2` of type `3` in `4`."
DeviceObject::pval = "`1` is not a valid value for the property `2`."
DeviceConfigure::confv = "`1` is not a valid value for the configuration parameter `2`."
DeviceConfigure::confx = "`1` is not a recognized configuration parameter."
DeviceExecuteAsynchronous::noopa = "Asynchronous operation `1` is not supported for `2`."
DeviceClose::ncdevc = "There are no open devices in the `1` class."
DeviceReadTimeSeries::tslow = "The result may have taken longer to obtain and/or may have a smaller number of data points because `1` measurement(s) took longer than the requested interval `2`, about `3` seconds (on average)."
DeviceReadTimeSeries::runits = "Range specification `1` is not a real number or a Quantity object representing time."
DeviceReadTimeSeries::range = "Argument `1` is not in the form of a range specification, {t, dt}."
DeviceReadLatest::ncoll = "No data was collected for `1` yet. Try using DeviceRead or a related function first."
DeviceReadBuffer::blen = "The requested number of items `1` exceeds the capacity of the buffer."
DeviceFramework`DeviceClassRegister::readp = "Class `1` is read-protected."
DeviceFramework`DeviceClassRegister::unqprop = "String names of properties `1` in `2` are not unique."
DeviceFramework`DeviceClassRegister::props = "Invalid property specification `1`. Properties must be specified as a list of rules."
DeviceFramework`DeviceClassRegister::nparent = "The parent specification `1` in the driver for `2` at `3` is not a valid class name or None."
DeviceFramework`DeviceClassRegister::ndrts = "Value of option ReadTimeSeriesFunction -> `1` must be a function or a list of the form {{\"method1\", function1}, ... }."
DeviceFramework`DeviceClassRegister::invdrf = "Failed to load a device driver from the file `1`."
ImageDemosaic::dydx = "Offset should be a list of two integers instead of `1`."
ImageDemosaic::cfa = "The color filter array of `1` is not supported"
ImageDemosaic::wb = "Expecting Automatic, None, \"GrayScaling\" or a list of three or four real numbers instead of `1`."
ImageDemosaic::gamma = "Expecting Automatic, None, \"sRGB\" or a positive real number instead of `1`."
RemoveBackground::imginv = "Expecting an image or graphics instead of `1`.";
RemoveBackground::mkinv = "Expecting either an image or graphics with dimensions `2`, a list of positions to specify markers, or a color primitive instead of `1`."
RemoveBackground::hintinv = "`1` is not a valid specification.";
FourierDCTFilter::arg1 = "Expecting an image instead of `1`."
FourierDCTFilter::thr = "Expecting a non-negative real number instead of `1`."
GrowCutBinarize::mkinv = "Expecting either an image or graphics with dimensions `2` or a list of positions to specify markers instead of `1`."
GrowCutBinarize::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
GrowCutComponents::mkinv = "Expecting a list of images with dimensions `2` or a list of positions to specify markers instead of `1`."
GrowCutComponents::mkempty = "The list of markers `1` does not contain any labels."
GrowCutComponents::iters = "The value of option MaxIterations -> `1` should be a positive integer.";
GrowCutComponents::thrinv = "Expecting a non-negative real number or Automatic instead of `1`.";
ConformImages::arg1 = "The specified argument `1` should be a list of images."
ConformImages::arg2 = "`1` is not a valid conformation specification."
ConformImages::fitmtd = "`1` is not a valid fitting method."
ConformImages::cspad = "The specified padding value `1` is incompatible with the specified color space `2`."
ConformImages::bdopts = "The specified options `1` are not valid options for the specified images and will be ignored."
General::insffroix = "There are insufficient elements in the specified region of interest Masking->`1` to proceed with the computation. At least `2` element is required."
General::insffroin = "There are insufficient elements in the specified region of interest Masking->`1` to proceed with the computation. At least `2` elements are required."
General::mrdim = "Dimension specification expected at position `2` of `1`."
General::mrdil = BoundaryMeshRegionData::mrdil = "Dimension specification or a list with dimension and cell indices expected at position `2` of `1`."
General::meshreg = "Valid MeshRegion or BoundaryMeshRegion object expected at position `2` of `1`."
General::polygon = "Valid polygon expected at position `2` of `1`."
General::polyhedron = "Valid polyhedron expected at position `2` of `1`."
General::regp = "A correctly specified region expected at position `1` of `2`."
General::regpnd = "A non-degenerate region is expected at position `1` of `2`."
General::reg = "`1` is not a correctly specified region."
General::nbf = "`1` is not a Boolean-valued pure function of `2` variable(s)."
General::distval = "The distance function `1` does not give a valid numerical value."
RegionDistance::cregp = SignedRegionDistance::cregp = RegionNearest::cregp = RegionMember::cregp = "The region given at position `2` of `1` is not a constant region. `3` can only be created for a constant region."
General::rnimpl = "The function `1` is not implemented for `2`."
RegionDimension::nmet = "Unable to compute the dimension of region `1`."
BoundedRegionQ::nmet = "Unable to determine whether the region `1` is bounded."
ConvexRegionQ::nmet = "Unable to determine whether the region `1` is convex."
RegionBounds::btp = "The second argument `1` of RegionBounds should be \"Minimal\", \"Sufficient\", or \"Finite\"."
RegionMeasure::nmet = "Unable to compute the measure of region `1`."
ArcLength::nmet = "Unable to compute the length of region `1`."
Area::nmet = "Unable to compute the area of region `1`."
Volume::nmet = "Unable to compute the volume of region `1`."
Perimeter::nmet = "Unable to compute the perimeter of region `1`."
RegionMoment::nmet = "Unable to compute the requested moment,`2`, for the region `1`."
MomentOfInertia::nmet = "Unable to compute the moment of inertia for the region `1`."
RegionCentroid::nmet = "Unable to compute the centroid of region `1`."
RegionCentroid::empty = RegionNearest::empty = "The region `1` is empty."
RegionCentroid::infm = "The region `1` has infinite measure."
RegionDistance::nmet = "Unable to compute the distance between `1` and `2`."
RegionDistance::nmetf = "Unable to compute the distance function for the region `1`."
SignedRegionDistance::nmet = "Unable to compute the signed distance between `1` and `2`."
SignedRegionDistance::nmetf = "Unable to compute the signed distance function for the region `1`."
RegionNearest::nmet = "Unable to compute an element of `1` nearest to `2`."
RegionNearest::nmetf = "Unable to compute the nearest point function for the region `1`."
BoundedRegionQ::opdiv = RegionBounds::opdiv = "Numeric optimization failed to converge to a solution. The region `1` may be unbounded."
EmptyRegion::pmdim = FullRegion::pmdim = InverseTransformedRegion::pmdim = "The embedding dimension `1` should be a machine-sized positive integer."
ParametricRegion::funs = "`1` should be a non-empty list of real-valued functions of variables `2`."
ImplicitRegion::bcond = ParametricRegion::bcond = "`1` should be a Boolean combination of equations, inequalities, and Element statements."
BooleanRegion::dims = "Boolean operations involving regions `1` and `2` with different embedding dimensions are not well-defined."
RegionUnion::dims = "Union of regions `1` and `2` with different embedding dimensions is not well-defined."
RegionIntersection::dims = "Intersection of regions `1` and `2` with different embedding dimensions is not well-defined."
RegionDifference::dims = "Difference of regions `1` and `2` with different embedding dimensions is not well-defined."
RegionSymmetricDifference::dims = "Symmetric difference of regions `1` and `2` with different embedding dimensions is not well-defined."
Region`RegionSubset::dims = Region`RegionDisjoint::dims = Region`RegionEqual::dims = "Regions `1` and `2` have different embedding dimensions."
BooleanRegion::rglst = "`1` should be a non-empty list of regions."
TransformedRegion::vfunc = "`1` evaluated at a list of length `2` should give a non-empty list."
InverseTransformedRegion::vfunc = "`1` evaluated at a list of length `2` should give a list of length `3`."
BoundingRegion::pts = "`1` should be a nonempty list of points with real-valued coordinates, a MeshRegion, or a BoundaryMeshRegion."
BoundingRegion::breg = "`1` is not a valid bounding region type."
BoundingRegion::pdim = "The dimension `3` of points `1` does not match the dimension `4` of the bounding region type `2`."
BoundingRegion::degbr = "Warning: returning a bounding region of type `1` that is a degenerate version of the requested bounding region type."
BoundingRegion::mpr = "Warning: Currently unable to compute the bounding region of type `1` with the requested precision so the result has machine-precision."
Simplex::vlst = "`1` should be a non-empty list of lists of equal nonzero length."
Simplex::indep = "`1` should be a list of affinely independent points."
Parallelogram::llen = "`1` should be a list of length two."
Parallelogram::ivec = Parallelepiped::ivec = "`1` should be a list of linearly independent vectors of length `2`."
Circumsphere::spec = "`1` is not a valid Circumsphere specification."
Insphere::spec = "`1` is not a valid Insphere specification."
Circumsphere::indep = "Circumsphere does not exist for `1`."
Insphere::indep = "Insphere does not exist for `1`."
Ellipsoid::pdefm = "`1` should be a length `2` list of positive real quantities or a `2` x `2` real symmetric positive definite matrix."
Hyperplane::fhyp = "The first argument `1` of Hyperplane should be a nonzero real vector."
HalfSpace::fhyp = "The first argument `1` of HalfSpace should be a nonzero real vector."
Hyperplane::shyp = "The second argument `1` of Hyperplane should be a real number or a list of length `2`."
HalfSpace::shyp = "The second argument `1` of HalfSpace should be a real number or a list of length `2`."
AffineSpace::vec = AffineHalfSpace::vec = ConicHullRegion::vec = "`1` should be a list of real vectors of length `2`."
AffineSpace::ppts = AffineHalfSpace::ppts = ConicHullRegion::ppts = "`1` should be a point or a list of points."
AffineSpace::pts = AffineHalfSpace::pts = ConicHullRegion::pts = "`1` should be a non-empty list of points."
AffineHalfSpace::indv = "The vector `1` should not be a linear combination of vectors `2`."
InfiniteLine::dpts = HalfLine::dpts = HalfPlane::dpts = "`1` should be a pair of distinct points."
InfiniteLine::nzvec = HalfLine::nzvec = "`1` should be a nonzero vector."
InfinitePlane::ipts = "`1` should be a list of three affinely independent points."
InfinitePlane::ivec = HalfPlane::ivec = "`1` should be a pair of linearly independent vectors."
Region`RegionProperty::prop = "`1` is not a known region property."
Region`RegionProperty::svars = "`1` should be a list of at least `2` variables."
Region`RegionProperty::pdim = "`1` should be a machine-sized non-negative integer."
Region`RegionProperty::ptreg = "`1` should be a list of length `2` or a region with embedding dimension `2`."
Region`RegionProperty::nmet = "Unable to compute the property `1` of region `2`."
Inactive::acinac = "A combination of active and inactive forms of the operator `1` has been detected in flat expression `2`. Consider adding parentheses to clarify intent.";
Inactive::mltops = "Two different inactive operators `1` and `2` have been been detected in flat expression `3`. Consider adding parentheses to clarify intent.";
AASTriangle::npa = ASATriangle::npa = SASTriangle::npa = "The angle `1` should be a positive number less than Pi."
AASTriangle::nps = ASATriangle::nps = SASTriangle::nps = SSSTriangle::nps = "The triangle side `1` should be a positive number."
AASTriangle::asm = ASATriangle::asm = "The sum of angles `1` and `2` should be less than Pi."
SSSTriangle::tri = "The triangle side `1` should be less than sum of sides `2` and `3`."
EulerMatrix::real = RollPitchYawMatrix::real = "The angle measure `1` should be real-valued."
EulerMatrix::bdir = RollPitchYawMatrix::bdir = "The axis index `1` should be 1, 2, or 3."
EulerMatrix::ang = RollPitchYawMatrix::ang = "`1` should be a list of three real-valued quantities."
EulerMatrix::axes = RollPitchYawMatrix::axes = "`1` should be a list of three rotation axis indices."
EulerAngles::rotm = RollPitchYawAngles::rotm = "`1` is not a 3 x 3 rotation matrix."
EulerAngles::rind = RollPitchYawAngles::rind = "The rotation axis indices `1` should be one of {1, 2, 1}, {1, 3, 1}, {2, 1, 2}, {2, 3, 2}, {3, 1, 3}, {3, 2, 3}, {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, or {3, 2, 1}."
MeshRegion::coplnr = BoundaryMeshRegion::coplnr = "The vertices in the polygon `1` are not coplanar."
MeshRegion::coplnrf = "The faces in `1` do not all have coplanar vertices."
MeshRegion::dgcell = BoundaryMeshRegion::dgcell = "The cell `1` is degenerate."
MeshRegion::dgcellr = BoundaryMeshRegion::dgcellr = "Degenerate cells including `1` have been removed."
MeshRegion::uocell = BoundaryMeshRegion::uocell = "The cell `1` is not correctly oriented."
MeshRegion::dupcell = BoundaryMeshRegion::dupcell = "There are cells in dimension `1` that have been deleted as duplicates. Only properties specified for the first instance will be kept."
MeshRegion::dgall = "All cells in `1` were degenerate."
BoundaryMeshRegion::dgall = "All cells in `1` of the boundary dimension were degenerate."
BoundaryMeshRegion::bnddim = "The dimension of the boundary given at position `2` of `1` is less than the required dimension `3`."
BoundaryMeshRegion::buncl = "At least one boundary was not closed in `1`."
BoundaryMeshRegion::buncl1 = "A set of closed boundaries in 1 dimension need to be specified by an even number of distinct points."
BoundaryMeshRegion::bcuncl = "The boundary curve is not closed because the vertices `1` only come from a single edge."
BoundaryMeshRegion::bsuncl = "The boundary surface is not closed because the edges `1` only come from a single face."
BoundaryMeshRegion::bcnint = "Boundary cells of lower dimension were given that were not intrinsic to the boundary in `1`."
General::binsect = "The boundary curves self-intersect or cross each other in `1`."
BoundaryMeshRegion::bcinsect = "The vertices `1` have more than two incident edges, indicating that the boundary curve self-intersects or that there are multiple boundaries that should be separated. Using Method->{\"SeparateBoundaries\"->True} will try to separate the boundaries automatically."
BoundaryMeshRegion::bsinsect = "The edges `1` have more than two incident faces, indicating that the boundary surface self-intersects or that there are multiple boundaries that should be separated. Using Method->{\"SeparateBoundaries\"->True} will try to separate the boundaries automatically."
BoundaryMeshRegion::bcsm = "There is a closed curve or surface that does not include all cells specified for a boundary. A boundary should consist of a single closed curve or surface."
BoundaryMeshRegion::bemm = "The faces in the boundary could not be matched together with a consistent orientation."
BoundaryMeshRegion::bfsep = "The faces specified in `1` could not be separated into closed boundary surfaces.  If the separation of boundaries is known it can be given with BoundaryMeshRegion[coords, boundary1, ...]."
MeshRegion::cinsect = "The cells overlap in `1`."
MeshRegion::qinsect = BoundaryMeshRegion::qinsect ="The vertex `1` is the quadratic vertex in a quadratic edge and also in another edge.  The quadratic vertex must only appear in one edge."
MeshRegion::bdctype = BoundaryMeshRegion::bdctype = "The head of the cell specification `1` is not one of Point, Line, Polygon, Hexahedron, Tetrahedron, Prism, or Pyramid."
MeshRegion::bdctd = "A `2` cell cannot be used for a mesh in dimension `1`."
BoundaryMeshRegion::bdctdb = "A `2` cell cannot be used for a boundary mesh in dimension `1`."
MeshRegion::bdcind = BoundaryMeshRegion::bdcind = "The cell data in `1` should be given in terms of coordinate indices."
MeshRegion::bdncv = BoundaryMeshRegion::bdncv = "The number of vertices `1` given in `2` is incorrect for that cell type."
MeshRegion::bdvi = BoundaryMeshRegion::bdvi = "The vertex indexes in `2` are not all integers between 1 and `1` giving a position in the coordinates."
Property::rules = "The property specification at position `2` in `1` should be a rule or list of rules."
MeshRegion::mixlq = BoundaryMeshRegion::mixlq = "Linear and Quadratic cells cannot be mixed together in the same mesh."
MeshRegion::bdcoord = BoundaryMeshRegion::bdcoord = CoordinateBounds::bdcoord = CoordinateBoundingBox::bdcoord = "The coordinates given at position `1` in `2` are not a list of real-valued points in the same dimension."
MeshRegion::vimap = BoundaryMeshRegion::vimap = "Because of duplicated or unused coordinates, the vertex indexes have been mapped to new values corresponding to the reduced coordinate set."
MeshRegion::cdim = BoundaryMeshRegion::cdim = "The coordinates given at position `1` in `2` are points in dimension `3`. `4` only supports coordinates in dimensions 1 through 3."
DiscretizeRegion::cdim = BoundaryDiscretizeRegion::cdim = "The region given at position `1` in `2` is in dimension `3`. `4` only supports dimensions 1 through 3."
MeshRegion::pnset = BoundaryMeshRegion::pnset = "Some or all of the properties specified in the Properties option could not be set."
MeshRegion::mrnew = BoundaryMeshRegion::mrnew = "New `1` expression created from `2` representation."
MeshRegion::mrcopy = "Shallow copy made of MeshRegion."
BoundaryMeshRegion::mrcopy = "Shallow copy made of BoundaryMeshRegion."
MeshRegion::mrdcopy = "Deep copy made of representations `1` in MeshRegion."
BoundaryMeshRegion::mrdcopy = "Deep copy made of representations `1` in BoundaryMeshRegion."
MeshRegion::mrcvr = BoundaryMeshRegion::mrcvr = "Conversion from representation `1` to representation `2` completed."
MeshRegion::mrcvrf = BoundaryMeshRegion::mrcvrf = "Conversion to representation `1` failed."
MeshRegion::holm = BoundaryMeshRegion::holm = "Unable to find points not in the region for all of the inner boundaries."
MeshCells::cnorep = MeshPrimitives::cnorep = "There is no simple cell representation for the specified cells of the BoundaryMeshRegion `1` in dimension `2`."
SetProperty::piuns = RemoveProperty::piuns = Set::piuns = Unset::piuns = "The property `2` is intrinsic to the `1` object and cannot be set or removed."
SetProperty::pvtype = RemoveProperty::pvtype = Set::pvtype = Unset::pvtype = "The property `2` for the  `1` object should have integer type so cannot be set to the specfied values."
GraphicsMesh::mprim = "Multiple Graphics3D primitives of region dimension 3 are not supported."
GraphicsMesh::invprim = DiscretizeGraphics::invprim = BoundaryDiscretizeGraphics::invprim = "The graphics primitive `1` is not valid."
GraphicsMesh::invcoord = "Invalid graphics coordinates `1` in primitive `2`."
GraphicsMesh::nimp = "Support for graphics primitive `1` is not implemented."
BoundaryMesh::nobrep = BoundaryDiscretizeRegion::nobrep = "There is not a boundary representation that uniquely defines a region with region dimension `1` embedded in dimension `2`."
BoundaryMesh::brepl = BoundaryDiscretizeRegion::brepl = BoundaryDiscretizeGraphics::brepl = "There are components in `1` having dimension lower than the embedding dimension `2` that will not be included in the boundary representation."
BoundaryMeshRegion::dupbcl = "The cell `1` was given in more than one boundary."
BoundaryMeshRegion::tjrq = MeshRegion::tjrq = "The T-junctions in the mesh cannot be repaired because the mesh is quadratic."
DiscretizeRegion::bdmdt = BoundaryDiscretizeRegion::bdmtd = "The value of the option Method->`1` is not a known built-in method."
RandomPoint::bdbnds = DiscretizeRegion::bdbnds = BoundaryDiscretizeRegion::bdbnds = RegionImage::bdbnds = "The bounds given at position `2` of `1` are not a list of {min, max} pairs of length `3`."
DiscretizeRegion::defbnds = BoundaryDiscretizeRegion::defbnds = RegionBounds::defbnds = RegionImage::defbnds = "Unable to compute bounds for the region. Using default bounds of {-1, 1} in all dimensions."
DiscretizeRegion::bdprbnds = BoundaryDiscretizeRegion::bdprbnds = "The bounds associated with the ParametricRegion variables are not a list of {min, max} pairs."
DiscretizeRegion::drtol = BoundaryDiscretizeRegion::drtol = NDSolve::drtol = NDSolveValue::drtol = ParametricNDSolve::drtol = ParametricNDSolveValue::drtol = NDSolve`FEM`ToBoundaryMesh::drtol = NDSolve`FEM`ToElementMesh::drtol = "Tolerance requested by the AccuracyGoal and PrecisionGoal options is too small to be achieved. Increasing to absolute tolerance `1`"
DiscretizeRegion::dre = BoundaryDiscretizeRegion::dre = "`1` did not find any sample points in the region `2` with bounds `3`. If this is not correct, different bounds may help."
DiscretizeRegion::drf = BoundaryDiscretizeRegion::drf = RegionImage::drf = "`1` was unable to discretize the region `2`."
DiscretizeRegion::drc = "Available methods not able to resolve all components of dimension less than the embedding dimension `1`; these may be omitted from the result."
DiscretizeRegion::drcm = "Method->`2` not able to resolve all components of dimension less than the embedding dimension `1`; these may be omitted from the result."
DiscretizeRegion::drcd = "Available methods not able to resolve all components of dimension `1`; these may be omitted from the result."
RegionImage::reg23 = "`1` is not a region with RegionEmbeddingDimension equal to 2 or 3."
ShellRegion::nsld = "A solid region or a closed surface is expected at position `2` in `1`."
BooleanRegion::drc = "Components of dimension less than the embedding dimension `1` may be omitted."
General::rdim2 = "A region with embedding dimension 2 is expected at position `2` in `1`."
General::rdim3 = "A region with embedding dimension 3 is expected at position `2` in `1`."
Developer`InactivateExclusions::iexlist = "The value of `1` must be a list of pairs of the form {_Symbol, \"Symbol\"} or {_Symbol, \"Expression\"}.";
Developer`InactivateExclusions::iexval = "`1` is not a pair of the form {_Symbol, \"Symbol\"} or {_Symbol, \"Expression\"}.";
Developer`InactivateExclusions::iexmult = "Multiple entries found for `1`. Only the first will be used."
RegionPlot::invplotreg = RegionPlot3D::invplotreg ="`1` is not a valid region to plot."
ConvexHull::invmethod = ConvexHullMesh::invmethod = "`1` is an invalid Method option. Must be Automatic, \"Andrews\", \"Melkman\", \"Graham\", or \"Jarvis\"."
ConvexHull::invpts = ConvexHullMesh::invpts = "Cannot construct a valid ConvexHull with the given points."
TriangulateMesh::qgoal = DiscretizeRegion::qgoal = "The value of the option MeshQualityGoal->`1` is Automatic, \"Minimal\", or a number between 0 and 1. The value `2` will be used."
TriangulateMesh::tmfail = "TriangulateMesh failed to triangulate the mesh."
TriangulateMesh::tmfailm = "TriangulateMesh failed to triangulate the mesh using the method `1`."
TriangulateMesh::tmprec = "TriangulateMesh is currently unable to triangulate the mesh to precision `1` because the coordinates are not distinct at MachinePrecision."
ImageMesh::imfailm = "ImageMesh failed to generate a mesh using the method `1`."
General::bdmcm = "Value of option MaxCellMeasure->`1` is not Automatic, a real number, or a list of rules for \"Length\", \"Area\", and or \"Volume\". The Automatic value will be used instead."
GeoMarker::invcol = "`1` is not a valid color."
GeoMarker::invrot = "`1` is not a valid \"Rotate\" value."
GeoMarker::invpro = "`1` is not a valid \"Proportion\" value."
GeoMarker::invsca = "`1` is not a valid scale."
GeoMarker::invspec = "`1` is not a valid GeoMarker specification."
GeoMarker::invpts = "`1` is not a valid GeoMarker coordinates specification."
General::invptype = "`1` is not a valid geo path type."
GeoPath::invpts = "`1` is not a valid GeoPath coordinates specification."
GeoPath::invspec = "`1` is not a valid GeoPath specification."
GeoPath::invspn = "`1` is not a valid specification for a named geo path."
GeoPath::invspty = "`1` is not a valid specification for a geo path of type `2`."
GeoPath::vcolors = "`1` is not a valid VertexColors specification."
GeoDisk::cntr = GeoCircle::cntr = "`1` is not a valid center location."
GeoDisk::rds = GeoCircle::rds = GeoNearest::rds = "`1` is not a valid radius specification."
GeoDisk::brng = GeoCircle::brng = "`1` is not a valid range of bearings."
GeoDisk::invspec = "`1` is not a valid GeoDisk specification."
GeoCircle::invspec = "`1` is not a valid GeoCircle specification."
GeoBoundsRegion::invspec = "`1` is not a valid GeoBoundsRegion specification."
DayHemisphere::sun = NightHemisphere::sun = DayNightTerminator::sun = "Cannot compute the geo position having the Sun at its zenith on date `1`."
General::zoom = "The zoom level `1` is not a positive integer or Automatic."
General::chzoom = "Unable to download data for zoom level `1`. Using zoom `2` instead."
GeoElevationData::invloc = "`1` is not a valid location or pair of locations."
GeoElevationData::datar = "Unable to download elevation data for ranges `1` and zoom level `2`."
GeoElevationData::datap = "Unable to download elevation data for positions `1`."
GeoElevationData::type = "Invalid elevation type `1`."
GeoElevationData::otype = "Invalid output type `1`."
GeoElevationData::otypeim = "Cannot construct an elevation image."
GeoElevationData::miss = "Result contains missing elevations, represented by value `1`."
GeoElevationData::bgr = "Invalid background value `1`."
GeoStyling::imf = "`1` is not a valid GeoStylingImageFunction specification."
General::invgr = "`1` is not a valid GeoRange specification."
General::invgrp = "`1` is not a valid GeoRangePadding specification."
General::invgc = "`1` is not a valid GeoCenter specification."
General::geores = "`1` is not a valid GeoResolution specification."
General::grdlin = "`1` is not a valid GeoGridLines specification."
General::sar = "Found bounding box with singular aspect ratio."
GeoGraphics::invspec = GeoImage::invspec = "`1` is not a valid geo primitive or style specification."
General::invgm = "`1` is not a valid GeoModel specification."
General::incgm = "Incompatible geo models `1` found."
General::invgmrm = "Warning: using geo projection with reference model `2` on geo model `1`."
General::gsrv = "`1` is not a valid geo server specification."
General::gmim = "Unable to download an image of `1`."
General::zoom1 = "Geo zoom level `1` is not available for geo model `2`. Using geo zoom level 1.";
General::plrange = "Geo grid range `1` should be All or a ranges specification {{xmin, xmax}, {ymin, ymax}}."
General::plrpad = "`1` is not a valid GeoGridRangePadding specification."
General::imgs = "`1` is not a valid ImageSize specification."
General::aspr = "`1` is not a valid AspectRatio specification."
General::rtsz = "`1` is not a valid RasterSize specification."
General::gasz = "`1` is not a valid GeoArraySize specification."
General::bbox = "Unable to compute a bounding box for the given input."
General::center = "Unable to compute a map center for the given input."
General::selpr = "Unable to select a geo projection for the given input."
General::range = "Unable to estimate geo ranges for the given input."
General::estz = "Unable to estimate geo zoom level for the given input."
General::entgr = "Unable to find geo range implied by GeoRange->`1`."
GeoGraphics::imeff = GeoImage::imeff = "Unable to apply image effect `1`."
GeoGraphics::raster = GeoImage::raster = "Unable to rasterize `1`."
GeoGraphics::bgnd = "Unable to construct geo background for the given input and style `1`."
GeoGraphics::tile = "Unable to download one tile of the geo background image."
GeoImage::tile = "Unable to download one tile of geo image."
General::etile = "Unable to download one tile of geo elevation data."
GeoGraphics::tiles = "Unable to download `1` tiles of the geo background image."
GeoImage::tiles = "Unable to download `1` tiles of geo image."
General::etiles = "Unable to download `1` tiles of geo elevation data."
GeoGraphics::geosty = GeoImage::geosty = "Geo styling `1` is invalid."
GeoGraphics::vstyle = GeoImage::vstyle = "Vector map style `1` is only supported for the geo background."
GeoGraphics::gslist = GeoImage::gslist = "List of geo stylings not yet supported."
GeoGraphics::proj = GeoImage::proj = GeoElevationData::proj = "Projection `1` cannot be performed."
General::ctrygm = "GeoRange->\"Country\" is not a valid setting for geo model `1`."
General::grpad = "Unable to implement padding specification `1`."
GeoGraphics::data = GeoImage::data = "Unable to download data for ranges `1` and zoom level `2` from geo server `3`."
GeoGraphics::wdata = GeoImage::wdata = "Unable to download data for ranges `1` and zoom level `2` from the Wolfram geo server."
GeoGraphics::sdata = GeoImage::sdata = "Unable to download data for ranges `1` and zoom level `2` for map style `3`."
GeoGraphics::gscl = "The value of the option GeoScaleBar -> `` should be Automatic, None, a unit or unit system, or a list of distances."
GeoGraphics::missloc = GeoPosition::missloc = "Unable to obtain location information for `1`."
GeoGraphics::rmloc = "Entites `1` have been removed from input because there is no available location information for them."
GeoGraphics::polpos = "Unable to obtain polygon information for `1`. Proceeding with average position `2`."
GeoGraphics::noparse = "Unable to parse the string \"`1`\"."
GeoGraphics::vtext = "Unable to compute automatic vertex texture coordinates."
GeoGraphics::mpsty = GeoImage::mpsty = "Invalid map style `1` for `2`."
GeoVisibleRegion::neghgt = GeoVisibleRegionBoundary::neghgt = "Negative geodetic height `1` does not define a visible region."
GeoNearest::geonear1 = "`1` is not a valid entity type pattern, a valid list of locations, or a valid list of rules."
GeoNearest::geonear2 = "`1` is not a valid location or list of locations."
GeoNearest::geonear3 = "`1` is not a non-negative integer, All, a list of the form {n, r} with n a positive integer or All and r a distance quantity, 0, or Infinity."
General::noloc = "Cannot obtain geographic information for location `1`."
GeoNearest::unktype = GeoWithinQ::unktype = GeoEntities::unktype = GeoIdentify::unktype = GeoDistance::unktype = "Unknown type `1`."
GeoNearest::notype = GeoWithinQ::notype = GeoEntities::notype = GeoIdentify::notype = GeoDistance::notype = "`1` is not supported as entity type."
GeoNearest::invn = "`1` is not valid as number of entities requested."
GeoNearest::unsuploc = GeoWithinQ::unsuploc = GeoEntities::unsuploc = GeoIdentify::unsuploc = GeoDistance::unsuploc = "`1` is not supported as location."
GeoNearest::invrsp = GeoWithinQ::invrsp = GeoEntities::invrsp = GeoIdentify::invrsp = GIS`GeoEntityTypes::invrsp = GeoDistance::invrsp = "Invalid server response."
GeoNearest::invdate = GeoWithinQ::invdate = GeoEntities::invdate = GeoIdentify::invdate = GeoDistance::invdate = "Invalid date object `1`."
TravelDirections::noroute = TravelTime::noroute = TravelDistance::noroute = TravelDistanceList::noroute = "Cannot compute path with travel method `1` between locations `2`."
TravelDirections::arginvll = TravelTime::arginvll = TravelDistance::arginvll = TravelDistanceList::arginvll = "At least one of the elements in the list `1` is not a valid location."
TravelDirections::arginvlt = TravelTime::arginvlt = TravelDistance::arginvlt = TravelDistanceList::arginvlt = "Argument `1` is not a list with 2 or more locations."
TravelDistance::arginv = TravelTime::arginv = "Argument `1` is not a valid location."
TravelDirectionsData::invprop = "Invalid travel directions property `1`."
General::nolen = "Cannot convert quantity `1` into a length."
General::noang = "Cannot convert quantity `1` into an angle."
General::nodt = "Cannot convert `1` into a date."
General::nodur = "Cannot convert `1` into a time difference."
General::unitsys = "`1` is not a valid UnitSystem specification."
General::msgs = "Evaluation of `1` generated message(s) `2`."
GrammarApply::arg1 = "The first argument `1` is expected to be a CloudObject or list of CloudObject.";
GrammarApply::arg1g = "`1` is not a deployed GrammarRules object."
GrammarApply::arg2 = "The second argument `1` is expected to be a String or a StringExpression of the form StringExpression[Repeated[_String | Alternatives[__String]].";
GrammarApply::sarg1 = "The first argument `2` of `1` is expected to be a String or a List.";
GrammarApply::bdpm = "The value `1` for AllowLooseGrammar should be True, False, or Automatic.";
GrammarApply::bdat = "The value `1` for AllowTransliteration should be True, False, or Automatic.";
GrammarApply::bdic = "The value `1` for IgnoreCase should be True or Automatic.";
GrammarApply::misspdi = "Missing parser data item '`1`'.";
GrammarApply::assrt = GrammarRules::assrt = "An internal error prevented the operation from proceeding. Please help improve the Wolfram Language by reporting this issue. Error Code: `1`";
GrammarApply::badresponse = "The Wolfram Cloud replied with an unexpected response. Please try again.";
GrammarApply::toolarge = "Application of the grammar was aborted because the resultant data was too large to transmit.";
GrammarRules::ngr1 = "The first argument is expected to be a list of grammar rules of the form grammarPattern:>action or GrammarToken[grammarSymbol].";
GrammarRules::ngr2 = "The second argument is expected to be a list of grammar rules of the form grammarSymbol->grammarPattern:>action, grammarSymbol->{(grammarPattern:>action)..}, or grammarSymbol->GrammarToken[grammarSymbol].";
GrammarRules::arg1 = "The first argument is expected to be a list of grammar rules of the form grammarPattern:>action or GrammarToken[grammarSymbol]. Invalid grammar rule: `1`";
GrammarRules::arg2 = "The second argument is expected to be a list of grammar rules of the form grammarSymbol->grammarPattern:>action, grammarSymbol->{(grammarPattern:>action)..}, or grammarSymbol->GrammarToken[grammarSymbol]. Invalid grammar rule: `1`";
GrammarRules::bdrule1 = "The grammar pattern `1` should have head String, FixedOrder, AnyOrder, Alternatives, Repeated, RepeatedNull, DelimitedSequence, CaseSensitive, or Pattern. Grammar rule: `2`";
GrammarRules::bdrule2 = "The grammar pattern `1` should have head String, FixedOrder, AnyOrder, OptionalElement, Alternatives, Repeated, RepeatedNull, DelimitedSequence, CaseSensitive, or Pattern. Grammar rule: `2`";
GrammarRules::bdpm = "The value `1` for AllowLooseGrammar should be True, False, or Automatic.";
GrammarRules::bdes = "The value `1` for ExternalSymbols should be a list of strings.";
GrammarRules::invr = "Invalid grammar rule: `1`"
GrammarRules::invb = "Named patterns may not be used here: `1`, Grammar rule: `2`";
GrammarRules::repargs = "The second argument of Repeated should be an Integer, Infinity, or of the form {minimumNumberOfMatches_Integer, maximumNumberOfMatches:(_Integer | Infinity)}. You supplied: `1`, Pattern: `2`, Grammar rule: `3`";
GrammarRules::depargs = "The second argument of DelimitedSequence should either be a grammar pattern or a list of three grammar patterns representing {left, sep, right}. You supplied: `1`, Pattern: `2`, Grammar rule: `3`";
GrammarRules::resfirstarg = "The first argument of Restricted should be a grammar pattern. You supplied: `1`, Pattern: `2`, Grammar rule: `3`";
GrammarRules::resargs = "The second argument of Restricted should be an Integer, Infinity, or of the form {minimumNumberOfMatches_Integer, maximumNumberOfMatches:(_Integer | Infinity)}. You supplied: `1`, Pattern: `2`, Grammar rule: `3`";
GrammarRules::csarg = "The argument to CaseSensitive must be a String. You supplied: `1`, Pattern: `2`, Grammar rule: `3`";
GrammarRules::ippna1 = "Grammar rule patterns of type `1` require arguments. Invalid grammar rule: `2`";
GrammarRules::ippna2 = "Grammar rule patterns of type `1` require arguments. Contained within larger pattern: `2`, Invalid grammar rule: `3`";
GrammarRules::invarga1 = "Grammar rule patterns of type `1` require `2` arguments. Pattern: `3`, Grammar rule: `4`";
GrammarRules::invargb1 = "Grammar rule patterns of type `1` require `2` arguments. Pattern: `3`, Contained within larger pattern: `4`, Grammar rule: `5`";
GrammarRules::invarga2 = "Grammar rule patterns of type `1` require `2`-`3` arguments. Pattern: `4`, Invalid grammar rule: `5`";
GrammarRules::invargb2 = "Grammar rule patterns of type `1` require `2`-`3` arguments. Pattern: `4`, Contained within larger pattern: `5`, Grammar rule: `6`";
GrammarRules::invsp = "Grammar rule patterns of type `1` are not supported. Subpattern: `2`, Contained within larger pattern: `3`";
GrammarRules::nullable = "Grammar rule patterns must contain at least one non-optional part. Pattern: `1`, Invalid grammar rule: `2`";
GrammarRules::restrgr = "The first argument of Restricted in `2` in the grammar rule `3` was `1` instead of a GrammarToken or DelimitedSequence."
GrammarRules::gta = "GrammarTokens must be of the form GrammarToken[sym_String], where 'sym' indicates the grammar symbol's name. Pattern: `1`, Invalid grammar rule: `2`";
GrammarRules::invalidlhs = "The left-hand side of a grammar rule is expected to be a grammar symbol, but it was not a String. Grammar rule: `1`"
GrammarRules::cr = "The grammar contains circular reductions, such as: `1`";
GrammarRules::nos = "The first argument must contain at least one rule.";
GrammarRules::singins = "Grammar rules in the first argument to GrammarRules whose patterns are of the form GrammarToken[symbol_] should not specify a produced grammar symbol. They imply that the given symbol is suitable for a full parse. Grammar rule: `1`";
GrammarRules::shads = "Your definition of GrammarToken[`1`] is shadowing the built-in one. All references to `1` will refer to your local definition.";
GrammarRules::gsexp = "Excessive number of grammar symbols (`1`) present in grammar.";
GrammarRules::aotme = "AnyOrder with too many elements.";
GrammarRules::undsym = "The grammar symbol `1` is undefined.";
GrammarRules::blank = "The empty string (\"\") cannot be used as a literal.";
GrammarRules::ons = "Optional is not supported. Use OptionalElement instead. Pattern: `1`, Contained within larger pattern: `2`";
GrammarRules::cond = "PatternTest and Condition are not supported in a StringExpression in GrammarRules."
General::gpts1 = "Data value `1` must be a list of at least 3 points in 3D."
General::gmat1 = "Data value `1` must be a list of points of dimension 3."
IntegerString::outrange = IntegerName::outrange = "Number `1` is too large for the algorithms available for `2`."
IntegerName::inputs = "`1` is not a valid type."
IntegerName::ignored = "Using type `1`."
IntegerName::optval = "Invalid value `1` for option Language."
IntegerName::type = "`1` is not a known string type. Valid types include \"DigitsWords\", \"Words\", \"Approximate\", and \"ApproximateWords\".";
General::nspoly = "`1` is not a simple Polygon."
General::ngdim1 = "Graphics primitives with coordinates `1` are not supported."
SemanticInterpretation::arg1 = "The first argument is expected to be a string or list of strings.";
SemanticInterpretation::nosi = "No semantic interpretation could be found.";
General::stempu = "The server is temporarily unavailable. Please try again."
General::idomdim = "`1` does not have a valid dimension as a plotting domain."
General::nnregion = "`1` cannot be automatically discretized."
General::idombds = "`1` is not a valid plotting domain; it may contain invalid interior boundaries."
Internal`ExtendLicenseProvision::provisioned = "This kernel is not provisioned.  Only provisioned kernels may extend provisions."
Internal`ExtendLicenseProvision::product = "`1` is not a valid product code.  A product code must be \"Kernel\" or \"FrontEnd\"."
PingTime::pntqoa = "`1` should be either a positive number, a Quantity time or Automatic.";
PingTime::ptimeout = "No ping echo received from host `1` within the specified timeout.";
SocketConnect::socketaddress = "Socket address expected at position `1` in `2`.  A socket address can be a two-element list of the form {\"HostName\", PortNumber} or {IPAddress, PortNumber}, a string of the form \"HostName:PortNumber\", or a URL of the form \"http://HostName\"."
SocketConnect::hoststring = "Host name or IP address string expected as element 1 of List in `1`."
SocketConnect::portnum = "Port number or service name string expected as element 2 of List in `1`."
SocketConnect::nohost = HostLookup::nohost = PingTime::nohost = "Host `1` not found during `2`.";
SocketConnect::noservice = "Port or service `1` not found during `2`."
SocketConnect::connrefused = "Connection refused by host `1`, port `2`, during `3`."
SocketConnect::connect = "Connection error occurred during `1`.  Error message text: `2`."
Socket`SocketInformation::sockinfoprop = "Expected a valid SocketInformation property at position `1` in `2`.  Valid properties are the strings in `3`."
Developer`ScheduledServiceSubmit::connect = "Connection refused by service `1`."
Developer`ScheduledServiceSubmit::invldsrvc = "`1` should be a valid service name or ServiceObject. Try using $Services."
Developer`ScheduledServiceSubmit::invldschdl = "Service could not be run at the provided `1` schedule. Allowed schedules are Hourly, Weekly, Monthly and Yearly."
Developer`ScheduledServiceSubmit::conntimeout = "Connection to the service `1` could not be established within `2`."
HostLookup::hoststr = PingTime::hoststr = "Host name or IP address expected at position `1` in `2`."
HostLookup::lookup = "Host lookup error occurred during `1`.  Error message text: `2`."
General::nosocket = "Connected socket expected at position `1` in `2`."
General::disconnectedsocket = "The socket in `1` is not connected."
General::socketambiguous = "The socket `1` cannot be used unambiguously as a stream function argument, because it could refer to either `2` or `3`."
General::ipaddress = "In `1`, `2` must contain an IP address."
General::methodoption = "No Method option is allowed when opening a socket in `1`."
General::socketstreamin1 = "Input may not be performed on a socket which has had its InputStream Closed, in `1`.  Only one InputStream may ever be opened on a SocketObject."
General::socketstreamout1 = "Output may not be performed on a socket which has had its OutputStream Closed, in `1`.  Only one OutputStream may ever be opened on a SocketObject."
AngleVector::dim = "`1` is not a vector of dimension `2`.";
AngleVector::ara = "`1` is not a valid angle or {radius, angle} specification.";
CirclePoints::dim = "`1` is not a vector of dimension `2`.";
CirclePoints::noneg = "Argument `1` should be a real non-negative number.";
CirclePoints::rra = "`1` is not a valid radius or {radius, angle} specification.";
AnglePath::adim = "`1` is not an angle or a vector of dimension `2`.";
AnglePath::init = "Invalid angle path initialization `1`.";
AnglePath::steps = AnglePath3D::steps = "Invalid steps specification `1`.";
AnglePath::otype = AnglePath3D::otype = "Invalid output type specification `1`.";
AnglePath3D::initp = "Invalid point initialization `1`.";
AnglePath3D::initf = "Invalid frame orientation initialization `1`.";
BoundaryDiscretizeRegion::rescm = "BoundaryDiscretizeRegion will not able to resolve all components of dimension less than the embedding dimension `1`; these may be omitted from the result."
DiscretizeRegion::bdmtdtype = BoundaryDiscretizeRegion::bdmtdtype = "The method, `2`, specified for method option `1` is not one of `3`";
DiscretizeRegion::bdmtdd = BoundaryDiscretizeRegion::bdmtdd = "The specified method, `1`, is not one of `2`";
DiscretizeRegion::invldmtd = BoundaryDiscretizeRegion::invldmtd = "The method, `1`, specified for `2` is not compatible for processing the specified region. Reverting to Method->Automatic.";
DiscretizeRegion::unbndreg = BoundaryDiscretizeRegion::unbndreg = "The specified region appears to be unbounded. Appropriate bounds will be automatically computed. Explicit bounds may be specified as a second argument."
DiscretizeRegion::nobmrtri = "The specified region cannot be represented by a single `1` dimensional cell. A minimal triangulation will be performed to generate the region."
DiscretizeRegion::nsmcm = "The single `1` dimensional cell representation of the specified region does not satisfy the specified MaxCellMeasure. Triangulation will be performed to satisfy the MaxCellMeasure."
General::lstpat = "List or pattern matching a list expected at position `2` in `1`.";
General::ovls = "Value of option Overlaps -> `1` must be True, False or All.";
CoordinateBoundsArray::units = CoordinateBoundingBoxArray::units = "Incompatible units `1` found.";
CoordinateBoundsArray::uunits = CoordinateBoundingBoxArray::uunits = "Unable to obtain units of `1`.";
CoordinateBoundsArray::dcdim = CoordinateBoundingBoxArray::dcdim = "Discretization `1` is incompatible with dimension `2`.";
CoordinateBoundsArray::dcunit = CoordinateBoundingBoxArray::dcunit = "Discretization `1` is incompatible with units `2`.";
CoordinateBoundsArray::ptdim = CoordinateBoundingBoxArray::ptdim =  "Point `1` is incompatible with dimension `2`.";
CoordinateBoundsArray::ptunit = CoordinateBoundingBoxArray::ptunit =  "Point `1` is incompatible with units `2`.";
CoordinateBoundsArray::offs = CoordinateBoundingBoxArray::offs = "Invalid offset specification `1`.";
CoordinateBoundsArray::offsdim = CoordinateBoundingBoxArray::offsdim =  "Offset `1` is incompatible with dimension `2`.";
CoordinateBoundsArray::offsunit = CoordinateBoundingBoxArray::offsunit = "Offset `1` is incompatible with units `2`.";
CoordinateBoundsArray::paddim = CoordinateBoundingBoxArray::paddim =  "Padding specification `1` is incompatible with dimension `2`.";
CoordinateBoundsArray::pad = CoordinateBoundingBoxArray::pad = "Invalid padding specification `1`.";
CoordinateBoundsArray::zstp = CoordinateBoundingBoxArray::zstp = "Found discretization step zero for an interval of nonzero length.";
CoordinateBoundingBoxArray::bbox = "Invalid bounding box specification `1`.";
CoordinateBoundsArray::bound = "Invalid bounds specification `1`.";
SequenceReplace::reps = "`1` is neither a rule nor a list of replacement rules, and so cannot be used for replacing.";
SequenceReplace::lstpat = "List or pattern matching a list expected for the left-hand side of the rules.";
SequenceFold::nargt = SequenceFoldList::nargt = "The argument `1` is not a non-negative integer.";
SequenceFold::nargs = SequenceFoldList::nargs = "Number of arguments `1` cannot be smaller than the length `2` of the seed.";
QuantityArray::uarray = "Invalid units specification `1`.";
QuantityArray::units = "Inconsistent argument dimensions `1` and `2`.";
UnitConvert::conv = "Cannot convert quantity array to units `1`";
UnitConvert::udims = "A quantity array of dimensions `1` cannot be converted to a unit block of dimensions `2`.";
General::lcompat = "Incompatible list of units `1`.";
GeogravityModelData::init = "Unable to locate initialization resources; Please contact technical support for assistance.";
GeogravityModelData::range="`1` should be an integer between 2 and 360";
GeogravityModelData::rotation="\"IncludeRotation\" should be True or False.";
GeogravityModelData::qdim=GeomagneticModelData::qdim="`1` is not a unit of length.";
GeogravityModelData::datum="`1` is not a supported datum of GeogravityModelData or GeomagneticModelData.";
GeogravityModelData::invelev=GeomagneticModelData::invelev="`1` is not a valid elevation.";
GeogravityModelData::elev=GeomagneticModelData::elev="Unable to download elevation data. Using default value of 0 instead.";
GeogravityModelData::loc=GeomagneticModelData::loc="`1` is not a valid location or region.";
GeogravityModelData::elevrng=GeomagneticModelData::elevrng="Elevation (`1` in kilometers) should be between -10 and 600 kilometers.";
GeomagneticModelData::erpole="An internal error encountered while locating `1`, whose position cannot be confirmed.";
GeomagneticModelData::time="Improper time specification.";
GeomagneticModelData::now="Unable to determine current time.";
GeomagneticModelData::model="Improper model specification.";
GeomagneticModelData::modelrng="Calculations for `1` are only valid between the years `2` and `3`.";
GeogravityModelData::moptx=GeomagneticModelData::moptx="Method option `1` in `2` is not the valid suboption `3`.";
GeogravityModelData::invreg=GeomagneticModelData::invreg="`1` is not a valid region.";
FetalGrowthData::notterm = "Age specification are outside the valid range `1` to `2`.";
FetalGrowthData::notage = "`1` is not a quantity of time or a future due date.";
FetalGrowthData::zscore = "`1` should between -5 and 5.";
FetalGrowthData::percentile = "`1` should between `2` and `3` exclusive.";
FetalGrowthData::invindex = "`1` is not a percentage or z-score.";
FetalGrowthData::nindex = "`1` is not an indexed property. Index will be ignored.";
FetalGrowthData::unit= "`1` is an unrecognized unit system.";
HumanGrowthData::notent = "`1` is not a known entity, class, or tag for `2`.";
HumanGrowthData::notage = "`1` is not a real quantity of time or a date.";
HumanGrowthData::fdate = "`1` is a future date. Use FetalGrowthData instead.";
HumanGrowthData::negage = "`1` is a negative time. Use FetalGrowthData instead.";
HumanGrowthData::notsex = "`1` is not a known gender. Use `2` or `3`.";
HumanGrowthData::range = "`1` falls outside of the supported range `2`.";
HumanGrowthData::percentile = "`1` should between `2` and `3` exclusive.";
HumanGrowthData::invindex = "`1` is not a percentage or z-score.";
HumanGrowthData::zscore = "`1` should between -5 and 5.";
HumanGrowthData::qrange = "`1` falls outside of the supported range `2` to `3`.";
HumanGrowthData::punit= "`1` has the wrong units for `2`.";
HumanGrowthData::unit= "`1` is an unrecognized unit system.";
HumanGrowthData::ncomp= "`1` is an unsupported component. Valid components include \"StandardDeviation\" and \"Distribution\".";
StoppingPowerData::usage = "StoppingPowerData returns information on the resistive properties of materials to ionizing radiation.";
StoppingPowerData::quant = "`1` is not a real number.";
StoppingPowerData::quants="List `1` does not consist of real numbers.";
StoppingPowerData::unit="`1` uses incorrect units.";
StoppingPowerData::time="Calculation exceeded time limit.";
StoppingPowerData::particle="`1` is not a valid particle. Valid particles include \"AlphaParticle\", \"Electron\", \"Photon\", and \"Proton\".";
StoppingPowerData::npq="The input for `1` is not a quantity.";
StoppingPowerData::orng="Energy should be between `1` and `2`.";
StoppingPowerData::init = "Unable to locate initialization resources; Please contact technical support for assistance.";
CloudConnect::notauth = "Unable to authenticate with Wolfram Cloud server. Please try authenticating again."
CloudConnect::oauth = "Unrecognized authentication information. Please contact technical support for assistance.";
CloudConnect::cerr = "Unrecognized client error; status code `1`.";
CloudConnect::serr = "Unrecognized server error; status code `1`.";
CloudConnect::uerr = "An unknown error occurred; status code `1`.";
CloudConnect::creds = "Incorrect username or password.";
CloudConnect::nocrd = "No username or password sent.";
CloudConnect::gwto = "Unable to process request at this time. Please try again later.";
CloudConnect::unav = "Wolfram Cloud temporarily unavailable. Please try again later.";
CloudConnect::iserr = "Unable to process request. Please try again later.";
CloudConnect::pcond = "Invalid authorization information; Please contact technical support for assistance.";
CloudConnect::tout = "Request timed out. Please try again later.";
CloudConnect::bdmtd = "HTTP method unavailable; Please contact technical support for assistance.";
CloudConnect::nfnd = "Unable to reach Wolfram Cloud servers. Please try again later.";
CloudConnect::bdrsp = "Unrecognized login response; Please contact technical support for assistance.";
CloudConnect::apkey = "Unrecognized authentication keys. Please contact technical support for assistance.";
CloudConnect::badts = "Invalid Timestamp. Please ensure your system clock is set to the correct time.";
CloudConnect::fbdn = "Unable to authorize request.  Please contact technical support for assistance.";
CloudConnect::atype = "Unrecognized AuthenticationMethod specification `1`.";
CloudConnect::cbase = "Invalid CloudBase specification `1`.";
CloudConnect::aurl = "Invalid AuthenticationURL specification `1`.";
CloudConnect::surl = "Invalid SignatureURL specification `1`.";
CloudConnect::config = CloudConnect::invcfg = "Unrecognized CloudConnect configuration.";
CloudObject::uristring = "URI `1` expected to be a string.";
CloudObject::invaliduri = "The URI `1` is not valid.";
CloudObject::unauth = "URI `1` only valid when authenticated.";
CloudObject::invalidbase = "Invalid CloudBase `1`; a fully qualified domain expected.";
DocumentGenerator::listing = "Unable to obtain DocumentGenerator listing.";
DocumentGenerator::filex = "Cannot overwrite existing cloud object `1`.";
DocumentGenerator::nffil = "`` not found.";
DocumentGenerator::badarg = "Bad value `` for argument ``.";
DocumentGenerator::badform = "Unrecognized output format ``.";
DocumentGenerator::tcrea = "Unable to create generator task.";
DocumentGenerator::crea = "Unable to create or update generator.";
DocumentGenerator::notrep = "Object `` not recognized as a document generator.";
DocumentGenerator::notask = "No task found for object ``.";
DocumentGenerator::argu = "Unrecognized document generator specification.";
DocumentGenerator::nostart = "Unable to start task for document generator ``.";
DocumentGenerator::norm = "Unable to remove DocumentGenerator.";
DocumentGenerator::nostop = "Unable to stop DocumentGenerator `1`.";
DocumentGenerator::nonext = "Unable to obtain next scheduled run time for DocumentGenerator `1`.";
DocumentGenerator::optx = "Unknown option `1` in `2`.";
DocumentGenerator::nochan = "Unsupported notification or delivery channel `1`.";
RenameFile::cldnm = "Cloud object `1` does not contain a name.";
CloudPut::invalidobj = "`1` is not a valid cloud object.";
CloudObjects::invtype = "Invalid cloud object type specification `1`.";
CloudObjectInformation::noprop = "`1` is not a property returned by CloudObjectInformation.";
CloudObject::noicon = "No icon named `1` found for `2`.";
CloudObject::invmeta = "Invalid meta information `1`; a list of rules or Association with string keys expected.";
General::invperm = "Invalid permissions specification `1`.";
General::selfperm = "The currently authenticated user `1` cannot be assigned specific permissions. Owners always have full permissions on their objects.";
General::invusr = "Invalid user or PermissionsGroup `1`.";
General::noaccess = "Access to user `1` information is denied.";
ScheduledTask::notask = "Argument 1 in CloudDeploy is not a recognized ScheduledTask specification.";
ScheduledTask::nostart = "Unable to start ScheduledTask.";
ScheduledTask::nostop = "Unable to stop ScheduledTask `1`.";
ScheduledTask::sched = "`1` is not a recognized scheduling time specification.";
ScheduledTask::nouri = "Unrecognized uri specification `1`.";
ScheduledTask::noavil = "Scheduling tasks remotely is not yet available.";
ScheduledTask::norm = "Unable to remove ScheduledTask `1`.";
ScheduledTask::listing = "Unable to obtain ScheduledTask listing.";
ScheduledTask::nonext = "Unable to obtain next scheduled run time for ScheduledTask `1`.";
ScheduledTask::restr = "Use restricted under current subscription.";
ScheduledTask::argu = "Unrecognized scheduling specification.";
ScheduledTask::upda = "Unable to update scheduled task.";
ScheduledTask::crea = "Unable to create scheduled task.";
ScheduledTask::unsuppsched = "The scheduling time specification `1` is not supported by the target environment.";
ScheduledTask::optx = "Unknown option `1` in `2`.";
ScheduledTask::badarg = "Bad value `1` for argument `2`.";
ScheduledTask::norun = "Scheduled task `1` is not presently running.";
ContinuousTask::restr = "Unrestricted cloud required for deployment.";
MailReceiverFunction::invfun="A function is expected instead of `1`";
MailReceiverFunction::invmail="The given message `1` is not valid mail.";
MailReceiverFunction::nfrom="The message should include a From parameter.";
MailReceiverFunction::nomail="The mbox file `1` does not include any messages.";
MailReceiverFunction::nfile="File `1` was not found.";
MailReceiverFunction::perms="MailReceiverFunction does not support the Permissions option.";
MailReceiverFunction::noco="The MailReceiverFunction could not be deployed.";
MailReceiverFunction::cloudc="You must be cloud connected to deploy the MailReceiverFunction.";
MailResponseFunction::invopt="The value `1` should be True, False, Automatic, or a function defining the desired response content."
ReturnReceiptFunction::invopt="The value `1` should be True, False, or a function determining whether to return a receipt."
General::maxviewers = "Maximum number of `1` viewer seats exceeded.";
General::userunknown = "User `1` unknown to the Wolfram Cloud.";
General::notauth = "Unable to authenticate with Wolfram Cloud server. Please try authenticating again.";
General::notperm = "Unable to perform the requested operation. Permission denied.";
General::unavailable = "The cloud service is not available. Please try again shortly.";
General::notparam = "Invalid parameters were specified.";
General::notmethod = "The specified method is not allowed.";
General::rejreq = "The specified request was rejected by the server.";
General::srverr = "Cloud server is not able to complete a request.";
General::cloudnf = "No CloudObject found at the given address";
General::cloudprecondition = "A precondition check in the cloud service failed.";
General::cloudunknown = "An unknown error occurred.";
URLExecute::clouderror = "Unable to execute the CloudObject. The object does not exist or is private.";
General::jsonfailedinit="Failed to initialize."
General::mnumber = "The value `1` cannot be coerced into a machine number."
General::jsonnotmnumber = "The JSON format only supports machine numbers."
General::jsonfoundendofinput="Expecting json token '`1`', found end of input."
General::jsontokenmismatch="Expecting '`1`' from token `2`. Found '`3`'."
General::jsoninvalidtoken="Invalid token found."
General::jsoninvalidnum="Invalid number."
General::jsoninvescchar="Unexpected escaped character '`1`'"
General::jsoninvcodepoint="Expecting 4 hexadecimal digits after token \\u."
General::jsonkeynstr="Object keys must be strings."
General::jsonkvsep="Missing key value separator ':'."
General::jsonobjmissingsep="Expecting end of object or an entry separator."
General::jsonarraymissingsep="Expecting end of array or a value separator."
General::jsonexpendofinput="Unexpected character found while looking for the end of input."
General::jsonhintposandchar="An error occurred near character '`1`', at line `2`:`3`"
General::jsonhintposition="An error occurred at line `1`:`2`"
General::jsonnullinput="Data in input is null."
General::jsonstrictencoding="Expression `1` cannot be exported as `2`."
General::jsonassockeynstr="Association contains non string key."
General::jsonrulelistnonrule="`1` contains a mixture of rule and non-rule expressions."
General::jsonrulelistkeynstr="Invalid non-string key `1`."
General::invissueas="Expecting symbol. Cannot issue message from expression `1`."
General::jsonconvfctnoeval="The conversion function `1` applied to `2` did not evaluate."
General::jsonconvtounexphead="Expecting the head of expression to be `1` instead of `2`."
General::jsonunicodestream="The input stream is a 16-bit Unicode data stream. UTF-8 encoded stream expected."
General::jsonoutofrangeunicode="Out of range unicode code point encountered."
General::rawobjectnotsupp="Raw objects cannot be exported as `1`."
General::exprjsonemptylist="Symbol head not found as first element of the array."
General::utf8outofrange="Input is not a valid UTF8 byte sequence. Leading byte `1` is outside of UTF8 supported range."
General::utf8badlead="Input is not a valid UTF8 byte sequence. Continuation byte `1` is expected to be a leading byte."
General::utf8expcontinuation="Input is not a valid UTF8 byte sequence. `1` is expected to be a continuation byte."
General::utf8incompletesequence="Input is not a valid UTF8 byte sequence. The final multibyte sequence is incomplete."
General::ubjsonexpectint="Expecting integer."
General::ubjtypednolength="Strongly typed containers must specify their length."
General::ubjincompletesequence="Incomplete sequence of bytes. Expecting `1` of size `2`."
General::ubjbadcount="Expecting count to be a positive integer."
General::ubjwrongclose="Container that specifies a count must not specify closing marker."
General::ubjbadcontainerparam="Failed to read `1` container parameters."
General::ubjbadcharacter="Invalid char type. Char type must not have a decimal value larger than 127."
General::ubjexpectnewtype="Invalid byte found. Expecting value type."
General::ubjunexpnoop="Unexpected no-op marker found outside a container."
General::ubjhighprenodata="Missing high precision number data."
General::ubjwrongpatype="Only PackedArray of reals or integers are supported."
General::ubjinfiniterealinpa="Infinite or NaN encountered in strongly typed packed array of reals. You might want to disable packing by setting \"PackStronglyTypedArray\" option to False."
General::ubjbigunsigned64="Failed to coerce UnsignedInteger64 to Integer64"
General::ubjsonhint="An error occured between positions `1` and `2`"
General::ubjsonearlyend="Expecting more data, reached end of input."
General::ubjexpendofinput="Expecting end of input, found more content to read."
General::nas = "The argument `1` is not a string."
General::nalph = "The alphabet `1` is not known or not available."
General::evsb = "`1` cannot be called when sandbox mode is already active."
FromLetterNumber::nint = "The argument `1` is not an integer."
FromLetterNumber::nlst = "The argument `1` is not an integer or a list of integers."
Alphabet::noalpha = "The alphabet `1` is not known or not available."
Alphabet::noprop = "The property `1` is not known or not available."
Alphabet::noscript = "The writing script `1` has no alphabet."
AlphabeticOrder::nmal = " The letter `1` is not a member of the alphabet `2`."
AlphabeticOrder::nstr = "The argument `1` is not a string."
AlphabeticSort::nosort = "`1` cannot be sorted alphabetically."
AlphabeticSort::arg1 = "The first argument is expected to be a list of strings."
CharacterName::nat = "The argument `1` is not a known character name type."
CharacterName::nac = "The argument `1` is not a character or a string."
FoldPair::pair = FoldPairList::pair = "Function application `1` returned `2`; a list of two elements is expected."
ShiftRegisterSequence::rlpec = "`1` is expected to be a polynomial, an integer n > 1, a pair {n, taps}, or a triple {n, taps, f}."
ShiftRegisterSequence::nupi = "`1` is not a univariate polynomial function with integer coefficients of degree greater than 1."
ShiftRegisterSequence::nupp = "The coefficients of `1` are zero after taking them modulus `2`."
ShiftRegisterSequence::modfp = "Value of option `1` -> `2` should be a prime number."
WarpingCorrespondence::invarg = WarpingDistance::invarg = "Expecting a real-valued numeric or boolean vector or matrix instead of `1`."
WarpingCorrespondence::invdims = WarpingDistance::invdims = "Expecting a real-valued numeric or boolean vector or matrix with dimensions `1` instead of `2`."
WarpingCorrespondence::invrform = WarpingDistance::invrform = "The specified window parameter `1` should be Automatic, a non-negative integer, or a list of the form {name, radius}."
WarpingCorrespondence::invr = WarpingDistance::invr = "Expecting a non-negative integer number instead of `1`."
WarpingCorrespondence::invwin = WarpingDistance::invwin = "Window name `1` should be one of the `2`."
WarpingCorrespondence::toosmallr = WarpingDistance::toosmallr = "The specified search radius `1` is too small to yield a result. Adjusting to `2`."
WarpingCorrespondence::invdist = WarpingDistance::invdist = "The distance function `1` is not supported."
WarpingCorrespondence::comaptu = WarpingDistance::compatu = "Incompatible units."
WarpingCorrespondence::failed = WarpingDistance::failed = "Internal error occurred."
WarpingDistance::invmtd = WarpingCorrespondence::invmtd = "Value of option Method -> `1` is invalid."
WarpingDistance::invitrv = WarpingCorrespondence::invitrv = "Value of suboption \"MatchingInterval\" -> `1` is not Full, \"Flexible\" or Automatic."
WarpingDistance::invimpl = WarpingCorrespondence::invimpl = "Value of suboption \"Implementation\" -> `1` is not \"Legacy\" or Automatic."
WarpingDistance::invsp = WarpingCorrespondence::invsp = Signal`TimeWarpingStepPatternAlgorithmData::invsp = "Invalid type of a time warping step pattern `1`."
Signal`TimeWarpingStepPatternAlgorithmData::invprop = "Invalid property `1`."
Signal`CanonicalCorrelationAnalysis::invarg = "Expecting a real-valued numeric vector or matrix instead of `1`.";
Signal`CanonicalCorrelationAnalysis::invlam = "Expecting a list of two numbers from interval [0, 1) instead of `1`.";
Signal`CanonicalCorrelationAnalysis::invdims = "Expecting second dimension equal `1` in `2`.";
CanonicalWarpingDistance::invlam = CanonicalWarpingCorrespondence::invlam = "Expecting a list of two numbers from interval [0, 1) instead of `1`.";
CanonicalWarpingDistance::invarg = CanonicalWarpingCorrespondence::invarg = "Expecting a real-valued numeric vector or matrix instead of `1`.";
CanonicalWarpingDistance::invinitp = CanonicalWarpingCorrespondence::invinitp = "Expecting a correspondence matrix or Automatic instead of `1`.";
CanonicalWarpingDistance::invmtd = CanonicalWarpingCorrespondence::invmtd = "Value of option Method -> `1` should be Automatic or a list of rules with possible left hand sides `2`."
CanonicalWarpingDistance::comaptu = CanonicalWarpingCorrespondence::compatu = "Incompatible units."
CanonicalWarpingDistance::incorpnd = CanonicalWarpingCorrespondence::incorpnd = "Correspondence matrix row `1` should be a nondecreasing list of positive integers."
CanonicalWarpingDistance::incorlen = CanonicalWarpingCorrespondence::incorlen = "Correspondence matrix rows `1` and `2` should have equal positive length."
CanonicalWarpingDistance::incorq = CanonicalWarpingCorrespondence::incorq = "Correspondence matrix row `1` should contain all numbers from 1 to `2` inclusive and only those."
TakeDrop::iseq = "Invalid sequence specification `1` for an expression of length `2`."
TakeList::splist = "`1` is not a list of sequence specifications."
TakeList::iseqs = "Cannot take list `1` of sequence specifications at level `2` of `3`."
NumberDecompose::psv = NumberCompose::psv = "`1` is not a list of nonincreasing positive numbers."
NumberCompose::ulen = "List `1` of coefficients cannot be longer than list `2` of units."
IntegerString::numsys = "Invalid numeric system `1`."
IntegerString::nnumb = "Integer or list of integers expected at position 1."
IntegerString::nrep = "Integer `1` cannot be represented in the mixed radix specification `2`."
IntegerDigits::imxrds = IntegerString::imxrds = IntegerReverse::imxrds = IntegerLength::imxrds = "The mixed radix specification `1` must contain a list of positive machine integers."
IntegerReverse::ibmr = "Positive integer greater than 1 or mixed radix specification expected at position `2` of `1`."
SubstitutionSystem::reps="`1` is neither a list of replacement rules nor a valid dispatch table, and so cannot be used for replacing."
SubstitutionSystem::rlsa="The rule specification `1` should be either a rule number, or a list {rule number, colors, size}, or a list specifying the size in each dimension {rule number, colors, {size1, ..., sized}}, or an explicit rule list specifying the replacement for each color."
SubstitutionSystem::initd="The initial condition specification `1` should be a non-empty  array whose elements are non-negative integers."
SubstitutionSystem::steps="Number of steps `1` should be a machine-sized integer."
SubstitutionSystem::inmx="The initial condition specification `1` should be a non-empty rank `2` array whose elements at level `2` are integers i in the range 0 <= i <= `3`."
SubstitutionSystem::rneg="The specified rule number `1` should be non-negative."
SubstitutionSystem::rsize="The specified rule number `1` is greater than the largest possible rule number (`2`)."
SubstitutionSystem::kspec="The specified number of colors `1` must be an integer greater than 1."
SubstitutionSystem::strge="The expression `1` that is not a string occurred in the evolution of `2`"
FromDigits::mxrds = BaseForm::mxrds = "The mixed radix specification `1` must contain a list of radices."
DateHistogram::tspecs = "Ticks specification `1` has shorter time duration than the minimal bin width. `2` is used instead."
DateHistogram::prd = "Period specification `1` in `2` is invalid."
RunProcess::pnfds = "Program `1` not found.  Put command-line arguments in a list.";
RunProcess::pnfd = StartProcess::pnfd = "Program `1` not found.  Check Environment[\"PATH\"].";
MortalityData::notent = "`1` is not a known entity, class, or tag for `2`.";
MortalityData::notage = "`1` is not a positive quantity of time or a historical date.";
MortalityData::notgndr = "`1` is not a known gender. Use `2`, `3`, or \"Any\" instead.";
MortalityData::notnat = "`1` is not a supported country. Use MortalityData[\"Countries\"] to find supported countries.";
MortalityData::notyr = "`1` should be a year.";
MortalityData::range = "`1` falls outside of the supported range `2`.";
MortalityData::time="Calculation exceeded time limit.";
MortalityData::prec = "Unable to locate paclet resources for MortalityData.";
MortalityData::noage="No age specified.";
Groupings::arity1 = "Arity 1 with infinite multiplicity is not allowed.";
Groupings::arity = "Invalid arity specification `1`.";
Groupings::arities = "Invalid list of arity specifications `1`.";
Groupings::ilst = "Argument `2` of `1` is expected to be a non-negative integer, a list, or a list of lists.";
Groupings::comp = "Cannot perform computation.";
WordTranslation::trfet = "Unable to fetch word translation results.";
General::nlang = "Language specification `1` should be a string or \"Language\" entity.";
WordList::inflang = RandomWord::inflang = "Inflections unavailable for language `1`.";
WordList::nodict = RandomWord::nodict = "Word list is not available for language `1`.";
Wordlist::infl = RandomWord::infl = "IncludeInflections specification `1` should be True or False.";
WordList::nopos = RandomWord::nopos = "`1` is not a recognized Word list type.";
WordList::lapos = RandomWord::lapos = "Word list type `2` is not available for language `1`; using \"English\" instead.";
FileSystemMap::fnpatt = FileSystemScan::fnpatt = "FileNameForms specification `1` should be a StringExpression, pattern, or All.";
FileSystemMap::flevel = FileSystemScan::flevel = "Directory level specification `1` should be a positive integer, pair of positive integers, or Infinity.";
FileSystemMap::fdepth = FileSystemScan::fdepth = "Association depth specification `1` should be a positive integer or Infinity.";
FileSystemMap::ndir = FileSystemScan::ndir = "Directory `1` does not exist.";
FileSystemMap::fincd = FileSystemScan::fincd = "The value of IncludeDirectories -> `1` must be True or False.";
FileSize::nfile = "The argument `1` is not a valid file path.";
FileSize::nobc = "Unable to determine file size of `1`.";
General::tzoff = "Unable to determine time zone offset for `1`.";
$TimeZone::tzset = "Unable to set $TimeZone to `1`. Time zone should be an integer, real number, a string, or an Entity object.";
$TimeZoneEntity::tzset = "Unable to set $TimeZoneEntity to `1`. Time zone should be a valid \"TimeZone\" Entity.";
StandardOceanData::pq="The input for `1` has incorrect units for `2`.";
StandardOceanData::npq="The input for `1` is not a quantity.";
StandardOceanData::pqr="The input for `1` is not a real-valued quantity.";
StandardOceanData::inv="The input for `1` is not a real number.";
StandardOceanData::geo="The input for Position is not GeoPosition or Entity.";
StandardOceanData::range="Inputs are outside supported range.";
StandardOceanData::bound="Value for `1` is outside the bounds `2` to `3`. Using `4` instead.";
StandardOceanData::notent = "`1` is not a known entity, class, or tag for `2`.";
RemoveDiacritics::arg1 = "String or list of strings expected in position 1.";
TextWords::arg1 = "String or ContentObject expected at position 1.";
TextWords::arg2 = "Positive integer expected at position 2.";
TextSentences::arg1 = "String or ContentObject expected at position 1.";
TextSentences::arg2 = "Positive integer expected at position 2.";
WordCount::arg1 = "String or list of strings expected in position 1.";
WordCounts::arg1 = "String expected in position 1.";
WordCounts::arg2 = "Positive integer expected in position 2.";
CharacterCounts::arg1 = "String or list of strings expected in position 1.";
CharacterCounts::arg2 = "Positive integer expected in position 2.";
LetterCounts::arg1 = "String expected in position 1.";
LetterCounts::arg2 = "Positive integer expected in position 2.";
LetterCounts::arg3 = "List of characters expected in position 3.";
Pluralize::noplural = "No valid English pluralization found for `1`.";
Pluralize::empty = "The empty string cannot be pluralized.";
Capitalize::nform = "Argument `1` is not \"AllWords\", \"FirstWord\", \"LongWords\", or \"TitleCase\".";
General::cnoget = "Unable to fetch contents for `1`.";
DEigenvalues::inhbcs = DEigensystem::inhbcs = "Inhomogeneous (nonzero) boundary conditions are replaced with homogeneous boundary conditions."
General::nnrarnk = "Expecting an array of rank `1` at position `2`."
General::nnrarnk2 = "Expecting an array of rank `1` or `2` at position `3`."
General::nnarobj = "An expression `1` at position `2` is not a valid array."
General::nnradims = "An array `1` at position `2` has wrong dimensions."
General::nnratype = "An array `1` at position `2` is not of single nor double machine precision type."
General::nnvalist = "Input arguments must be arrays of the same type."
General::nnnetp = "Arrays have different machine precision types."
General::nnstrval = "An incorrect string at position `1`."
General::nnascval = "An incorrect association key at position `1` of the argument `2`."
General::nnasc = "An association object expected at position `1`."
General::nndb2fl = "Cannot coerce to float a number at position `1`."
General::lsa = "List or association expected instead of `1`."
General::modfl = "The modification `1` could not be performed."
General::mutreclim = "Too many nested mutations occurred."
Subsequences::take = "Not all elements were found when attempting to take the sequence `1` from `2`, which has length `3`."
SubsetMap::newls = "The function `1` does not give a list of the same length when applied to list `2`."
PerfectNumber::pari = "Parameter `1` at position `2` in `3` is expected to be \"Even\" or \"Odd\".";
Between::pair = "Argument `1` is expected to be a pair, a list of pairs or an Interval object."
FareySequence::rank = "Farey sequence rank `1` at position `2` of `3` is expected to be a positive integer less than or equal to `4`."
DeBruijnSequence::lsim = "Argument `1` at position `2` should be a list, a string or a non-negative machine-sized integer.";
FindTransientRepeat::arg1 = "The first argument `1` to `2` is expected to be a list, an association, or a string.";
FindRepeat::arg1 = "The first argument `1` to `2` is expected to be a list, an association, or a string.";
FindRepeat::arg2 = "The second argument `1` to `2` is expected to be a positive integer, or a list of positive integers.";
FindRepeat::incl = "Length of the repetition specification `2` should be less than or equal to the array depth of `1`.";
FindRepeat::inclstr = "The repetition specification `2` should be a positive integer or a list of one positive integer for the string `1`.";
KnapsackSolve::invexpr = "Argument `1` at position `2` should be a list, a list of rules, an association, a quantity array, or a dataset.";
KnapsackSolve::invsttr = "Each collection of payoff, cost and maximum count is expected to be given as a numeric quantity, a quantity, a list, a list of rules, an association, or a quantity array.";
KnapsackSolve::keyexpr = "The key \"Cost\" is expected for elements specified as lists of rules or associations in the first argument.";
KnapsackSolve::invcol1 = "Invalid collection(s) of parameters in the first argument.";
KnapsackSolve::invpoct = "All payoffs and costs are expected to be non-negative real numbers or quantities of magnitude a non-negative real number.";
KnapsackSolve::invmcnt = "Each maximum count specification is expected to be a dimensionless non-negative integer or Infinity.";
KnapsackSolve::invcons = "Argument `1` at position `2` must be a numeric quantity, a quantity, a list, a list of rules, an association, or a quantity array.";
KnapsackSolve::invcol2 = "Invalid collection of parameters in the second argument.";
KnapsackSolve::invtpof = "The maximum total payoff `1` in the second argument is expected to be a non-negative real number, Infinity, or a quantity of magnitude a non-negative real number or Infinity.";
KnapsackSolve::incutpo = "Compatible units expected between all payoffs and the maximum total payoff.";
KnapsackSolve::incutcst = "Compatible units expected between all costs and the maximum total cost.";
KnapsackSolve::keycons = "The key \"MaxTotalCost\" is expected for the second argument when specified as a list of rules or an association.";
KnapsackSolve::invtcst = "The maximum total cost `1` in the second argument is expected to be a non-negative real number or a quantity of magnitude a non-negative real number.";
KnapsackSolve::invtcnt = "The maximum total count `1` in the second argument is expected to a be a dimensionless non-negative integer or Infinity.";
KnapsackSolve::kssnf = "No solution can be found that satisfies the constraints.";
Printout3D::noserv = "`1` is not a known service for `2`.";
Printout3D::notsup = "`1` is not a supported format.";
Printout3D::cloudf = "Only 3D online printing services are supported in the Wolfram cloud.";
General::sarg = "The argument `1` in `2` is not a string.";
WordFrequency::arg1 = "The first argument is expected to be a string or list of strings.";
WordFrequency::arg2 = "The second argument is expected to be a string or list of strings.";
WordFrequency::arg3 = "The third argument is expected to be a string: \"CaseVariants\".";
WordFrequency::trfet = "Unable to fetch word frequency results.";
WordFrequency::nongram = "Cannot mix multiple n-grams within the same Alternatives.";
WordFrequencyData::arg1 = "The first argument is expected to be a string, a valid TextElement or a list of them.";
WordFrequencyData::arg2 = "The second argument is expected to be a string or list of strings.";
WordFrequencyData::arg2v = "Invalid second argument values. Possible values include one or more of \"TimeSeries\", \"Total\", \"CaseVariants\", or \"PartOfSpeechVariants\".";
WordFrequencyData::argdate = "Invalid \"Date\" value.";
WordFrequencyData::optlang = "Invalid Language option value.";
WordFrequencyData::trfet = "Unable to fetch word frequency results.";
WordFrequencyData::invtext = "Invalid TextElement expression.";
General::chobj = "Argument `1` does not represent a valid channel object.";
General::cbrefused = "Connection at `1` refused because too many concurrent sessions open. Please disconnect from the server in some of your sessions.";
General::cbnauth =  "Not authorized (status code `1`) for `2`.";
General::nauth =  "Not authorized (status code `1`).";
AudioAmplify::volr = "`1` should be either a non-negative real number or decibels quantity."
AudioJoin::ajoinoff = AudioOverlay::aovloff = "Offset specification in `1` has to be a non-negative number or a Quantity object representing time."
AudioPartition::apartlen = "Argument `1` should be a positive real number, a Quantity object representing time or a Quantity object representing samples."
AudioPartition::apartoff = "Argument `1` should be a positive real number, a Quantity object representing time or a Quantity object representing samples not greater than `2`."
Audio`AudioRasterize::data = "Expecting a Sound object, a sound primitive or a TimeSeries object instead of `1`."
Audio`AudioRasterize::type = "The specified audio type should be either \"SignedInteger8\"\, \"SignedInteger16\", \"SignedInteger32\", \"Real32\", or \"Real64\"."
Audio`AudioRasterize::sfinv = "Expecting a list of sound font files instead of `1`."
Audio`AudioRasterize::fontnf = "The sound font file `1` cannot be installed."
Audio`AudioRasterize::nofont = "The sound font file `1` does not exist."
Audio`AudioRasterize::noidx = "The SoundFont paclet cannot be installed."
Audio`Utilities`ExportToFile::infer = "Cannot infer format of file `1`."
Audio`Utilities`ExportToFile::arg = "Invalid arguments provided.  A file path, audio object, format, and options are expected."
ConformAudio::spec = "`1` is not a valid conformation specification."
AudioData::audiorng = "The specified argument `1` should be a pair of real or integer numbers."
Audio`AudioInformation::audioprop = AudioData::audioprop = "`1` is not a valid property for an audio."
AudioPad::audiopadn = "Argument `1` should be a non-negative real number, a Quantity object representing time, a Quantity object representing samples or a pair of such values."
AudioTrim::audiotrimn = "Argument `1` should be a real number, a Quantity object representing time, a Quantity object representing samples, a pair of such values or a list of pairs of such values."
AudioTrim::audiotrime = "Trim specification `1` corresponds to an empty audio."
General::audioapm = "Appearance method should be \"Minimal\", \"Basic\", \"Detailed\" or Automatic instead of `1`."
Audio::audioin = "The specified argument `1` should be an array of rank 1 or 2 with machine-sized numbers, a string representing local or remote audio resource, a Sound or an Audio object."
Audio::nofile = "File `1` not found."
Audio::audiostrmtype = "The audio resource at `1` does not contain a supported audio streaming format."
Audio::audioidlen = "The \"AudioID\" provided should be a string of 64 characters or less."
Audio::network = "The Wolfram Language is currently configured not to use the internet, and could not connect to the server specified. To allow internet access, use Help > Internet Connectivity..."
Audio::conopen = "A connection could not be established to the audio resource at `1`. Check that your internet is connected or that any authentication credentials provided are correct."
Audio::optann = "Value of option `1` -> `2` is not a valid annotation."
General::vol = "The value of option SoundVolume -> `1` should be a real number between 0 and 1."
AudioAnnotationLookup::fmt = "The format specification `1` did not produce a valid result. Expecting a string or a function."
AudioAnnotate::invann = "The specification `1` does not generate a valid annotation."
AudioCapture::badduration = "The specified argument `1` should be a positive real number or Quantity object representing time."
AudioCapture::osnotsupported = "AudioCapture is not yet supported on `1`."
AudioCapture::dynamicnotsupported = "AudioCapture cannot be part of the evaluation of a Dynamic."
AudioData::audiodtype = "The specified data type `1` should be either \"SignedInteger8\", \"SignedInteger16\", \"SignedInteger32\", \"Real32\", \"Real64\" or Automatic."
AudioMeasurements::audiomprop = "`1` is not a known audio measurements property."
AudioMeasurements::audiomfmt = "`1` is not a valid audio measurements format."
AudioCapture::invext = AudioRecord::invext = AudioStream::invext = "\"`1`\" is a file extension not supported by AudioCapture. Use a file name with the extension \".wav\", \".aif\", \".ogg\", or \".flac\"."
AudioCapture::noext = AudioRecord::noext = AudioStream::noext = "The file name \"`1`\" does not specify a file extension. Use a file name with the extension \".wav\", \".aif\", \".ogg\", or \".flac\"."
AudioCapture::srate = "The value of option SampleRate->`1` is not supported. Use a sample rate of 8000, 11025, 12000, 16000, 22050, 32000, 44100, 48000, 88200, 96000, 176400, or 192000."
AudioCapture::fereq = "A front end is not available. AudioCapture requires a front end or a finite MaxDuration."
AudioCapture::apm = "Appearance method should be \"Basic\", \"Detailed\" or Automatic instead of `1`."
AudioCapture::inprogress = "Cannot capture audio while another AudioCapture is still in progress."
AudioCapture::muststart = "AudioCapture requires capture to run upon evaluation if no front end is available."
AudioCapture::nodev = "No input device was discovered to start AudioCapture."
AudioChannelCombine::adursame = "All audio objects should have the same duration."
AudioChannelCombine::asrsame = "All audio objects should have the same sample rate."
AudioChannelSeparate::achn = "The channel specification should be an machine-sized integer between 1 and `2`, a list of such numbers or All instead of `1`."
AudioBlockMap::opt = AudioDelay::opt = AudioFrequencyShift::opt = AudioFade::opt = AudioIntervals::opt = AudioTimeStretch::opt = AudioPitchShift::opt = AudioPlot::opt = AudioSpectralMap::opt = AudioLoudness::opt = PitchRecognize::opt = "Value of option `1` -> `2` is not a valid specification."
AudioChannelMix::dest = "The destination parameter `1` should be either \"Mono\", \"Stereo\" or an integer."
AudioChannelMix::volr = "The parameter `1` should be a list of length `2` of non-negative real numbers or decibels quantities."
AudioChannelMix::panr = "The parameter `1` should be a list of length `2` of real numbers between -1 and 1."
AudioChannelMix::distm = "`1` should be a `2`x`3` matrix of non-negative real numbers or decibels quantities."
AudioChannelMix::spec = "`1` is not a valid parameter specification."
AudioDelay::time = "The delay time parameter `1` should be a positive real number less than or equal `2`, a Quantity object representing time or a Quantity object representing samples."
AudioDelay::fb = "The feedback parameter `1` should be a machine-sized real number between -1 and 1."
AudioDelay::pad = AudioReverb::pad = "The pad parameter `1` should be a machine-sized real number greater or equal than 0."
AudioDelete::times = "The time specification `1` should be a time, a time interval or a list of time intervals."
AudioDelete::tgr = "The absolute value of the time specification `1` should be less than `2`."
AudioDelete::tintgr = "Cannot delete time interval `1`."
AudioDelete::tintsgr = "Cannot delete time intervals `1`."
AudioDistance::feature = "The feature `1` is not supported for `2`."
AudioDistance::distance = "`1` is not a valid distance function. Some possible values are EuclideanDistance, \"SpectralEuclidean\" or WarpingDistance."
AudioDistance::fitting = "Expecting \"Trim\" or \"Pad\" instead of `1`."
AudioDistance::masking = "Expecting a time interval or a list of time intervals instead of `1`."
AudioDistance::maskingdur = "The durations of the time intervals in `1` need to be equal."
AudioFade::time = "The time specification `1` is not valid."
AudioFade::tdur = "The sum of the times `1` should be less than the duration of the signal."
AudioFrequencyShift::freq = "Expecting a number, time series, pure function, or an audio object, with absolute values less than one quarter of the sample rate for the duration of the generated audio instead of `1`."
AudioGenerator::type = "Invalid generator type `1`."
AudioGenerator::nargs = "The generator `1` does not support `2` parameters."
AudioGenerator::tdata = "The argument `1` is not a valid specification."
AudioGenerator::srinv = "The value of option SampleRate->`1` should be a positive integer or a Quantity representing frequency."
AudioGenerator::durinv = "Expecting a positive real number, a Quantity object representing time or a Quantity object representing samples instead of `1`."
AudioGenerator::durshort = "The duration `1` should be greater than `2`."
AudioGenerator::freqinv = "`1` is not a valid frequency specification. Expecting a number, time series, pure function, or an audio object, with absolute values less than half the sample rate for the duration of the generated audio."
AudioGenerator::specch = "`1` is not a valid `2` specification. Audio objects are only accepted if they have a single channel."
AudioGenerator::spectsch = "`1` is not a valid `2` specification. TimeSeries are only accepted if they have a single scalar-valued path."
AudioGenerator::phaseinv = "`1` is not a valid phase specification. Expecting a real number, time series, pure function, or an audio object."
AudioGenerator::widthinv = "`1` is not a valid pulse width specification. Expecting a number, time series, pure function, or an audio object, with values between 0 and 1 for the duration of the generated audio."
AudioGenerator::colorinv = "Color must be a number between -2 and 2\.1d instead of `1`."
AudioGenerator::distrinv = "The argument for generator `1` must be a distribution instead of `2`."
AudioGenerator::rlout = "The specified input did not produce a vector of real numbers."
AudioIntervals::prop = "`1` is not a valid test."
AudioIntervals::mindur = "Expecting a positive real number, a Quantity object representing time or a Quantity object representing samples instead of `1`."
AudioIntervals::spec = "Invalid partitioning specification `1`."
AudioInsert::times = "`1` is not a valid insertion specification."
AudioLocalMeasurements::prop = AudioBlockMap::prop = "`1` is not a valid property or list of valid properties."
AudioLocalMeasurements::format = "`1` is not a valid audio measurements format."
AudioLoudness::def = "`1` is not a valid loudness definition."
AudioPan::npan = "Pan value should be either a real machine-sized number between -1 and 1, an Audio object, a pure function or a TimeSeries instead of `1`."
AudioPlot::range = "Range specification `1` is invalid."
AudioPlot::ftcks = "A ticks specification in the value of FrameTicks should be None, Automatic, a function, or a list of ticks."
AudioTimeStretch::amnt = "Expecting a positive real number, a Scaled object or a Quantity object representing time instead of `1`."
AudioPitchShift::amnt = Audio`SpeechRestyle::amnt = "Expecting a positive real number or Quantity object representing semitones or octaves instead of `1`."
General::wsize = "Expecting a positive real number, a Quantity object representing time or a Quantity object representing samples instead of `1`."
General::wfun = "Expecting a window function or a List of real numbers of length `1`."
General::wlength = "The magnitude of the parameter `1` should be less than the duration of the input Audio."
Spectrogram::wsize3 = SpectrogramArray::wsize3 = Cepstrogram::wsize3 = CepstrogramArray::wsize3 = ShortTimeFourier::wsize3 = "Expecting a positive integer, a Quantity object representing time or a Quantity object representing samples instead of `1`."
Spectrogram::wsize2 = SpectrogramArray::wsize2 = Cepstrogram::wsize2 = CepstrogramArray::wsize2 = ShortTimeFourier::wsize2 = "Expecting a positive integer or a Quantity object representing samples instead of `1`."
Spectrogram::wlength2 = SpectrogramArray::wlength2 = Cepstrogram::wlength2 = CepstrogramArray::wlength2 = ShortTimeFourier::wlength2 = "The partition size `1` should be smaller than or equal to the length of the input data."
AudioRecord::devinuse = Audio`CurrentAudio::devinuse = "The device `1` is already in use by the Wolfram Language."
InverseShortTimeFourier::inpt = "Expecting a ShortTimeFourierData object or a numeric matrix instead of `1`."
InverseShortTimeFourier::dtype = ShortTimeFourierData::dtype = "The data type `1` is not valid. Possible values include  \"List\", \"Audio\" or \"Sound\"."
InverseShortTimeFourier::thrsh = InverseSpectrogram::thrsh = "Expecting a non-negative number instead of `1`."
InverseShortTimeFourier::maxiter = InverseSpectrogram::maxiter = "Expecting a positive integer instead of `1`."
InverseShortTimeFourier::wsizei = InverseSpectrogram::wsizei = "The parameter `1` does not match the value `2` inferred from the input."
InverseShortTimeFourier::wsizel = InverseSpectrogram::wsizel = ShortTimeFourierData::wsizel = "Expecting Automatic or a positive integer instead of `1`."
InverseShortTimeFourier::wfuni = "The window funtion `1` does not match the value `2` inferred of the input."
InverseSpectrogram::inpt = "Expecting a real-valued numeric matrix instead of `1`."
ShortTimeFourierData::inpt = "Expecting a numeric matrix  of dimensions {n,`1`} instead of `2`."
ShortTimeFourierData::fpopt = "The value of the property `1` should be a real vector of length 2."
AudioReplace::times = "`1` is not a valid replacement specification."
AudioReplace::fit = "Expecting \"Fill\", \"Insert\" or \"Stretch\" instead of `1`."
AudioReplace::overlap = "The time intervals in `1` should not overlap."
AudioReverb::type = "Invalid audio reverb type `1`."
AudioReverb::ir = "The impulse response parameter should be a mono or `2`-channel audio object instead of `1`."
AudioReverb::fparams = "The length of the parameter list `1` should be 1 or 2."
AudioReverb::arg = "The parameter `1` should be a real number between 0 and 1."
AudioSpectralMap::func = "Expecting a function that returns a numeric output instead of `1`."
AudioSpectralTransformation::func = "The function `1` should map a pixel position of form {t, f} to {t', f'}."
AudioSpectralTransformation::dtrng = "Value of DataRange -> `1` is not Automatic, Full, or a list of the form {{tmin, tmax}, {fmin, fmax}}."
AudioSplit::times = "The time specification `1` should be a time or a list of times."
AudioStream::bufsize = Audio`CurrentAudio::bufsize = "Expecting a positive integer, a Quantity object representing time or a Quantity object representing samples instead of `1`."
AudioStream::bufcount = "Expecting a positive integer instead of `1`."
AudioStream::pos = "Expecting a positive real number, a Quantity object representing time or a Quantity object representing samples instead of `1`."
AudioStream::state = "`1` is not a valid state specification. Allowed values are \"Playing\", \"Paused\" and \"Stopped\"."
AudioStream::acass = "`1` is not a valid AudioChannelAssignment specification. Some possible values are \"Mean\", \"Partition\" or \"Periodic\"."
AudioPlay::maxdur = AudioRecord::maxdur = "Expecting a positive real number, a Quantity object representing time or a Quantity object representing samples instead of `1`."
AudioPlay::loop = AudioStream::loop = "Expecting Automatic, a boolean value or a positive number instead of `1`."
AudioPlay::invstr = AudioPause::invstr = AudioStop::invstr = RemoveAudioStream::invstr = AudioRecord::invstr = "`1` is not a valid AudioStream."
Audio`AudioGraph::func = "`1` is not a valid function specification."
SpeechSynthesize::string = "The argument `1` should be a string or an expression with at least one voiced character."
SpeechSynthesize::invext = "`1` is a file extension not supported by SpeechSynthesize. Use \".wav\" or \".aif\" file extensions instead."
SpeechSynthesize::noext = "File name `1` does not specify a file extension. Use a file name with the extension \".wav\" or \".aif\"."
VoiceStyleData::voice = "Expecting a voice or a list of voices instead of `1`. Evaluate $VoiceStyles to get a list of available voices."
SpeechSynthesize::voice = "Expecting a voice specification instead of `1`. Evaluate $VoiceStyles to get a list of available voices."
SpeechSynthesize::nolang = "A `1`-language voice is not available for synthesis. Evaluate VoiceStyleData[] for properties of supported voices."
Audio`SpeechRestyle::forshft = "The parameter `1` is not a valid specification. Expecting a positive number instead."
Audio`SpeechRestyle::invf = "The parameter `1` is not a valid specification."
Audio`SpeechRestyle::invf0 = "The fundamental frequency specification `1` does not produce a list of real numbers."
Audio`SpeechRestyle::invse = "The spectral envelope specification `1` does not produce a two dimensional list of real numbers."
Audio`SpeechRestyle::invap = "The aperiodicity specification `1` does not produce a two dimensional list of real numbers."
Audio`SpeechRestyle::invdim = "The dimensions of the specifications `1` do not match."
Audio`SpeechRestyle::invsr = "The sample rate `1` is not a valid specification."
Audio`SpeechRestyle::invarg = "The argument `1` is not a valid specification. Expecting an Audio object or an association."
Audio`SpeechRestyleData::spec = "The argument `1` is not a valid specification. Expecting \"FundamentalFrequency\", \"SpectralEnvelope\" or \"Aperiodicity\"."
VoiceStyleData::fmt = "`1` is not a valid format specification. Expecting \"List\", \"Dataset\", or Automatic."
VoiceStyleData::prop = "`1` is not a valid property specification. Expecting a string, list of strings, or All."
$DefaultAudioInputDevice::noset = "$DefaultAudioInputDevice cannot be set to `1`.  An audio input device name in the form of a string is expected."
$DefaultAudioInputDevice::nodev = "$DefaultAudioInputDevice could not be set to \"`1`\".  An audio input device with that name was not found."
$DefaultAudioOutputDevice::noset = "$DefaultAudioOutputDevice cannot be set to `1`.  An audio output device name in the form of a string is expected."
$DefaultAudioOutputDevice::nodev = "$DefaultAudioOutputDevice could not be set to \"`1`\".  An audio output device with that name was not found."
CepstrumArray::input = "`1` is not a valid input. Expecting either a numeric or quantity array of arbitrary rank, an Audio or Sound object or an Image or Image3D."
CepstrumArray::type = "Expecting either \"Power\" or \"Real\" instead of `1`."
CepstrogramArray::input = Cepstrogram::input = "`1` is not a valid input. Expecting either a list of numbers or quantities, a Sound or an Audio object."
CepstrogramArray::type = Cepstrogram::type = "Expecting either \"Power\" or \"Real\" instead of `1`."
PitchRecognize::freq = "Expecting a list of two real numbers or frequency quantities instead of `1`."
PitchRecognize::minfreq = "The minimum frequency `1` should be less than the maximum frequency `2`."
PitchRecognize::maxfreq = "The maximum frequency `1` should be less than the Nyquist frequency `2`."
PitchRecognize::sens = "Expecting a real number between 0 and 1 instead of `1`."
PitchRecognize::frqlst = "Expecting a list of frequencies instead of `1`."
General::mix = "The mix parameter `1` should be a machine-sized real number between 0 and 1."
General::audiodtype = "The specified data type `1` should be either \"SignedInteger8\", \"SignedInteger16\", \"SignedInteger32\", \"Real32\", or \"Real64\"."
General::srate = "The value of sample rate should be a positive machine-sized integer number or a Quantity representing frequency instead of `1`."
General::sratefile = "The value of sample rate `1` is not supported for Audio of file objects."
General::durn = "The value of duration should be a positive machine-sized real number instead of `1`."
General::audio = "Expecting an audio object instead of `1`."
General::audioms = "Expecting a mono or stereo audio object instead of `1`."
General::audiov = "Expecting a vector of audio objects instead of `1`."
General::audiol = "Expecting an audio or a list of audio objects instead of `1`."
General::audiopadm = "`1` is not a valid audio padding specification."
General::padsize = "`1` is not a valid padding size specification."
General::realnn = "Argument `1` should be a non-negative real number."
General::realnntql = "Argument `1` should be a non-negative real number, a quantity object representing time or an ordered pair of such values."
General::realnndq = "Argument `1` should be a non-negative real number or a decibels quantity object."
General::audiorsm = "Invalid resampling method `1`"
General::audiosread = "Cannot read from file or stream `1`."
General::audioswrite = "Cannot write to file or stream `1`."
General::audionotsupported = "`1` is not yet supported on this OS."
Duration::durinv = "Expecting an audio, a sound or a time series object instead of `1`."
General::audiolist = "The specified argument `1` should be a vector of audio objects or a vector or {audio, offset} pairs."
General::astream = "Audio streams are not supported yet be `1`."
General::ftype = "File format `1` is not supported."
General::fftype = "The file `1` is in not supported format."
General::interr = "An internal error occurred: `1`."
General::obsopt = "`1` is now obsolete. It will not be included in future versions of the Wolfram Language."
General::afstnostream = "There is no stream open for `1`."
LocalObject::lbx = "Cannot set $DefaultLocalBase to `1`."
LocalObject::garbled = "`1` is not a valid Local Object."
LocalObject::uri = "`1` is not a valid Local Object URL."
LocalObject::nso = "`1` not found."
LocalObject::dir = "`1` was not written as it conflicts with an existing directory."
$LocalBase::nourl = "Cannot set $LocalBase to `1`."
PersistenceLocation::nometh = "Undefined method `1` called for `2`."
PersistenceLocation::NIM = "Unhandled method call: `1`."
PersistenceLocation::invalid = "Persistence location `1` is not valid."
PersistenceLocation::plocs = "`1` is not a list of persistence locations."
PersistenceLocation::ploc = "`1` is not a persistence location."
PersistenceLocation::plocse = "`1` is not a persistence location or list of persistence locations."
PersistenceLocation::unknown = "Unknown persistence location type `1`."
PersistenceLocation::save = "Saved data `1` is not suitable for `2`."
PersistenceLocation::ro = "Persistence location `1` is read-only."
PersistenceLocation::fe = "No FrontEnd available; `1` persistence location is not supported."
PersistentObject::meta = "`1` is not a valid metadata name for `2`."
PersistentValue::valid = "Value `2` failed preprocessing function for `1`."
EvaluationEnvironment::unknown = "Warning: \"`1`\" is not among the known evaluation environments `2`.";
General::optstring = "Option setting `1` is not a string."
General::optstrlist = "Option setting `1` is not a string or list of strings."
DeleteObject::nim = "Cannot delete object `1`."
ParentDirectory::nums = "Argument `1` should be a positive machine-size integer, a nonempty string, or a File specification."
ParentDirectory::argsf = "`1` is called with 2 arguments; the first argument is expected to be a nonempty string or a File specification."
General::nso = "`1` not found."
General::sors = "Argument `1` in `2` is not a symbol or string."
General::umeth = "Invalid hashing algorithm `1`."
General::uform = "Invalid hash format `1`."
BaseEncode::barray = "`1` is not a ByteArray object."
BaseDecode::b64str = "`1` is not a Base64-encoded string."
General::msfl = "Missing data has been automatically filled in."
General::nmsfl = "Missing data could not be automatically filled in."
General::armuns = "`1` is not supported on Linux-ARM."
General::decfail = "Failed to decode `1` as `2`."
General::encfail = "Failed to encode `1` as `2`."
AsymptoticDSolveValue::vspec = AsymptoticIntegrate::vspec = AsymptoticRSolveValue::vspec = AsymptoticSum::vspec = "Variable specification `1` is not a list with three elements."
AsymptoticDSolveValue::pspec = AsymptoticIntegrate::pspec = AsymptoticRSolveValue::pspec = AsymptoticSum::pspec = "Parameter specification `1` is not a list with three elements."
AsymptoticDSolveValue::asvar = AsymptoticIntegrate::asvar = AsymptoticRSolveValue::asvar = AsymptoticSum::asvar = "`1` is not a valid variable."
AsymptoticDSolveValue::aspar = AsymptoticIntegrate::aspar = AsymptoticRSolveValue::aspar = AsymptoticSum::aspar = "`1` is not a valid parameter."
AsymptoticDSolveValue::aord = AsymptoticIntegrate::aord = AsymptoticRSolveValue::aord = AsymptoticSum::aord = "Approximation order specification `1` should be a positive integer."
AsymptoticDSolveValue::asdb = "There are multiple solution branches for the equations, but AsymptoticDSolveValue will return only one."
Curry::cst = "Invalid Curry arity structure `1`."
FindEquationalProof::invs = "Invalid specification of propositions `1` and axioms `2`."
FindEquationalProof::notheory = "Unknown named axiomatic theory `1`."
AxiomaticTheory::opers = "Invalid operator rules specification `1`."
Around::rel = VectorAround::rel = "Invalid relative uncertainty specification `1`."
Around::compat = VectorAround::compat = "`1` and `2` are not compatible units."
Around::around = "Invalid Around object `1`."
Around::udt = "Uncertainty decimal threshold `1` should be a real number larger than 10."
VectorAround::varound = "Invalid VectorAround object `1`."
VectorAround::vdims = "Dimensions `2` are incompatible with vector length `1`."
VectorAround::cov = "Invalid covariance specification `1`."
VectorAround::covm = "Invalid covariance matrix `1`."
VectorAround::corrm = "Invalid correlation matrix `1`."
VectorAround::vec1 = "First argument `1` of VectorAround is expected to be a list of scalar objects."
AroundReplace::ord = "Expansion order `1` should be an integer from 1 to 4."
AroundReplace::rule = "Uncertainty propagation rules `1` should all have head Rule."
General::ilblsz = "`1` is not a valid size for LabelingSize" 
Language`FinalizeExpressionAdd::noreg = "Cannot find `1` as a FinalizeExpression registration."
Language`FinalizeExpressionAdd::dup = "FinalizeExpressionAdd cannot be configured for `1` with registration `2`. An existing registration `3` exists."
Language`FinalizeExpressionAdd::dupreg = "FinalizeExpressionAdd cannot be configured for registration `1` with free function `2`. An existing free function `3` exists."
Language`FinalizeExpressionAdd::arg = "FinalizeExpressionAdd cannot be configured for `1`. It is only valid for symbol or nonatomic expressions."
Atom::atnam = "Atom name `1` is not a string."
Atom::chrg = "Atomic charge `1` should be an integer."
Atom::elec = "Unpaired electron count `1` should be a positive integer or zero."  
Atom::mass = "Mass number `1` should be a positive integer or Automatic."
General::mol = "Argument `1` is not a valid molecule."
General::mols = "Argument `1` is not a valid molecule or list of molecules."
General::molent = "Argument `1` is not a valid molecule or chemical entity."
General::molents = "Argument `1` is not a valid molecule, chemical entity or list of molecules and chemical entities."
General::molpat = "Argument `1` is not a valid molecule pattern."
General::atmpat = "Argument `1` is not a valid atom pattern."
General::bndpat = "Argument `1` is not a valid bond pattern."
Molecule::ambig = "Warning: chemical name `1` is ambiguous due to the following: `2`."
Molecule::aromat2 = "Non-ring atom marked as aromatic."
Molecule::aromat = "Unable to assign aromaticity for ring containing atoms `1`."
Molecule::atom = "`1` is not a valid atom specification."
Molecule::bond = MoleculeModify::bond = "`1` is not a valid bond specification."
Molecule::coord = "Value of option `1` -> `2` is not a list of coordinates with the same length as the number of atoms."
Molecule::bndvi = "The atom indices in `2` are not all integers between 1 and `1` giving a position in the atom list."
Molecule::discon = "Coordinate generation for disconnected molecules is not supported."
Molecule::dupbnd = "Duplicate bonds found in bonds list."
Molecule::noatom = "Atom `1` not found in atoms list."
Molecule::nobond = "Bond `1` not found in bonds list."
Molecule::inpt = "Unable to construct a Molecule from the given input."
Molecule::nocoord = MoleculeModify::nocoord = MoleculePlot3D::nocoord = "Unable to generate 3D coordinates for molecule."
Molecule::nintrp = "Unable to interpret `1` as a name or chemical identifier."
Molecule::stereo2 = "Warning: stereochemistry ignored in `1` due to the following: `2`."
Molecule::stereo = "Invalid stereochemistry specification `1`."
Molecule::strtype = "Invalid stereo type `1` should be \"Tetrahedral\" or \"DoubleBond\"." 
Molecule::valenc = "Invalid valence for `2` atom at position `1`."
MoleculeModify::atchpt = "Value of option `1` -> `2` should be Automatic or a list of index pairs."
MoleculeModify::atmlst = "`1` is not a valid list of atom indices or names."
MoleculeModify::modspc = "`1` is not a valid molecule modification."
MoleculeModify::nombed = "The molecule must be embedded in 3D to perform this action."
MoleculeModify::subst = "The right hand side of the replacement rule `1` must be a valid molecule or SMILES string."
MoleculePlot3D::dupcoord = "Duplicate coordinates found at positions `1` and `2` of coordinates list."
MoleculeValue::qname = "`1` is not a known qualifier of Molecule property `2`."
ComplexPlot::plld = ComplexPlot3D::plld = "Corners for `1` in `2` must have distinct machine-precision real and imaginary parts."
ComplexPlot::plln = ComplexPlot3D::plln = "Limiting value `1` in `2` is not a machine-sized complex number."
ComplexListPlot::invsf = "Incompatible scaling functions `1` used with PolarAxes."
AbsArgPlot::cfun       =  "Value of option ColorFunction -> `1` is not a valid color function, or a gradient ColorData entity."
PerpendicularBisector::linearg = "Straight line segment in the plane expected in position `1` of `2`."
AngleBisector::invang = "Points `1` expected to specify a valid angle in the plane."
AngleBisector::spec = "Specification `2` in `1` should be either \"Interior\" or \"Exterior\"."
TriangleConstruct::invtri = "`1` expected to specify a nondegenerate triangle in the plane."
TriangleConstruct::spec = "Improper specification `2` in `1`."
TriangleConstruct::regular = "The construct type `2` does not support regular triangle `1`."
TriangleConstruct::parallel = "Cevian specification `1` should define a line that is not parallel to the side opposite to the selected vertex in `2`."
TriangleMeasurement::invtri = "`1` expected to specify a nondegenerate triangle in the plane."
TriangleMeasurement::spec = "Improper specification `2` in `1`."
TriangleCenter::invtri = "`1` expected to specify a nondegenerate triangle in the plane."
TriangleCenter::spec = "Improper specification `2` in `1`."
